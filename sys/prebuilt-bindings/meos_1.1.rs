/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const LWFLAG_Z: u32 = 1;
pub const LWFLAG_M: u32 = 2;
pub const LWFLAG_BBOX: u32 = 4;
pub const LWFLAG_GEODETIC: u32 = 8;
pub const LWFLAG_READONLY: u32 = 16;
pub const LWFLAG_SOLID: u32 = 32;
pub const WKB_ISO: u32 = 1;
pub const WKB_SFSQL: u32 = 2;
pub const WKB_EXTENDED: u32 = 4;
pub const WKB_NDR: u32 = 8;
pub const WKB_XDR: u32 = 16;
pub const WKB_HEX: u32 = 32;
pub const WKB_NO_NPOINTS: u32 = 64;
pub const WKB_NO_SRID: u32 = 128;
pub const WKT_ISO: u32 = 1;
pub const WKT_SFSQL: u32 = 2;
pub const WKT_EXTENDED: u32 = 4;
pub const SKIPLIST_MAXLEVEL: u32 = 32;
pub const NO_MEOS_TYPES: u32 = 56;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type Pointer = *mut ::std::os::raw::c_char;
pub type Datum = usize;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type int64 = ::std::os::raw::c_long;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type uint64 = ::std::os::raw::c_ulong;
pub type DateADT = int32;
pub type TimeADT = int64;
pub type Timestamp = int64;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
pub type fsec_t = int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[test]
fn bindgen_test_layout_Interval() {
    const UNINIT: ::std::mem::MaybeUninit<Interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Interval>(),
        16usize,
        concat!("Size of: ", stringify!(Interval))
    );
    assert_eq!(
        ::std::mem::align_of::<Interval>(),
        8usize,
        concat!("Alignment of ", stringify!(Interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(month)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varlena() {
    const UNINIT: ::std::mem::MaybeUninit<varlena> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varlena>(),
        4usize,
        concat!("Size of: ", stringify!(varlena))
    );
    assert_eq!(
        ::std::mem::align_of::<varlena>(),
        1usize,
        concat!("Alignment of ", stringify!(varlena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varlena),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_dat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varlena),
            "::",
            stringify!(vl_dat)
        )
    );
}
pub type text = varlena;
pub type bytea = varlena;
pub type lwflags_t = u16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AFFINE {
    pub afac: f64,
    pub bfac: f64,
    pub cfac: f64,
    pub dfac: f64,
    pub efac: f64,
    pub ffac: f64,
    pub gfac: f64,
    pub hfac: f64,
    pub ifac: f64,
    pub xoff: f64,
    pub yoff: f64,
    pub zoff: f64,
}
#[test]
fn bindgen_test_layout_AFFINE() {
    const UNINIT: ::std::mem::MaybeUninit<AFFINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AFFINE>(),
        96usize,
        concat!("Size of: ", stringify!(AFFINE))
    );
    assert_eq!(
        ::std::mem::align_of::<AFFINE>(),
        8usize,
        concat!("Alignment of ", stringify!(AFFINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).afac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(afac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bfac) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(bfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfac) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(cfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfac) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(dfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).efac) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(efac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ffac) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(ffac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfac) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(gfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfac) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(hfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifac) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(ifac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xoff) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(xoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yoff) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(yoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zoff) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(zoff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BOX3D {
    pub xmin: f64,
    pub ymin: f64,
    pub zmin: f64,
    pub xmax: f64,
    pub ymax: f64,
    pub zmax: f64,
    pub srid: i32,
}
#[test]
fn bindgen_test_layout_BOX3D() {
    const UNINIT: ::std::mem::MaybeUninit<BOX3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BOX3D>(),
        56usize,
        concat!("Size of: ", stringify!(BOX3D))
    );
    assert_eq!(
        ::std::mem::align_of::<BOX3D>(),
        8usize,
        concat!("Alignment of ", stringify!(BOX3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(srid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GBOX {
    pub flags: lwflags_t,
    pub xmin: f64,
    pub xmax: f64,
    pub ymin: f64,
    pub ymax: f64,
    pub zmin: f64,
    pub zmax: f64,
    pub mmin: f64,
    pub mmax: f64,
}
#[test]
fn bindgen_test_layout_GBOX() {
    const UNINIT: ::std::mem::MaybeUninit<GBOX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GBOX>(),
        72usize,
        concat!("Size of: ", stringify!(GBOX))
    );
    assert_eq!(
        ::std::mem::align_of::<GBOX>(),
        8usize,
        concat!("Alignment of ", stringify!(GBOX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmin) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(mmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmax) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(mmax)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPHEROID {
    pub a: f64,
    pub b: f64,
    pub f: f64,
    pub e: f64,
    pub e_sq: f64,
    pub radius: f64,
    pub name: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_SPHEROID() {
    const UNINIT: ::std::mem::MaybeUninit<SPHEROID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SPHEROID>(),
        72usize,
        concat!("Size of: ", stringify!(SPHEROID))
    );
    assert_eq!(
        ::std::mem::align_of::<SPHEROID>(),
        8usize,
        concat!("Alignment of ", stringify!(SPHEROID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_sq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(e_sq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT2D {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_POINT2D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT2D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT2D>(),
        16usize,
        concat!("Size of: ", stringify!(POINT2D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT2D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT2D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3DZ {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_POINT3DZ() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3DZ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3DZ>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3DZ))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3DZ>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3DZ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_POINT3D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3D>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3DM {
    pub x: f64,
    pub y: f64,
    pub m: f64,
}
#[test]
fn bindgen_test_layout_POINT3DM() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3DM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3DM>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3DM))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3DM>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3DM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(m)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT4D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub m: f64,
}
#[test]
fn bindgen_test_layout_POINT4D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT4D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT4D>(),
        32usize,
        concat!("Size of: ", stringify!(POINT4D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT4D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT4D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(m)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINTARRAY {
    pub npoints: u32,
    pub maxpoints: u32,
    pub flags: lwflags_t,
    pub serialized_pointlist: *mut u8,
}
#[test]
fn bindgen_test_layout_POINTARRAY() {
    const UNINIT: ::std::mem::MaybeUninit<POINTARRAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINTARRAY>(),
        24usize,
        concat!("Size of: ", stringify!(POINTARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<POINTARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(POINTARRAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(npoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxpoints) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(maxpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialized_pointlist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(serialized_pointlist)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSERIALIZED {
    pub size: u32,
    pub srid: [u8; 3usize],
    pub gflags: u8,
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_GSERIALIZED() {
    const UNINIT: ::std::mem::MaybeUninit<GSERIALIZED> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSERIALIZED>(),
        12usize,
        concat!("Size of: ", stringify!(GSERIALIZED))
    );
    assert_eq!(
        ::std::mem::align_of::<GSERIALIZED>(),
        4usize,
        concat!("Alignment of ", stringify!(GSERIALIZED))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gflags) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(gflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWGEOM {
    pub bbox: *mut GBOX,
    pub data: *mut ::std::os::raw::c_void,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWGEOM() {
    const UNINIT: ::std::mem::MaybeUninit<LWGEOM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWGEOM>(),
        24usize,
        concat!("Size of: ", stringify!(LWGEOM))
    );
    assert_eq!(
        ::std::mem::align_of::<LWGEOM>(),
        8usize,
        concat!("Alignment of ", stringify!(LWGEOM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPOINT {
    pub bbox: *mut GBOX,
    pub point: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<LWPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPOINT>(),
        24usize,
        concat!("Size of: ", stringify!(LWPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPOINT>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWLINE {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWLINE() {
    const UNINIT: ::std::mem::MaybeUninit<LWLINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWLINE>(),
        24usize,
        concat!("Size of: ", stringify!(LWLINE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWLINE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWLINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWTRIANGLE {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWTRIANGLE() {
    const UNINIT: ::std::mem::MaybeUninit<LWTRIANGLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWTRIANGLE>(),
        24usize,
        concat!("Size of: ", stringify!(LWTRIANGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWTRIANGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWTRIANGLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCIRCSTRING {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWCIRCSTRING() {
    const UNINIT: ::std::mem::MaybeUninit<LWCIRCSTRING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCIRCSTRING>(),
        24usize,
        concat!("Size of: ", stringify!(LWCIRCSTRING))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCIRCSTRING>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCIRCSTRING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPOLY {
    pub bbox: *mut GBOX,
    pub rings: *mut *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub nrings: u32,
    pub maxrings: u32,
}
#[test]
fn bindgen_test_layout_LWPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(rings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(nrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrings) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(maxrings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMPOINT {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOINT,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<LWMPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMPOINT>(),
        32usize,
        concat!("Size of: ", stringify!(LWMPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMPOINT>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMLINE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWLINE,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMLINE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMLINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMLINE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMLINE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMLINE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMLINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMPOLY {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOLY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWMPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWMPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCOLLECTION {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWCOLLECTION() {
    const UNINIT: ::std::mem::MaybeUninit<LWCOLLECTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCOLLECTION>(),
        32usize,
        concat!("Size of: ", stringify!(LWCOLLECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCOLLECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCOLLECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCOMPOUND {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWCOMPOUND() {
    const UNINIT: ::std::mem::MaybeUninit<LWCOMPOUND> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCOMPOUND>(),
        32usize,
        concat!("Size of: ", stringify!(LWCOMPOUND))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCOMPOUND>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCOMPOUND))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCURVEPOLY {
    pub bbox: *mut GBOX,
    pub rings: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub nrings: u32,
    pub maxrings: u32,
}
#[test]
fn bindgen_test_layout_LWCURVEPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWCURVEPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCURVEPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWCURVEPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCURVEPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCURVEPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(rings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(nrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrings) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(maxrings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMCURVE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMCURVE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMCURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMCURVE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMCURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMCURVE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMCURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMSURFACE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMSURFACE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMSURFACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMSURFACE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMSURFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMSURFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMSURFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPSURFACE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOLY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWPSURFACE() {
    const UNINIT: ::std::mem::MaybeUninit<LWPSURFACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPSURFACE>(),
        32usize,
        concat!("Size of: ", stringify!(LWPSURFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPSURFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPSURFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWTIN {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWTRIANGLE,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWTIN() {
    const UNINIT: ::std::mem::MaybeUninit<LWTIN> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWTIN>(),
        32usize,
        concat!("Size of: ", stringify!(LWTIN))
    );
    assert_eq!(
        ::std::mem::align_of::<LWTIN>(),
        8usize,
        concat!("Alignment of ", stringify!(LWTIN))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(maxgeoms)
        )
    );
}
extern "C" {
    pub fn geo_get_srid(g: *const GSERIALIZED) -> int32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJconsts {
    _unused: [u8; 0],
}
pub type PJ = PJconsts;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPROJ {
    pub pj: *mut PJ,
    pub pipeline_is_forward: bool,
    pub source_is_latlong: u8,
    pub source_semi_major_metre: f64,
    pub source_semi_minor_metre: f64,
}
#[test]
fn bindgen_test_layout_LWPROJ() {
    const UNINIT: ::std::mem::MaybeUninit<LWPROJ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPROJ>(),
        32usize,
        concat!("Size of: ", stringify!(LWPROJ))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPROJ>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPROJ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(pj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_is_forward) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(pipeline_is_forward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_is_latlong) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_is_latlong)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_semi_major_metre) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_semi_major_metre)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_semi_minor_metre) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_semi_minor_metre)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Set {
    pub vl_len_: int32,
    pub settype: uint8,
    pub basetype: uint8,
    pub flags: int16,
    pub count: int32,
    pub maxcount: int32,
    pub bboxsize: int16,
}
#[test]
fn bindgen_test_layout_Set() {
    const UNINIT: ::std::mem::MaybeUninit<Set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Set>(),
        20usize,
        concat!("Size of: ", stringify!(Set))
    );
    assert_eq!(
        ::std::mem::align_of::<Set>(),
        4usize,
        concat!("Alignment of ", stringify!(Set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(settype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(bboxsize)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Span {
    pub spantype: uint8,
    pub basetype: uint8,
    pub lower_inc: bool,
    pub upper_inc: bool,
    pub padding: [::std::os::raw::c_char; 4usize],
    pub lower: Datum,
    pub upper: Datum,
}
#[test]
fn bindgen_test_layout_Span() {
    const UNINIT: ::std::mem::MaybeUninit<Span> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Span>(),
        24usize,
        concat!("Size of: ", stringify!(Span))
    );
    assert_eq!(
        ::std::mem::align_of::<Span>(),
        8usize,
        concat!("Alignment of ", stringify!(Span))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(spantype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_inc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(lower_inc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper_inc) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(upper_inc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(upper)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpanSet {
    pub vl_len_: int32,
    pub spansettype: uint8,
    pub spantype: uint8,
    pub basetype: uint8,
    pub padding: ::std::os::raw::c_char,
    pub count: int32,
    pub maxcount: int32,
    pub span: Span,
    pub elems: [Span; 1usize],
}
#[test]
fn bindgen_test_layout_SpanSet() {
    const UNINIT: ::std::mem::MaybeUninit<SpanSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SpanSet>(),
        64usize,
        concat!("Size of: ", stringify!(SpanSet))
    );
    assert_eq!(
        ::std::mem::align_of::<SpanSet>(),
        8usize,
        concat!("Alignment of ", stringify!(SpanSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spansettype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(spansettype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(spantype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).span) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(span)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(elems)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBox {
    pub period: Span,
    pub span: Span,
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_TBox() {
    const UNINIT: ::std::mem::MaybeUninit<TBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TBox>(),
        56usize,
        concat!("Size of: ", stringify!(TBox))
    );
    assert_eq!(
        ::std::mem::align_of::<TBox>(),
        8usize,
        concat!("Alignment of ", stringify!(TBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).span) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(span)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STBox {
    pub period: Span,
    pub xmin: f64,
    pub ymin: f64,
    pub zmin: f64,
    pub xmax: f64,
    pub ymax: f64,
    pub zmax: f64,
    pub srid: int32,
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_STBox() {
    const UNINIT: ::std::mem::MaybeUninit<STBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<STBox>(),
        80usize,
        concat!("Size of: ", stringify!(STBox))
    );
    assert_eq!(
        ::std::mem::align_of::<STBox>(),
        8usize,
        concat!("Alignment of ", stringify!(STBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(flags)
        )
    );
}
pub const tempSubtype_ANYTEMPSUBTYPE: tempSubtype = 0;
pub const tempSubtype_TINSTANT: tempSubtype = 1;
pub const tempSubtype_TSEQUENCE: tempSubtype = 2;
pub const tempSubtype_TSEQUENCESET: tempSubtype = 3;
pub type tempSubtype = ::std::os::raw::c_uint;
pub const interpType_INTERP_NONE: interpType = 0;
pub const interpType_DISCRETE: interpType = 1;
pub const interpType_STEP: interpType = 2;
pub const interpType_LINEAR: interpType = 3;
pub type interpType = ::std::os::raw::c_uint;
pub const spatialRel_INTERSECTS: spatialRel = 0;
pub const spatialRel_CONTAINS: spatialRel = 1;
pub const spatialRel_TOUCHES: spatialRel = 2;
pub const spatialRel_COVERS: spatialRel = 3;
pub type spatialRel = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Temporal {
    pub vl_len_: int32,
    pub temptype: uint8,
    pub subtype: uint8,
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_Temporal() {
    const UNINIT: ::std::mem::MaybeUninit<Temporal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Temporal>(),
        8usize,
        concat!("Size of: ", stringify!(Temporal))
    );
    assert_eq!(
        ::std::mem::align_of::<Temporal>(),
        4usize,
        concat!("Alignment of ", stringify!(Temporal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TInstant {
    pub vl_len_: int32,
    pub temptype: uint8,
    pub subtype: uint8,
    pub flags: int16,
    pub t: TimestampTz,
    pub value: Datum,
}
#[test]
fn bindgen_test_layout_TInstant() {
    const UNINIT: ::std::mem::MaybeUninit<TInstant> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TInstant>(),
        24usize,
        concat!("Size of: ", stringify!(TInstant))
    );
    assert_eq!(
        ::std::mem::align_of::<TInstant>(),
        8usize,
        concat!("Alignment of ", stringify!(TInstant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSequence {
    pub vl_len_: int32,
    pub temptype: uint8,
    pub subtype: uint8,
    pub flags: int16,
    pub count: int32,
    pub maxcount: int32,
    pub bboxsize: int16,
    pub padding: [::std::os::raw::c_char; 6usize],
    pub period: Span,
}
#[test]
fn bindgen_test_layout_TSequence() {
    const UNINIT: ::std::mem::MaybeUninit<TSequence> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSequence>(),
        48usize,
        concat!("Size of: ", stringify!(TSequence))
    );
    assert_eq!(
        ::std::mem::align_of::<TSequence>(),
        8usize,
        concat!("Alignment of ", stringify!(TSequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(bboxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSequenceSet {
    pub vl_len_: int32,
    pub temptype: uint8,
    pub subtype: uint8,
    pub flags: int16,
    pub count: int32,
    pub totalcount: int32,
    pub maxcount: int32,
    pub bboxsize: int16,
    pub padding: int16,
    pub period: Span,
}
#[test]
fn bindgen_test_layout_TSequenceSet() {
    const UNINIT: ::std::mem::MaybeUninit<TSequenceSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSequenceSet>(),
        48usize,
        concat!("Size of: ", stringify!(TSequenceSet))
    );
    assert_eq!(
        ::std::mem::align_of::<TSequenceSet>(),
        8usize,
        concat!("Alignment of ", stringify!(TSequenceSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(totalcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(bboxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Match {
    pub i: ::std::os::raw::c_int,
    pub j: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Match() {
    const UNINIT: ::std::mem::MaybeUninit<Match> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Match>(),
        8usize,
        concat!("Size of: ", stringify!(Match))
    );
    assert_eq!(
        ::std::mem::align_of::<Match>(),
        4usize,
        concat!("Alignment of ", stringify!(Match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Match), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Match), "::", stringify!(j))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkipListElem {
    pub value: *mut ::std::os::raw::c_void,
    pub height: ::std::os::raw::c_int,
    pub next: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_SkipListElem() {
    const UNINIT: ::std::mem::MaybeUninit<SkipListElem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SkipListElem>(),
        144usize,
        concat!("Size of: ", stringify!(SkipListElem))
    );
    assert_eq!(
        ::std::mem::align_of::<SkipListElem>(),
        8usize,
        concat!("Alignment of ", stringify!(SkipListElem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkipList {
    pub capacity: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub freed: *mut ::std::os::raw::c_int,
    pub freecount: ::std::os::raw::c_int,
    pub freecap: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
    pub extra: *mut ::std::os::raw::c_void,
    pub extrasize: usize,
    pub elems: *mut SkipListElem,
}
#[test]
fn bindgen_test_layout_SkipList() {
    const UNINIT: ::std::mem::MaybeUninit<SkipList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SkipList>(),
        64usize,
        concat!("Size of: ", stringify!(SkipList))
    );
    assert_eq!(
        ::std::mem::align_of::<SkipList>(),
        8usize,
        concat!("Alignment of ", stringify!(SkipList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freecount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freecount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freecap) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freecap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extrasize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(extrasize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(elems)
        )
    );
}
pub const errorCode_MEOS_SUCCESS: errorCode = 0;
pub const errorCode_MEOS_ERR_INTERNAL_ERROR: errorCode = 1;
pub const errorCode_MEOS_ERR_INTERNAL_TYPE_ERROR: errorCode = 2;
pub const errorCode_MEOS_ERR_VALUE_OUT_OF_RANGE: errorCode = 3;
pub const errorCode_MEOS_ERR_DIVISION_BY_ZERO: errorCode = 4;
pub const errorCode_MEOS_ERR_MEMORY_ALLOC_ERROR: errorCode = 5;
pub const errorCode_MEOS_ERR_AGGREGATION_ERROR: errorCode = 6;
pub const errorCode_MEOS_ERR_DIRECTORY_ERROR: errorCode = 7;
pub const errorCode_MEOS_ERR_FILE_ERROR: errorCode = 8;
pub const errorCode_MEOS_ERR_INVALID_ARG: errorCode = 10;
pub const errorCode_MEOS_ERR_INVALID_ARG_TYPE: errorCode = 11;
pub const errorCode_MEOS_ERR_INVALID_ARG_VALUE: errorCode = 12;
pub const errorCode_MEOS_ERR_MFJSON_INPUT: errorCode = 20;
pub const errorCode_MEOS_ERR_MFJSON_OUTPUT: errorCode = 21;
pub const errorCode_MEOS_ERR_TEXT_INPUT: errorCode = 22;
pub const errorCode_MEOS_ERR_TEXT_OUTPUT: errorCode = 23;
pub const errorCode_MEOS_ERR_WKB_INPUT: errorCode = 24;
pub const errorCode_MEOS_ERR_WKB_OUTPUT: errorCode = 25;
pub const errorCode_MEOS_ERR_GEOJSON_INPUT: errorCode = 26;
pub const errorCode_MEOS_ERR_GEOJSON_OUTPUT: errorCode = 27;
pub type errorCode = ::std::os::raw::c_uint;
extern "C" {
    pub fn meos_error(
        errlevel: ::std::os::raw::c_int,
        errcode: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn meos_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_set(err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_restore(err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_reset() -> ::std::os::raw::c_int;
}
pub type error_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn meos_initialize_timezone(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn meos_initialize_error_handler(err_handler: error_handler_fn);
}
extern "C" {
    pub fn meos_finalize_timezone();
}
extern "C" {
    pub fn meos_set_datestyle(
        newval: *mut ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn meos_set_intervalstyle(
        newval: *mut ::std::os::raw::c_char,
        extra: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn meos_get_datestyle() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn meos_get_intervalstyle() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn meos_initialize(tz_str: *const ::std::os::raw::c_char, err_handler: error_handler_fn);
}
extern "C" {
    pub fn meos_finalize();
}
extern "C" {
    pub fn add_date_int(d: DateADT, days: int32) -> DateADT;
}
extern "C" {
    pub fn add_interval_interval(
        interv1: *const Interval,
        interv2: *const Interval,
    ) -> *mut Interval;
}
extern "C" {
    pub fn add_timestamptz_interval(t: TimestampTz, interv: *const Interval) -> TimestampTz;
}
extern "C" {
    pub fn bool_in(str_: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn bool_out(b: bool) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cstring2text(str_: *const ::std::os::raw::c_char) -> *mut text;
}
extern "C" {
    pub fn date_to_timestamptz(d: DateADT) -> TimestampTz;
}
extern "C" {
    pub fn minus_date_date(d1: DateADT, d2: DateADT) -> *mut Interval;
}
extern "C" {
    pub fn minus_date_int(d: DateADT, days: int32) -> DateADT;
}
extern "C" {
    pub fn minus_timestamptz_interval(t: TimestampTz, interv: *const Interval) -> TimestampTz;
}
extern "C" {
    pub fn minus_timestamptz_timestamptz(t1: TimestampTz, t2: TimestampTz) -> *mut Interval;
}
extern "C" {
    pub fn mult_interval_double(interv: *const Interval, factor: f64) -> *mut Interval;
}
extern "C" {
    pub fn pg_date_in(str_: *const ::std::os::raw::c_char) -> DateADT;
}
extern "C" {
    pub fn pg_date_out(d: DateADT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_interval_cmp(
        interv1: *const Interval,
        interv2: *const Interval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_interval_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> *mut Interval;
}
extern "C" {
    pub fn pg_interval_make(
        years: int32,
        months: int32,
        weeks: int32,
        days: int32,
        hours: int32,
        mins: int32,
        secs: f64,
    ) -> *mut Interval;
}
extern "C" {
    pub fn pg_interval_out(interv: *const Interval) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_time_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> TimeADT;
}
extern "C" {
    pub fn pg_time_out(t: TimeADT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_timestamp_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> Timestamp;
}
extern "C" {
    pub fn pg_timestamp_out(t: Timestamp) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_timestamptz_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> TimestampTz;
}
extern "C" {
    pub fn pg_timestamptz_out(t: TimestampTz) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text2cstring(txt: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_cmp(txt1: *const text, txt2: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn text_copy(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_initcap(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_lower(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_out(txt: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_upper(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn textcat_text_text(txt1: *const text, txt2: *const text) -> *mut text;
}
extern "C" {
    pub fn timestamptz_to_date(t: TimestampTz) -> DateADT;
}
extern "C" {
    pub fn geo_as_ewkb(
        gs: *const GSERIALIZED,
        endian: *const ::std::os::raw::c_char,
        size: *mut usize,
    ) -> *mut u8;
}
extern "C" {
    pub fn geo_as_ewkt(
        gs: *const GSERIALIZED,
        precision: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_geojson(
        gs: *const GSERIALIZED,
        option: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
        srs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_hexewkb(
        gs: *const GSERIALIZED,
        endian: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_text(
        gs: *const GSERIALIZED,
        precision: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_from_ewkb(wkb: *const u8, wkb_size: usize, srid: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_from_geojson(geojson: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_out(gs: *const GSERIALIZED) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_same(gs1: *const GSERIALIZED, gs2: *const GSERIALIZED) -> bool;
}
extern "C" {
    pub fn geography_from_hexewkb(wkt: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geography_from_text(
        wkt: *mut ::std::os::raw::c_char,
        srid: ::std::os::raw::c_int,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geometry_from_hexewkb(wkt: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geometry_from_text(
        wkt: *mut ::std::os::raw::c_char,
        srid: ::std::os::raw::c_int,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn pgis_geography_in(str_: *mut ::std::os::raw::c_char, typmod: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn pgis_geometry_in(str_: *mut ::std::os::raw::c_char, typmod: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn bigintset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn bigintset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bigintspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn bigintspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bigintspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn bigintspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dateset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn dateset_out(s: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn datespan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn datespan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn datespanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn datespanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn floatset_out(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn floatspan_out(
        s: *const Span,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_out(
        ss: *const SpanSet,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geogset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn geomset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn geoset_as_ewkt(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geoset_as_text(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geoset_out(set: *const Set, maxdd: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn intset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn intspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn intspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn set_as_hexwkb(
        s: *const Set,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn set_as_wkb(s: *const Set, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn set_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn set_from_wkb(wkb: *const u8, size: usize) -> *mut Set;
}
extern "C" {
    pub fn span_as_hexwkb(
        s: *const Span,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn span_as_wkb(s: *const Span, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn span_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn span_from_wkb(wkb: *const u8, size: usize) -> *mut Span;
}
extern "C" {
    pub fn spanset_as_hexwkb(
        ss: *const SpanSet,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn spanset_as_wkb(ss: *const SpanSet, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn spanset_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_from_wkb(wkb: *const u8, size: usize) -> *mut SpanSet;
}
extern "C" {
    pub fn textset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn textset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn tstzset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn tstzspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bigintset_make(values: *const int64, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn bigintspan_make(
        lower: int64,
        upper: int64,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn dateset_make(values: *const DateADT, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn datespan_make(
        lower: DateADT,
        upper: DateADT,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn floatset_make(values: *const f64, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn floatspan_make(lower: f64, upper: f64, lower_inc: bool, upper_inc: bool) -> *mut Span;
}
extern "C" {
    pub fn geoset_make(values: *mut *const GSERIALIZED, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn intset_make(
        values: *const ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> *mut Set;
}
extern "C" {
    pub fn intspan_make(
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn set_copy(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn span_copy(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn spanset_copy(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_make(
        spans: *mut Span,
        count: ::std::os::raw::c_int,
        normalize: bool,
        order: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn textset_make(values: *mut *const text, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn tstzset_make(values: *const TimestampTz, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_make(
        lower: TimestampTz,
        upper: TimestampTz,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn bigint_to_set(i: int64) -> *mut Set;
}
extern "C" {
    pub fn bigint_to_span(i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn bigint_to_spanset(i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn date_to_set(d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn date_to_span(d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn date_to_spanset(d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn dateset_to_tstzset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn datespan_to_tstzspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn datespanset_to_tstzspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn float_to_set(d: f64) -> *mut Set;
}
extern "C" {
    pub fn float_to_span(d: f64) -> *mut Span;
}
extern "C" {
    pub fn float_to_spanset(d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn floatset_to_intset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatspan_to_intspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspanset_to_intspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn geo_to_set(gs: *mut GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn int_to_set(i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn int_to_span(i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn int_to_spanset(i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn intset_to_floatset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intspan_to_floatspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn intspanset_to_floatspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn set_to_spanset(s: *const Set) -> *mut SpanSet;
}
extern "C" {
    pub fn span_to_spanset(s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn text_to_set(txt: *mut text) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_to_set(t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_to_span(t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_to_spanset(t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzset_to_dateset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_to_datespan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn tstzspanset_to_datespanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn bigintset_end_value(s: *const Set) -> int64;
}
extern "C" {
    pub fn bigintset_start_value(s: *const Set) -> int64;
}
extern "C" {
    pub fn bigintset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut int64) -> bool;
}
extern "C" {
    pub fn bigintset_values(s: *const Set) -> *mut int64;
}
extern "C" {
    pub fn bigintspan_lower(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspan_upper(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspan_width(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspanset_lower(ss: *const SpanSet) -> int64;
}
extern "C" {
    pub fn bigintspanset_upper(ss: *const SpanSet) -> int64;
}
extern "C" {
    pub fn bigintspanset_width(ss: *const SpanSet, boundspan: bool) -> int64;
}
extern "C" {
    pub fn dateset_end_value(s: *const Set) -> DateADT;
}
extern "C" {
    pub fn dateset_start_value(s: *const Set) -> DateADT;
}
extern "C" {
    pub fn dateset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut DateADT) -> bool;
}
extern "C" {
    pub fn dateset_values(s: *const Set) -> *mut DateADT;
}
extern "C" {
    pub fn datespan_duration(s: *const Span) -> *mut Interval;
}
extern "C" {
    pub fn datespan_lower(s: *const Span) -> DateADT;
}
extern "C" {
    pub fn datespan_upper(s: *const Span) -> DateADT;
}
extern "C" {
    pub fn datespanset_date_n(
        ss: *const SpanSet,
        n: ::std::os::raw::c_int,
        result: *mut DateADT,
    ) -> bool;
}
extern "C" {
    pub fn datespanset_dates(ss: *const SpanSet) -> *mut Set;
}
extern "C" {
    pub fn datespanset_duration(ss: *const SpanSet, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn datespanset_end_date(ss: *const SpanSet) -> DateADT;
}
extern "C" {
    pub fn datespanset_num_dates(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datespanset_start_date(ss: *const SpanSet) -> DateADT;
}
extern "C" {
    pub fn floatset_end_value(s: *const Set) -> f64;
}
extern "C" {
    pub fn floatset_start_value(s: *const Set) -> f64;
}
extern "C" {
    pub fn floatset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut f64) -> bool;
}
extern "C" {
    pub fn floatset_values(s: *const Set) -> *mut f64;
}
extern "C" {
    pub fn floatspan_lower(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspan_upper(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspan_width(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspanset_lower(ss: *const SpanSet) -> f64;
}
extern "C" {
    pub fn floatspanset_upper(ss: *const SpanSet) -> f64;
}
extern "C" {
    pub fn floatspanset_width(ss: *const SpanSet, boundspan: bool) -> f64;
}
extern "C" {
    pub fn geoset_end_value(s: *const Set) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geoset_srid(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geoset_start_value(s: *const Set) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geoset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn geoset_values(s: *const Set) -> *mut *mut GSERIALIZED;
}
extern "C" {
    pub fn intset_end_value(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intset_start_value(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn intset_values(s: *const Set) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_lower(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_upper(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_width(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_lower(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_upper(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_width(ss: *const SpanSet, boundspan: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_hash(s: *const Set) -> uint32;
}
extern "C" {
    pub fn set_hash_extended(s: *const Set, seed: uint64) -> uint64;
}
extern "C" {
    pub fn set_num_values(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_to_span(s: *const Set) -> *mut Span;
}
extern "C" {
    pub fn span_hash(s: *const Span) -> uint32;
}
extern "C" {
    pub fn span_hash_extended(s: *const Span, seed: uint64) -> uint64;
}
extern "C" {
    pub fn span_lower_inc(s: *const Span) -> bool;
}
extern "C" {
    pub fn span_upper_inc(s: *const Span) -> bool;
}
extern "C" {
    pub fn spanset_end_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_hash(ss: *const SpanSet) -> uint32;
}
extern "C" {
    pub fn spanset_hash_extended(ss: *const SpanSet, seed: uint64) -> uint64;
}
extern "C" {
    pub fn spanset_lower_inc(ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_num_spans(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spanset_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_span_n(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn spanset_spanarr(ss: *const SpanSet) -> *mut *mut Span;
}
extern "C" {
    pub fn spanset_start_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_upper_inc(ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn textset_end_value(s: *const Set) -> *mut text;
}
extern "C" {
    pub fn textset_start_value(s: *const Set) -> *mut text;
}
extern "C" {
    pub fn textset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut *mut text)
        -> bool;
}
extern "C" {
    pub fn textset_values(s: *const Set) -> *mut *mut text;
}
extern "C" {
    pub fn tstzset_end_value(s: *const Set) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_start_value(s: *const Set) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn tstzset_values(s: *const Set) -> *mut TimestampTz;
}
extern "C" {
    pub fn tstzspan_duration(s: *const Span) -> *mut Interval;
}
extern "C" {
    pub fn tstzspan_lower(s: *const Span) -> TimestampTz;
}
extern "C" {
    pub fn tstzspan_upper(s: *const Span) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_duration(ss: *const SpanSet, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn tstzspanset_end_timestamptz(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_lower(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_num_timestamps(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tstzspanset_start_timestamptz(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_timestamptz_n(
        ss: *const SpanSet,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn tstzspanset_timestamps(ss: *const SpanSet) -> *mut Set;
}
extern "C" {
    pub fn tstzspanset_upper(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn bigintset_shift_scale(
        s: *const Set,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn bigintspan_shift_scale(
        s: *const Span,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn bigintspanset_shift_scale(
        ss: *const SpanSet,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn dateset_shift_scale(
        s: *const Set,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn datespan_shift_scale(
        s: *const Span,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn datespanset_shift_scale(
        ss: *const SpanSet,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn floatset_ceil(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_floor(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_degrees(s: *const Set, normalize: bool) -> *mut Set;
}
extern "C" {
    pub fn floatset_radians(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_round(s: *const Set, maxdd: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn floatset_shift_scale(
        s: *const Set,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn floatspan_ceil(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspan_floor(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspan_round(s: *const Span, maxdd: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn floatspan_shift_scale(
        s: *const Span,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn floatspanset_ceil(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_floor(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_round(ss: *const SpanSet, maxdd: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_shift_scale(
        ss: *const SpanSet,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn geoset_round(s: *const Set, maxdd: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn geoset_set_srid(s: *const Set, srid: int32) -> *mut Set;
}
extern "C" {
    pub fn geoset_transform(s: *const Set, srid: int32) -> *mut Set;
}
extern "C" {
    pub fn geoset_transform_pipeline(
        s: *const Set,
        pipelinestr: *const ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn intset_shift_scale(
        s: *const Set,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn intspan_shift_scale(
        s: *const Span,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn intspanset_shift_scale(
        ss: *const SpanSet,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn point_transform(gs: *const GSERIALIZED, srid: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn point_transform_pipeline(
        gs: *const GSERIALIZED,
        pipelinestr: *const ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn set_spans(s: *const Set) -> *mut Span;
}
extern "C" {
    pub fn set_split_each_n_spans(
        s: *const Set,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn set_split_n_spans(
        s: *const Set,
        span_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn spanset_spans(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_split_each_n_spans(
        ss: *const SpanSet,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn spanset_split_n_spans(
        ss: *const SpanSet,
        span_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn textset_initcap(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textset_lower(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textset_upper(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textcat_textset_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn textcat_text_textset(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_tprecision(
        t: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_shift_scale(
        s: *const Set,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Set;
}
extern "C" {
    pub fn tstzset_tprecision(
        s: *const Set,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_shift_scale(
        s: *const Span,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Span;
}
extern "C" {
    pub fn tstzspan_tprecision(
        s: *const Span,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut Span;
}
extern "C" {
    pub fn tstzspanset_shift_scale(
        ss: *const SpanSet,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzspanset_tprecision(
        ss: *const SpanSet,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn set_cmp(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_eq(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_ge(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_gt(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_le(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_lt(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_ne(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn span_cmp(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn span_eq(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_ge(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_gt(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_le(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_lt(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_ne(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn spanset_cmp(ss1: *const SpanSet, ss2: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spanset_eq(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_ge(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_gt(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_le(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_lt(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_ne(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn adjacent_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn adjacent_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn adjacent_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn adjacent_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn adjacent_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn adjacent_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_geo_set(gs: *mut GSERIALIZED, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn contained_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn contained_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn contains_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn contains_set_geo(s: *const Set, gs: *mut GSERIALIZED) -> bool;
}
extern "C" {
    pub fn contains_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn contains_set_text(s: *const Set, t: *mut text) -> bool;
}
extern "C" {
    pub fn contains_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn contains_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn contains_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn contains_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn contains_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn contains_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn contains_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn contains_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overlaps_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overlaps_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overlaps_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn after_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn after_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn after_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn after_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn before_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn before_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn before_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn before_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn left_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn left_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn left_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn left_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn left_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn left_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn left_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn left_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn left_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overafter_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overbefore_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn overbefore_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overbefore_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn overleft_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn overright_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn overright_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overright_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn overright_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn overright_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn overright_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overright_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn overright_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn overright_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn right_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn right_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn right_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn right_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn right_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn right_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn right_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn right_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn right_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn intersection_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn intersection_span_bigint(s: *const Span, i: int64) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_date(s: *const Span, d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_float(s: *const Span, d: f64) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_span(s1: *const Span, s2: *const Span) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn intersection_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_bigint_span(i: int64, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_bigint_spanset(i: int64, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_date_span(d: DateADT, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_date_spanset(d: DateADT, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_float_span(d: f64, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_float_spanset(d: f64, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_int_span(i: ::std::os::raw::c_int, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn minus_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn minus_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn minus_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn minus_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn minus_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn minus_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn minus_span_bigint(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_date(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_float(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_span(s1: *const Span, s2: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_timestamptz_span(t: TimestampTz, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_bigint_span(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_bigint_spanset(i: int64, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_date_span(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_date_spanset(d: DateADT, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_float_span(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_float_spanset(d: f64, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_int_span(i: ::std::os::raw::c_int, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_int_spanset(i: ::std::os::raw::c_int, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn union_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn union_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn union_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn union_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn union_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn union_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn union_span_bigint(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_date(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_float(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_span(s1: *const Span, s2: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn union_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_timestamptz_span(t: TimestampTz, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_timestamptz_spanset(t: TimestampTz, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn distance_bigintset_bigintset(s1: *const Set, s2: *const Set) -> int64;
}
extern "C" {
    pub fn distance_bigintspan_bigintspan(s1: *const Span, s2: *const Span) -> int64;
}
extern "C" {
    pub fn distance_bigintspanset_bigintspan(ss: *const SpanSet, s: *const Span) -> int64;
}
extern "C" {
    pub fn distance_bigintspanset_bigintspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> int64;
}
extern "C" {
    pub fn distance_dateset_dateset(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespan_datespan(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespanset_datespan(
        ss: *const SpanSet,
        s: *const Span,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespanset_datespanset(
        ss1: *const SpanSet,
        ss2: *const SpanSet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_floatset_floatset(s1: *const Set, s2: *const Set) -> f64;
}
extern "C" {
    pub fn distance_floatspan_floatspan(s1: *const Span, s2: *const Span) -> f64;
}
extern "C" {
    pub fn distance_floatspanset_floatspan(ss: *const SpanSet, s: *const Span) -> f64;
}
extern "C" {
    pub fn distance_floatspanset_floatspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> f64;
}
extern "C" {
    pub fn distance_intset_intset(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspan_intspan(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspanset_intspan(ss: *const SpanSet, s: *const Span)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspanset_intspanset(
        ss1: *const SpanSet,
        ss2: *const SpanSet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_bigint(s: *const Set, i: int64) -> int64;
}
extern "C" {
    pub fn distance_set_date(s: *const Set, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_float(s: *const Set, d: f64) -> f64;
}
extern "C" {
    pub fn distance_set_int(s: *const Set, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_timestamptz(s: *const Set, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_span_bigint(s: *const Span, i: int64) -> int64;
}
extern "C" {
    pub fn distance_span_date(s: *const Span, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_span_float(s: *const Span, d: f64) -> f64;
}
extern "C" {
    pub fn distance_span_int(s: *const Span, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_span_timestamptz(s: *const Span, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_spanset_bigint(ss: *const SpanSet, i: int64) -> int64;
}
extern "C" {
    pub fn distance_spanset_date(ss: *const SpanSet, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_spanset_float(ss: *const SpanSet, d: f64) -> f64;
}
extern "C" {
    pub fn distance_spanset_int(
        ss: *const SpanSet,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_tstzset_tstzset(s1: *const Set, s2: *const Set) -> f64;
}
extern "C" {
    pub fn distance_tstzspan_tstzspan(s1: *const Span, s2: *const Span) -> f64;
}
extern "C" {
    pub fn distance_tstzspanset_tstzspan(ss: *const SpanSet, s: *const Span) -> f64;
}
extern "C" {
    pub fn distance_tstzspanset_tstzspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> f64;
}
extern "C" {
    pub fn bigint_extent_transfn(state: *mut Span, i: int64) -> *mut Span;
}
extern "C" {
    pub fn bigint_union_transfn(state: *mut Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn date_extent_transfn(state: *mut Span, d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn date_union_transfn(state: *mut Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn float_extent_transfn(state: *mut Span, d: f64) -> *mut Span;
}
extern "C" {
    pub fn float_union_transfn(state: *mut Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn int_extent_transfn(state: *mut Span, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn int_union_transfn(state: *mut Set, i: int32) -> *mut Set;
}
extern "C" {
    pub fn set_extent_transfn(state: *mut Span, s: *const Set) -> *mut Span;
}
extern "C" {
    pub fn set_union_finalfn(state: *mut Set) -> *mut Set;
}
extern "C" {
    pub fn set_union_transfn(state: *mut Set, s: *mut Set) -> *mut Set;
}
extern "C" {
    pub fn span_extent_transfn(state: *mut Span, s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn span_union_transfn(state: *mut SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_extent_transfn(state: *mut Span, ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_union_finalfn(state: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_union_transfn(state: *mut SpanSet, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn text_union_transfn(state: *mut Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_extent_transfn(state: *mut Span, t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_union_transfn(state: *mut Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn tbox_in(str_: *const ::std::os::raw::c_char) -> *mut TBox;
}
extern "C" {
    pub fn tbox_out(box_: *const TBox, maxdd: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tbox_from_wkb(wkb: *const u8, size: usize) -> *mut TBox;
}
extern "C" {
    pub fn tbox_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut TBox;
}
extern "C" {
    pub fn stbox_from_wkb(wkb: *const u8, size: usize) -> *mut STBox;
}
extern "C" {
    pub fn stbox_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut STBox;
}
extern "C" {
    pub fn tbox_as_wkb(box_: *const TBox, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn tbox_as_hexwkb(
        box_: *const TBox,
        variant: u8,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stbox_as_wkb(box_: *const STBox, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn stbox_as_hexwkb(
        box_: *const STBox,
        variant: u8,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stbox_in(str_: *const ::std::os::raw::c_char) -> *mut STBox;
}
extern "C" {
    pub fn stbox_out(
        box_: *const STBox,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn float_tstzspan_to_tbox(d: f64, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn float_timestamptz_to_tbox(d: f64, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn geo_tstzspan_to_stbox(gs: *const GSERIALIZED, s: *const Span) -> *mut STBox;
}
extern "C" {
    pub fn geo_timestamptz_to_stbox(gs: *const GSERIALIZED, t: TimestampTz) -> *mut STBox;
}
extern "C" {
    pub fn int_tstzspan_to_tbox(i: ::std::os::raw::c_int, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn int_timestamptz_to_tbox(i: ::std::os::raw::c_int, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn numspan_tstzspan_to_tbox(span: *const Span, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn numspan_timestamptz_to_tbox(span: *const Span, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn stbox_copy(box_: *const STBox) -> *mut STBox;
}
extern "C" {
    pub fn stbox_make(
        hasx: bool,
        hasz: bool,
        geodetic: bool,
        srid: int32,
        xmin: f64,
        xmax: f64,
        ymin: f64,
        ymax: f64,
        zmin: f64,
        zmax: f64,
        s: *const Span,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tbox_copy(box_: *const TBox) -> *mut TBox;
}
extern "C" {
    pub fn tbox_make(s: *const Span, p: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn float_to_tbox(d: f64) -> *mut TBox;
}
extern "C" {
    pub fn geo_to_stbox(gs: *const GSERIALIZED) -> *mut STBox;
}
extern "C" {
    pub fn int_to_tbox(i: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn set_to_tbox(s: *const Set) -> *mut TBox;
}
extern "C" {
    pub fn span_to_tbox(s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn spanset_to_tbox(ss: *const SpanSet) -> *mut TBox;
}
extern "C" {
    pub fn spatialset_to_stbox(s: *const Set) -> *mut STBox;
}
extern "C" {
    pub fn stbox_to_gbox(box_: *const STBox) -> *mut GBOX;
}
extern "C" {
    pub fn stbox_to_box3d(box_: *const STBox) -> *mut BOX3D;
}
extern "C" {
    pub fn stbox_to_geo(box_: *const STBox) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn stbox_to_tstzspan(box_: *const STBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_intspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_floatspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_tstzspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_to_stbox(t: TimestampTz) -> *mut STBox;
}
extern "C" {
    pub fn timestamptz_to_tbox(t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn tstzset_to_stbox(s: *const Set) -> *mut STBox;
}
extern "C" {
    pub fn tstzspan_to_stbox(s: *const Span) -> *mut STBox;
}
extern "C" {
    pub fn tstzspanset_to_stbox(ss: *const SpanSet) -> *mut STBox;
}
extern "C" {
    pub fn tnumber_to_tbox(temp: *const Temporal) -> *mut TBox;
}
extern "C" {
    pub fn tpoint_to_stbox(temp: *const Temporal) -> *mut STBox;
}
extern "C" {
    pub fn stbox_area(box_: *const STBox, spheroid: bool) -> f64;
}
extern "C" {
    pub fn stbox_hast(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_hasx(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_hasz(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_isgeodetic(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_perimeter(box_: *const STBox, spheroid: bool) -> f64;
}
extern "C" {
    pub fn stbox_srid(box_: *const STBox) -> int32;
}
extern "C" {
    pub fn stbox_tmax(box_: *const STBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn stbox_tmax_inc(box_: *const STBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn stbox_tmin(box_: *const STBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn stbox_tmin_inc(box_: *const STBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn stbox_xmax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_xmin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_ymax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_ymin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_zmax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_zmin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_hast(box_: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_hasx(box_: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_tmax(box_: *const TBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn tbox_tmax_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_tmin(box_: *const TBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn tbox_tmin_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_xmax(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_xmax_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_xmin(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_xmin_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tboxfloat_xmax(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tboxfloat_xmin(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tboxint_xmax(box_: *const TBox, result: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn tboxint_xmin(box_: *const TBox, result: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn stbox_expand_space(box_: *const STBox, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn stbox_expand_time(box_: *const STBox, interv: *const Interval) -> *mut STBox;
}
extern "C" {
    pub fn stbox_get_space(box_: *const STBox) -> *mut STBox;
}
extern "C" {
    pub fn stbox_quad_split(box_: *const STBox, count: *mut ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn stbox_round(box_: *const STBox, maxdd: ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn stbox_set_srid(box_: *const STBox, srid: int32) -> *mut STBox;
}
extern "C" {
    pub fn stbox_shift_scale_time(
        box_: *const STBox,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_transform(box_: *const STBox, srid: int32) -> *mut STBox;
}
extern "C" {
    pub fn stbox_transform_pipeline(
        box_: *const STBox,
        pipelinestr: *const ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stboxarr_round(
        boxarr: *const STBox,
        count: ::std::os::raw::c_int,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tbox_expand_time(box_: *const TBox, interv: *const Interval) -> *mut TBox;
}
extern "C" {
    pub fn tbox_expand_float(box_: *const TBox, d: f64) -> *mut TBox;
}
extern "C" {
    pub fn tbox_expand_int(box_: *const TBox, i: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn tbox_round(box_: *const TBox, maxdd: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_float(
        box_: *const TBox,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_int(
        box_: *const TBox,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_time(
        box_: *const TBox,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut TBox;
}
extern "C" {
    pub fn union_tbox_tbox(box1: *const TBox, box2: *const TBox, strict: bool) -> *mut TBox;
}
extern "C" {
    pub fn intersection_tbox_tbox(box1: *const TBox, box2: *const TBox) -> *mut TBox;
}
extern "C" {
    pub fn union_stbox_stbox(box1: *const STBox, box2: *const STBox, strict: bool) -> *mut STBox;
}
extern "C" {
    pub fn intersection_stbox_stbox(box1: *const STBox, box2: *const STBox) -> *mut STBox;
}
extern "C" {
    pub fn adjacent_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn adjacent_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn same_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn same_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn left_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overleft_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn right_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overright_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn before_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overbefore_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn after_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overafter_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn left_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overleft_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn right_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overright_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn below_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overbelow_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn above_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overabove_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn front_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overfront_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn back_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overback_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn before_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overbefore_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn after_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overafter_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn tbox_eq(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_ne(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_cmp(box1: *const TBox, box2: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tbox_lt(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_le(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_ge(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_gt(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn stbox_eq(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_ne(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_cmp(box1: *const STBox, box2: *const STBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stbox_lt(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_le(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_ge(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_gt(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn tbool_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_from_wkb(wkb: *const u8, size: usize) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tint_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tfloat_out(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttext_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_out(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_as_text(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_as_ewkt(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_as_mfjson(
        temp: *const Temporal,
        with_bbox: bool,
        flags: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
        srs: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_as_wkb(temp: *const Temporal, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn temporal_as_hexwkb(
        temp: *const Temporal,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tbool_from_base_temp(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tboolinst_make(b: bool, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tboolseq_from_base_tstzset(b: bool, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tboolseq_from_base_tstzspan(b: bool, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn tboolseqset_from_base_tstzspanset(b: bool, ss: *const SpanSet) -> *mut TSequenceSet;
}
extern "C" {
    pub fn temporal_copy(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_from_base_temp(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloatinst_make(d: f64, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tfloatseq_from_base_tstzspan(
        d: f64,
        s: *const Span,
        interp: interpType,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tfloatseq_from_base_tstzset(d: f64, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tfloatseqset_from_base_tstzspanset(
        d: f64,
        ss: *const SpanSet,
        interp: interpType,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tint_from_base_temp(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tintinst_make(i: ::std::os::raw::c_int, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tintseq_from_base_tstzspan(i: ::std::os::raw::c_int, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn tintseq_from_base_tstzset(i: ::std::os::raw::c_int, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tintseqset_from_base_tstzspanset(
        i: ::std::os::raw::c_int,
        ss: *const SpanSet,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tpoint_from_base_temp(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpointinst_make(gs: *const GSERIALIZED, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tpointseq_from_base_tstzspan(
        gs: *const GSERIALIZED,
        s: *const Span,
        interp: interpType,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tpointseq_from_base_tstzset(gs: *const GSERIALIZED, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tpointseqset_from_base_tstzspanset(
        gs: *const GSERIALIZED,
        ss: *const SpanSet,
        interp: interpType,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tsequence_make(
        instants: *mut *const TInstant,
        count: ::std::os::raw::c_int,
        lower_inc: bool,
        upper_inc: bool,
        interp: interpType,
        normalize: bool,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tsequenceset_make(
        sequences: *mut *const TSequence,
        count: ::std::os::raw::c_int,
        normalize: bool,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tsequenceset_make_gaps(
        instants: *mut *const TInstant,
        count: ::std::os::raw::c_int,
        interp: interpType,
        maxt: *const Interval,
        maxdist: f64,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn ttext_from_base_temp(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttextinst_make(txt: *const text, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn ttextseq_from_base_tstzspan(txt: *const text, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn ttextseq_from_base_tstzset(txt: *const text, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn ttextseqset_from_base_tstzspanset(
        txt: *const text,
        ss: *const SpanSet,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn temporal_to_tstzspan(temp: *const Temporal) -> *mut Span;
}
extern "C" {
    pub fn tfloat_to_tint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tint_to_tfloat(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_to_span(temp: *const Temporal) -> *mut Span;
}
extern "C" {
    pub fn tbool_end_value(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tbool_start_value(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tbool_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn tbool_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn tbool_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut bool;
}
extern "C" {
    pub fn temporal_duration(temp: *const Temporal, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn temporal_end_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_end_sequence(temp: *const Temporal) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_end_timestamptz(temp: *const Temporal) -> TimestampTz;
}
extern "C" {
    pub fn temporal_hash(temp: *const Temporal) -> uint32;
}
extern "C" {
    pub fn temporal_instant_n(temp: *const Temporal, n: ::std::os::raw::c_int) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_instants(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TInstant;
}
extern "C" {
    pub fn temporal_interp(temp: *const Temporal) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_max_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_min_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_num_instants(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_num_sequences(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_num_timestamps(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_segments(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TSequence;
}
extern "C" {
    pub fn temporal_sequence_n(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_sequences(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TSequence;
}
extern "C" {
    pub fn temporal_lower_inc(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_upper_inc(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_start_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_start_sequence(temp: *const Temporal) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_start_timestamptz(temp: *const Temporal) -> TimestampTz;
}
extern "C" {
    pub fn temporal_stops(
        temp: *const Temporal,
        maxdist: f64,
        minduration: *const Interval,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn temporal_subtype(temp: *const Temporal) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_time(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn temporal_timestamptz_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn temporal_timestamps(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TimestampTz;
}
extern "C" {
    pub fn tfloat_end_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_max_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_min_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_start_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn tfloat_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn tfloat_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut f64;
}
extern "C" {
    pub fn tint_end_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_max_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_min_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_start_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tint_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tint_values(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn tnumber_integral(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tnumber_twavg(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tnumber_valuespans(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn tpoint_end_value(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_start_value(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_values(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut GSERIALIZED;
}
extern "C" {
    pub fn ttext_end_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_max_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_min_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_start_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut *mut text,
    ) -> bool;
}
extern "C" {
    pub fn ttext_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut *mut text,
    ) -> bool;
}
extern "C" {
    pub fn ttext_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int)
        -> *mut *mut text;
}
extern "C" {
    pub fn float_degrees(value: f64, normalize: bool) -> f64;
}
extern "C" {
    pub fn temporal_scale_time(temp: *const Temporal, duration: *const Interval) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_set_interp(temp: *const Temporal, interp: interpType) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_shift_scale_time(
        temp: *const Temporal,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_shift_time(temp: *const Temporal, shift: *const Interval) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_to_tinstant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_to_tsequence(
        temp: *const Temporal,
        interp_str: *const ::std::os::raw::c_char,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_to_tsequenceset(
        temp: *const Temporal,
        interp_str: *const ::std::os::raw::c_char,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tfloat_floor(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_ceil(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_degrees(temp: *const Temporal, normalize: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_radians(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_round(temp: *const Temporal, maxdd: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_scale_value(temp: *const Temporal, width: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_shift_scale_value(temp: *const Temporal, shift: f64, width: f64)
        -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_shift_value(temp: *const Temporal, shift: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloatarr_round(
        temp: *mut *const Temporal,
        count: ::std::os::raw::c_int,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tint_scale_value(temp: *const Temporal, width: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tint_shift_scale_value(
        temp: *const Temporal,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tint_shift_value(temp: *const Temporal, shift: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_round(temp: *const Temporal, maxdd: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform(temp: *const Temporal, srid: int32) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform_pipeline(
        temp: *const Temporal,
        pipelinestr: *const ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform_pj(
        temp: *const Temporal,
        srid: int32,
        pj: *const LWPROJ,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn lwproj_transform(srid_from: int32, srid_to: int32) -> *mut LWPROJ;
}
extern "C" {
    pub fn tpointarr_round(
        temp: *mut *const Temporal,
        count: ::std::os::raw::c_int,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn temporal_append_tinstant(
        temp: *mut Temporal,
        inst: *const TInstant,
        maxdist: f64,
        maxt: *const Interval,
        expand: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_append_tsequence(
        temp: *mut Temporal,
        seq: *const TSequence,
        expand: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzspan(
        temp: *const Temporal,
        s: *const Span,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzspanset(
        temp: *const Temporal,
        ss: *const SpanSet,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzset(
        temp: *const Temporal,
        s: *const Set,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_insert(
        temp1: *const Temporal,
        temp2: *const Temporal,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_merge(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_merge_array(
        temparr: *mut *const Temporal,
        count: ::std::os::raw::c_int,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_update(
        temp1: *const Temporal,
        temp2: *const Temporal,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_at_value(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_minus_value(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_max(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_min(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzspan(temp: *const Temporal, s: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzspanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_timestamptz(temp: *const Temporal, t: TimestampTz) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzset(temp: *const Temporal, s: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_values(temp: *const Temporal, set: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_max(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_min(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzspan(temp: *const Temporal, s: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzspanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_timestamptz(temp: *const Temporal, t: TimestampTz) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzset(temp: *const Temporal, s: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_values(temp: *const Temporal, set: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_at_value(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_minus_value(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tint_at_value(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tint_minus_value(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_span(temp: *const Temporal, span: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_spanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_tbox(temp: *const Temporal, box_: *const TBox) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_span(temp: *const Temporal, span: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_spanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_tbox(temp: *const Temporal, box_: *const TBox) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_geom_time(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        zspan: *const Span,
        period: *const Span,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_stbox(
        temp: *const Temporal,
        box_: *const STBox,
        border_inc: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_value(temp: *const Temporal, gs: *mut GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_geom_time(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        zspan: *const Span,
        period: *const Span,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_stbox(
        temp: *const Temporal,
        box_: *const STBox,
        border_inc: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_value(temp: *const Temporal, gs: *mut GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_at_value(temp: *const Temporal, txt: *mut text) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_minus_value(temp: *const Temporal, txt: *mut text) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_cmp(temp1: *const Temporal, temp2: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_eq(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_ge(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_gt(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_le(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_lt(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_ne(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn always_eq_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn teq_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_point_tpoint(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn teq_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn teq_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tge_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tge_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tge_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tle_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tle_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tle_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tne_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_point_tpoint(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tne_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tne_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_spans(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn temporal_split_each_n_spans(
        temp: *const Temporal,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn temporal_split_n_spans(
        temp: *const Temporal,
        span_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn temporal_time_spans(
        temp: *const Temporal,
        duration: *const Interval,
        origin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn tnumber_tboxes(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn tnumber_split_each_n_tboxes(
        temp: *const Temporal,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tnumber_split_n_tboxes(
        temp: *const Temporal,
        box_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tnumber_value_spans(
        temp: *const Temporal,
        size: Datum,
        origin: Datum,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn tpoint_stboxes(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_space_boxes(
        temp: *const Temporal,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        sorigin: *const GSERIALIZED,
        bitmatrix: bool,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_space_time_boxes(
        temp: *const Temporal,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *const Interval,
        sorigin: *const GSERIALIZED,
        torigin: TimestampTz,
        bitmatrix: bool,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_split_each_n_stboxes(
        temp: *const Temporal,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_split_n_stboxes(
        temp: *const Temporal,
        box_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn geo_split_each_n_gboxes(
        gs: *const GSERIALIZED,
        elem_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut GBOX;
}
extern "C" {
    pub fn geo_split_n_gboxes(
        gs: *const GSERIALIZED,
        box_count: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut GBOX;
}
extern "C" {
    pub fn adjacent_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn adjacent_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn contained_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn contains_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overlaps_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn same_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn same_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn same_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn same_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn above_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn above_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn above_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn after_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn after_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn back_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn back_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn back_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn before_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn before_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn below_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn below_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn below_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn front_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn front_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn front_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn left_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn left_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overabove_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overabove_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overabove_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overafter_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overafter_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overback_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overback_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overback_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overbefore_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overbefore_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbelow_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbelow_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overbelow_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overfront_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overfront_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overfront_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overleft_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overright_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overright_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn right_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn right_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn tand_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tand_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tand_tbool_tbool(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_when_true(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn tnot_tbool(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tor_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tor_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tor_tbool_tbool(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn add_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn add_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn add_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn add_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn add_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn div_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn div_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn div_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn div_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn div_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn mult_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn mult_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn sub_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn sub_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_derivative(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_abs(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_angular_difference(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_delta_value(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn textcat_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn textcat_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn textcat_ttext_ttext(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_upper(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_lower(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_initcap(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tnumber_tnumber(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn nad_stbox_geo(box_: *const STBox, gs: *const GSERIALIZED) -> f64;
}
extern "C" {
    pub fn nad_stbox_stbox(box1: *const STBox, box2: *const STBox) -> f64;
}
extern "C" {
    pub fn nad_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tint_tbox(temp: *const Temporal, box_: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tint_tint(temp1: *const Temporal, temp2: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tboxint_tboxint(box1: *const TBox, box2: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tfloat_float(temp: *const Temporal, d: f64) -> f64;
}
extern "C" {
    pub fn nad_tfloat_tfloat(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn nad_tfloat_tbox(temp: *const Temporal, box_: *const TBox) -> f64;
}
extern "C" {
    pub fn nad_tboxfloat_tboxfloat(box1: *const TBox, box2: *const TBox) -> f64;
}
extern "C" {
    pub fn nad_tpoint_geo(temp: *const Temporal, gs: *const GSERIALIZED) -> f64;
}
extern "C" {
    pub fn nad_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> f64;
}
extern "C" {
    pub fn nad_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn nai_tpoint_geo(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut TInstant;
}
extern "C" {
    pub fn nai_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn shortestline_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn shortestline_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn bearing_point_point(
        gs1: *const GSERIALIZED,
        gs2: *const GSERIALIZED,
        result: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn bearing_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        invert: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn bearing_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn geo_gboxes(gs: *const GSERIALIZED, count: *mut ::std::os::raw::c_int) -> *mut GBOX;
}
extern "C" {
    pub fn tpoint_angular_difference(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_azimuth(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_convex_hull(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_cumulative_length(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_direction(temp: *const Temporal, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tpoint_get_x(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_get_y(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_get_z(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_is_simple(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tpoint_length(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tpoint_speed(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_srid(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpoint_trajectory(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_twcentroid(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_expand_space(gs: *const GSERIALIZED, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn geomeas_to_tpoint(gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_to_tgeompoint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_to_tgeogpoint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_AsMVTGeom(
        temp: *const Temporal,
        bounds: *const STBox,
        extent: i32,
        buffer: i32,
        clip_geom: bool,
        gsarr: *mut *mut GSERIALIZED,
        timesarr: *mut *mut int64,
        count: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_expand_space(temp: *const Temporal, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_make_simple(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tpoint_set_srid(temp: *const Temporal, srid: int32) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_tfloat_to_geomeas(
        tpoint: *const Temporal,
        measure: *const Temporal,
        segmentize: bool,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn acontains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn econtains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn etouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcontains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn ttouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_tand_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tbool_tor_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn temporal_extent_transfn(s: *mut Span, temp: *const Temporal) -> *mut Span;
}
extern "C" {
    pub fn temporal_tagg_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tcount_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tsum_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wmax_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wmin_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wsum_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn timestamptz_tcount_transfn(state: *mut SkipList, t: TimestampTz) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tsum_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wmax_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wmin_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wsum_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tnumber_extent_transfn(box_: *mut TBox, temp: *const Temporal) -> *mut TBox;
}
extern "C" {
    pub fn tnumber_tavg_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_tavg_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tnumber_wavg_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tpoint_extent_transfn(box_: *mut STBox, temp: *const Temporal) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_tcentroid_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_tcentroid_transfn(state: *mut SkipList, temp: *mut Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tstzset_tcount_transfn(state: *mut SkipList, s: *const Set) -> *mut SkipList;
}
extern "C" {
    pub fn tstzspan_tcount_transfn(state: *mut SkipList, s: *const Span) -> *mut SkipList;
}
extern "C" {
    pub fn tstzspanset_tcount_transfn(state: *mut SkipList, ss: *const SpanSet) -> *mut SkipList;
}
extern "C" {
    pub fn ttext_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn ttext_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn temporal_simplify_dp(
        temp: *const Temporal,
        eps_dist: f64,
        synchronized: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_max_dist(
        temp: *const Temporal,
        eps_dist: f64,
        synchronized: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_min_dist(temp: *const Temporal, dist: f64) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_min_tdelta(
        temp: *const Temporal,
        mint: *const Interval,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tprecision(
        temp: *const Temporal,
        duration: *const Interval,
        origin: TimestampTz,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tsample(
        temp: *const Temporal,
        duration: *const Interval,
        origin: TimestampTz,
        interp: interpType,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_dyntimewarp_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn temporal_dyntimewarp_path(
        temp1: *const Temporal,
        temp2: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Match;
}
extern "C" {
    pub fn temporal_frechet_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn temporal_frechet_path(
        temp1: *const Temporal,
        temp2: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Match;
}
extern "C" {
    pub fn temporal_hausdorff_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn float_get_bin(value: f64, vsize: f64, vorigin: f64) -> f64;
}
extern "C" {
    pub fn floatspan_value_spans(
        bounds: *const Span,
        vsize: f64,
        vorigin: f64,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn int_get_bin(
        value: ::std::os::raw::c_int,
        vsize: ::std::os::raw::c_int,
        vorigin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_value_spans(
        bounds: *const Span,
        vsize: ::std::os::raw::c_int,
        vorigin: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn stbox_get_space_tile(
        point: *const GSERIALIZED,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        sorigin: *const GSERIALIZED,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_get_space_time_tile(
        point: *const GSERIALIZED,
        t: TimestampTz,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *const Interval,
        sorigin: *const GSERIALIZED,
        torigin: TimestampTz,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_get_time_tile(
        t: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_space_tiles(
        bounds: *const STBox,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        sorigin: *const GSERIALIZED,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_space_time_tiles(
        bounds: *const STBox,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *const Interval,
        sorigin: *const GSERIALIZED,
        torigin: TimestampTz,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_time_tiles(
        bounds: *const STBox,
        duration: *const Interval,
        torigin: TimestampTz,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn temporal_time_split(
        temp: *const Temporal,
        duration: *const Interval,
        torigin: TimestampTz,
        time_bins: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloat_value_split(
        temp: *const Temporal,
        vsize: f64,
        vorigin: f64,
        value_bins: *mut *mut f64,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloat_value_time_split(
        temp: *const Temporal,
        vsize: f64,
        duration: *const Interval,
        vorigin: f64,
        torigin: TimestampTz,
        value_bins: *mut *mut f64,
        time_bins: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloatbox_get_time_tile(
        t: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_get_value_tile(value: f64, vsize: f64, vorigin: f64) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_get_value_time_tile(
        value: f64,
        t: TimestampTz,
        vsize: f64,
        duration: *const Interval,
        vorigin: f64,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_time_tiles(
        box_: *const TBox,
        duration: *const Interval,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_value_tiles(
        box_: *const TBox,
        vsize: f64,
        vorigin: f64,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_value_time_tiles(
        box_: *const TBox,
        vsize: f64,
        duration: *const Interval,
        vorigin: f64,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn timestamptz_get_bin(
        timestamp: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> TimestampTz;
}
extern "C" {
    pub fn tint_value_split(
        temp: *const Temporal,
        vsize: ::std::os::raw::c_int,
        vorigin: ::std::os::raw::c_int,
        value_bins: *mut *mut ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tint_value_time_split(
        temp: *const Temporal,
        size: ::std::os::raw::c_int,
        duration: *const Interval,
        vorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
        value_bins: *mut *mut ::std::os::raw::c_int,
        time_bins: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tintbox_get_time_tile(
        t: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_get_value_tile(
        value: ::std::os::raw::c_int,
        vsize: ::std::os::raw::c_int,
        vorigin: ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_get_value_time_tile(
        value: ::std::os::raw::c_int,
        t: TimestampTz,
        vsize: ::std::os::raw::c_int,
        duration: *const Interval,
        vorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_time_tiles(
        box_: *const TBox,
        duration: *const Interval,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_value_tiles(
        box_: *const TBox,
        xsize: ::std::os::raw::c_int,
        xorigin: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_value_time_tiles(
        box_: *const TBox,
        xsize: ::std::os::raw::c_int,
        duration: *const Interval,
        xorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tpoint_space_split(
        temp: *const Temporal,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        sorigin: *const GSERIALIZED,
        bitmatrix: bool,
        border_inc: bool,
        space_bins: *mut *mut *mut GSERIALIZED,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tpoint_space_time_split(
        temp: *const Temporal,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *const Interval,
        sorigin: *const GSERIALIZED,
        torigin: TimestampTz,
        bitmatrix: bool,
        border_inc: bool,
        space_bins: *mut *mut *mut GSERIALIZED,
        time_bins: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tpoint_time_split(
        temp: *const Temporal,
        duration: *const Interval,
        torigin: TimestampTz,
        border_inc: bool,
        time_bins: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tstzspan_time_spans(
        bounds: *const Span,
        duration: *const Interval,
        origin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
pub const meosType_T_UNKNOWN: meosType = 0;
pub const meosType_T_BOOL: meosType = 1;
pub const meosType_T_DATE: meosType = 2;
pub const meosType_T_DATEMULTIRANGE: meosType = 3;
pub const meosType_T_DATERANGE: meosType = 4;
pub const meosType_T_DATESET: meosType = 5;
pub const meosType_T_DATESPAN: meosType = 6;
pub const meosType_T_DATESPANSET: meosType = 7;
pub const meosType_T_DOUBLE2: meosType = 8;
pub const meosType_T_DOUBLE3: meosType = 9;
pub const meosType_T_DOUBLE4: meosType = 10;
pub const meosType_T_FLOAT8: meosType = 11;
pub const meosType_T_FLOATSET: meosType = 12;
pub const meosType_T_FLOATSPAN: meosType = 13;
pub const meosType_T_FLOATSPANSET: meosType = 14;
pub const meosType_T_INT4: meosType = 15;
pub const meosType_T_INT4MULTIRANGE: meosType = 16;
pub const meosType_T_INT4RANGE: meosType = 17;
pub const meosType_T_INTSET: meosType = 18;
pub const meosType_T_INTSPAN: meosType = 19;
pub const meosType_T_INTSPANSET: meosType = 20;
pub const meosType_T_INT8: meosType = 21;
pub const meosType_T_INT8MULTIRANGE: meosType = 52;
pub const meosType_T_INT8RANGE: meosType = 53;
pub const meosType_T_BIGINTSET: meosType = 22;
pub const meosType_T_BIGINTSPAN: meosType = 23;
pub const meosType_T_BIGINTSPANSET: meosType = 24;
pub const meosType_T_STBOX: meosType = 25;
pub const meosType_T_TBOOL: meosType = 26;
pub const meosType_T_TBOX: meosType = 27;
pub const meosType_T_TDOUBLE2: meosType = 28;
pub const meosType_T_TDOUBLE3: meosType = 29;
pub const meosType_T_TDOUBLE4: meosType = 30;
pub const meosType_T_TEXT: meosType = 31;
pub const meosType_T_TEXTSET: meosType = 32;
pub const meosType_T_TFLOAT: meosType = 33;
pub const meosType_T_TIMESTAMPTZ: meosType = 34;
pub const meosType_T_TINT: meosType = 35;
pub const meosType_T_TSTZMULTIRANGE: meosType = 36;
pub const meosType_T_TSTZRANGE: meosType = 37;
pub const meosType_T_TSTZSET: meosType = 38;
pub const meosType_T_TSTZSPAN: meosType = 39;
pub const meosType_T_TSTZSPANSET: meosType = 40;
pub const meosType_T_TTEXT: meosType = 41;
pub const meosType_T_GEOMETRY: meosType = 42;
pub const meosType_T_GEOMSET: meosType = 43;
pub const meosType_T_GEOGRAPHY: meosType = 44;
pub const meosType_T_GEOGSET: meosType = 45;
pub const meosType_T_TGEOMPOINT: meosType = 46;
pub const meosType_T_TGEOGPOINT: meosType = 47;
pub const meosType_T_NPOINT: meosType = 48;
pub const meosType_T_NPOINTSET: meosType = 49;
pub const meosType_T_NSEGMENT: meosType = 50;
pub const meosType_T_TNPOINT: meosType = 51;
pub const meosType_T_POSE: meosType = 54;
pub const meosType_T_TPOSE: meosType = 55;
pub type meosType = ::std::os::raw::c_uint;
pub const meosOper_UNKNOWN_OP: meosOper = 0;
pub const meosOper_EQ_OP: meosOper = 1;
pub const meosOper_NE_OP: meosOper = 2;
pub const meosOper_LT_OP: meosOper = 3;
pub const meosOper_LE_OP: meosOper = 4;
pub const meosOper_GT_OP: meosOper = 5;
pub const meosOper_GE_OP: meosOper = 6;
pub const meosOper_ADJACENT_OP: meosOper = 7;
pub const meosOper_UNION_OP: meosOper = 8;
pub const meosOper_MINUS_OP: meosOper = 9;
pub const meosOper_INTERSECT_OP: meosOper = 10;
pub const meosOper_OVERLAPS_OP: meosOper = 11;
pub const meosOper_CONTAINS_OP: meosOper = 12;
pub const meosOper_CONTAINED_OP: meosOper = 13;
pub const meosOper_SAME_OP: meosOper = 14;
pub const meosOper_LEFT_OP: meosOper = 15;
pub const meosOper_OVERLEFT_OP: meosOper = 16;
pub const meosOper_RIGHT_OP: meosOper = 17;
pub const meosOper_OVERRIGHT_OP: meosOper = 18;
pub const meosOper_BELOW_OP: meosOper = 19;
pub const meosOper_OVERBELOW_OP: meosOper = 20;
pub const meosOper_ABOVE_OP: meosOper = 21;
pub const meosOper_OVERABOVE_OP: meosOper = 22;
pub const meosOper_FRONT_OP: meosOper = 23;
pub const meosOper_OVERFRONT_OP: meosOper = 24;
pub const meosOper_BACK_OP: meosOper = 25;
pub const meosOper_OVERBACK_OP: meosOper = 26;
pub const meosOper_BEFORE_OP: meosOper = 27;
pub const meosOper_OVERBEFORE_OP: meosOper = 28;
pub const meosOper_AFTER_OP: meosOper = 29;
pub const meosOper_OVERAFTER_OP: meosOper = 30;
pub const meosOper_EVEREQ_OP: meosOper = 31;
pub const meosOper_EVERNE_OP: meosOper = 32;
pub const meosOper_EVERLT_OP: meosOper = 33;
pub const meosOper_EVERLE_OP: meosOper = 34;
pub const meosOper_EVERGT_OP: meosOper = 35;
pub const meosOper_EVERGE_OP: meosOper = 36;
pub const meosOper_ALWAYSEQ_OP: meosOper = 37;
pub const meosOper_ALWAYSNE_OP: meosOper = 38;
pub const meosOper_ALWAYSLT_OP: meosOper = 39;
pub const meosOper_ALWAYSLE_OP: meosOper = 40;
pub const meosOper_ALWAYSGT_OP: meosOper = 41;
pub const meosOper_ALWAYSGE_OP: meosOper = 42;
pub type meosOper = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct temptype_catalog_struct {
    pub temptype: meosType,
    pub basetype: meosType,
}
#[test]
fn bindgen_test_layout_temptype_catalog_struct() {
    const UNINIT: ::std::mem::MaybeUninit<temptype_catalog_struct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<temptype_catalog_struct>(),
        8usize,
        concat!("Size of: ", stringify!(temptype_catalog_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<temptype_catalog_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(temptype_catalog_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(temptype_catalog_struct),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(temptype_catalog_struct),
            "::",
            stringify!(basetype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct settype_catalog_struct {
    pub settype: meosType,
    pub basetype: meosType,
}
#[test]
fn bindgen_test_layout_settype_catalog_struct() {
    const UNINIT: ::std::mem::MaybeUninit<settype_catalog_struct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<settype_catalog_struct>(),
        8usize,
        concat!("Size of: ", stringify!(settype_catalog_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<settype_catalog_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(settype_catalog_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(settype_catalog_struct),
            "::",
            stringify!(settype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(settype_catalog_struct),
            "::",
            stringify!(basetype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spantype_catalog_struct {
    pub spantype: meosType,
    pub basetype: meosType,
}
#[test]
fn bindgen_test_layout_spantype_catalog_struct() {
    const UNINIT: ::std::mem::MaybeUninit<spantype_catalog_struct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spantype_catalog_struct>(),
        8usize,
        concat!("Size of: ", stringify!(spantype_catalog_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<spantype_catalog_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(spantype_catalog_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spantype_catalog_struct),
            "::",
            stringify!(spantype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spantype_catalog_struct),
            "::",
            stringify!(basetype)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spansettype_catalog_struct {
    pub spansettype: meosType,
    pub spantype: meosType,
}
#[test]
fn bindgen_test_layout_spansettype_catalog_struct() {
    const UNINIT: ::std::mem::MaybeUninit<spansettype_catalog_struct> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<spansettype_catalog_struct>(),
        8usize,
        concat!("Size of: ", stringify!(spansettype_catalog_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<spansettype_catalog_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(spansettype_catalog_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spansettype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spansettype_catalog_struct),
            "::",
            stringify!(spansettype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(spansettype_catalog_struct),
            "::",
            stringify!(spantype)
        )
    );
}
extern "C" {
    pub fn temptype_subtype(subtype: tempSubtype) -> bool;
}
extern "C" {
    pub fn temptype_subtype_all(subtype: tempSubtype) -> bool;
}
extern "C" {
    pub fn tempsubtype_name(subtype: tempSubtype) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempsubtype_from_string(
        str_: *const ::std::os::raw::c_char,
        subtype: *mut int16,
    ) -> bool;
}
extern "C" {
    pub fn meosoper_name(oper: meosOper) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn meosoper_from_string(name: *const ::std::os::raw::c_char) -> meosOper;
}
extern "C" {
    pub fn interptype_name(interp: interpType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn interptype_from_string(interp_str: *const ::std::os::raw::c_char) -> interpType;
}
extern "C" {
    pub fn meostype_name(type_: meosType) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn temptype_basetype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn settype_basetype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn spantype_basetype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn spantype_spansettype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn spansettype_spantype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn basetype_spantype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn basetype_settype(type_: meosType) -> meosType;
}
extern "C" {
    pub fn meos_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn alpha_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tnumber_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn alphanum_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn geo_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn spatial_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn time_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn set_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn set_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn numset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_numset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn timeset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_timeset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn set_spantype(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_set_spantype(type_: meosType) -> bool;
}
extern "C" {
    pub fn alphanumset_type(settype: meosType) -> bool;
}
extern "C" {
    pub fn geoset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_geoset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn spatialset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_spatialset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn span_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn span_canon_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn span_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn span_bbox_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn numspan_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn numspan_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_numspan_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn timespan_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn timespan_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_timespan_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn spanset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn numspanset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn timespanset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_timespanset_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn temporal_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn temporal_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn temptype_continuous(type_: meosType) -> bool;
}
extern "C" {
    pub fn basetype_byvalue(type_: meosType) -> bool;
}
extern "C" {
    pub fn basetype_varlength(type_: meosType) -> bool;
}
extern "C" {
    pub fn basetype_length(type_: meosType) -> int16;
}
extern "C" {
    pub fn talphanum_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn talpha_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn tnumber_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_tnumber_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_tnumber_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tnumber_settype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tnumber_spantype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tnumber_spansettype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tspatial_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_tspatial_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn tspatial_basetype(type_: meosType) -> bool;
}
extern "C" {
    pub fn tgeo_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_tgeo_type(type_: meosType) -> bool;
}
extern "C" {
    pub fn ensure_tnumber_tgeo_type(type_: meosType) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
