/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub const _LIBLWGEOM_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const POSTGIS_CONFIG_H: u32 = 1;
pub const POSTGIS_DEBUG_LEVEL: u32 = 0;
pub const PARANOIA_LEVEL: u32 = 0;
pub const ENABLE_NLS: u32 = 1;
pub const HAVE_FSEEKO: u32 = 1;
pub const HAVE_GETTEXT: u32 = 1;
pub const HAVE_ICONV: u32 = 1;
pub const HAVE_IEEEFP_H: u32 = 0;
pub const HAVE_LIBGEOS_C: u32 = 1;
pub const HAVE_LIBPROTOBUF: u32 = 1;
pub const LIBPROTOBUF_VERSION: u32 = 1003003;
pub const HAVE_LIBJSON: u32 = 1;
pub const HAVE_LIBPQ: u32 = 1;
pub const HAVE_LIBPROJ: u32 = 1;
pub const HAVE_LIBXML2: u32 = 1;
pub const HAVE_LIBXML_PARSER_H: u32 = 1;
pub const HAVE_LIBXML_TREE_H: u32 = 1;
pub const HAVE_LIBXML_XPATHINTERNALS_H: u32 = 1;
pub const HAVE_LIBXML_XPATH_H: u32 = 1;
pub const HAVE_UNISTD_H: u32 = 1;
pub const HAVE_WAGYU: u32 = 1;
pub const LT_OBJDIR: &[u8; 7] = b".libs/\0";
pub const POSTGIS_BUILD_DATE: &[u8; 20] = b"2021-06-26 08:21:14\0";
pub const POSTGIS_GDAL_VERSION: u32 = 30;
pub const POSTGIS_GEOS_VERSION: u32 = 30800;
pub const POSTGIS_LIBXML2_VERSION: &[u8; 7] = b"2.9.10\0";
pub const POSTGIS_LIB_VERSION: &[u8; 6] = b"3.4.2\0";
pub const POSTGIS_MAJOR_VERSION: &[u8; 2] = b"3\0";
pub const POSTGIS_MINOR_VERSION: &[u8; 2] = b"4\0";
pub const POSTGIS_MICRO_VERSION: &[u8; 2] = b"2\0";
pub const POSTGIS_PGSQL_VERSION: u32 = 140;
pub const POSTGIS_PROJ_VERSION: u32 = 63;
pub const POSTGIS_RASTER_WARN_ON_TRUNCATION: u32 = 0;
pub const POSTGIS_SCRIPTS_VERSION: &[u8; 6] = b"3.4.2\0";
pub const POSTGIS_VERSION: &[u8; 38] = b"3.1 USE_GEOS=1 USE_PROJ=1 USE_STATS=1\0";
pub const STDC_HEADERS: u32 = 1;
pub const YYTEXT_POINTER: u32 = 1;
pub const PROJ_VERSION_MAJOR: u32 = 6;
pub const PROJ_VERSION_MINOR: u32 = 3;
pub const PROJ_VERSION_PATCH: u32 = 1;
pub const PJ_DEFAULT_CTX: u32 = 0;
pub const LIBLWGEOM_VERSION: &[u8; 1] = b"\0";
pub const LIBLWGEOM_VERSION_MAJOR: &[u8; 1] = b"\0";
pub const LIBLWGEOM_VERSION_MINOR: &[u8; 1] = b"\0";
pub const LIBLWGEOM_GEOS_VERSION: &[u8; 6] = b"30800\0";
pub const LW_TRUE: u32 = 1;
pub const LW_FALSE: u32 = 0;
pub const LW_UNKNOWN: u32 = 2;
pub const LW_FAILURE: u32 = 0;
pub const LW_SUCCESS: u32 = 1;
pub const POINTTYPE: u32 = 1;
pub const LINETYPE: u32 = 2;
pub const POLYGONTYPE: u32 = 3;
pub const MULTIPOINTTYPE: u32 = 4;
pub const MULTILINETYPE: u32 = 5;
pub const MULTIPOLYGONTYPE: u32 = 6;
pub const COLLECTIONTYPE: u32 = 7;
pub const CIRCSTRINGTYPE: u32 = 8;
pub const COMPOUNDTYPE: u32 = 9;
pub const CURVEPOLYTYPE: u32 = 10;
pub const MULTICURVETYPE: u32 = 11;
pub const MULTISURFACETYPE: u32 = 12;
pub const POLYHEDRALSURFACETYPE: u32 = 13;
pub const TRIANGLETYPE: u32 = 14;
pub const TINTYPE: u32 = 15;
pub const NUMTYPES: u32 = 16;
pub const WKBZOFFSET: u32 = 2147483648;
pub const WKBMOFFSET: u32 = 1073741824;
pub const WKBSRIDFLAG: u32 = 536870912;
pub const WKBBBOXFLAG: u32 = 268435456;
pub const WGS84_MAJOR_AXIS: f64 = 6378137.0;
pub const WGS84_INVERSE_FLATTENING: f64 = 298.257223563;
pub const WGS84_MINOR_AXIS: f64 = 6356752.314245179;
pub const WGS84_RADIUS: f64 = 6371008.771415059;
pub const WGS84_SRID: u32 = 4326;
pub const LWFLAG_Z: u32 = 1;
pub const LWFLAG_M: u32 = 2;
pub const LWFLAG_BBOX: u32 = 4;
pub const LWFLAG_GEODETIC: u32 = 8;
pub const LWFLAG_READONLY: u32 = 16;
pub const LWFLAG_SOLID: u32 = 32;
pub const SRID_MAXIMUM: u32 = 999999;
pub const SRID_USER_MAXIMUM: u32 = 998999;
pub const SRID_UNKNOWN: u32 = 0;
pub const SRID_INVALID: u32 = 1000001;
pub const SRID_DEFAULT: u32 = 4326;
pub const IS_BIG_ENDIAN: u32 = 0;
pub const LW_GML_IS_DIMS: u32 = 1;
pub const LW_GML_IS_DEGREE: u32 = 2;
pub const LW_GML_SHORTLINE: u32 = 4;
pub const LW_GML_EXTENT: u32 = 16;
pub const LW_X3D_FLIP_XY: u32 = 1;
pub const LW_X3D_USE_GEOCOORDS: u32 = 2;
pub const LW_PARSER_CHECK_MINPOINTS: u32 = 1;
pub const LW_PARSER_CHECK_ODD: u32 = 2;
pub const LW_PARSER_CHECK_CLOSURE: u32 = 4;
pub const LW_PARSER_CHECK_ZCLOSURE: u32 = 8;
pub const LW_PARSER_CHECK_NONE: u32 = 0;
pub const LW_PARSER_CHECK_ALL: u32 = 7;
pub const PARSER_ERROR_MOREPOINTS: u32 = 1;
pub const PARSER_ERROR_ODDPOINTS: u32 = 2;
pub const PARSER_ERROR_UNCLOSED: u32 = 3;
pub const PARSER_ERROR_MIXDIMS: u32 = 4;
pub const PARSER_ERROR_INVALIDGEOM: u32 = 5;
pub const PARSER_ERROR_INVALIDWKBTYPE: u32 = 6;
pub const PARSER_ERROR_INCONTINUOUS: u32 = 7;
pub const PARSER_ERROR_TRIANGLEPOINTS: u32 = 8;
pub const PARSER_ERROR_LESSPOINTS: u32 = 9;
pub const PARSER_ERROR_OTHER: u32 = 10;
pub const UNPARSER_ERROR_MOREPOINTS: u32 = 1;
pub const UNPARSER_ERROR_ODDPOINTS: u32 = 2;
pub const UNPARSER_ERROR_UNCLOSED: u32 = 3;
pub const WKB_ISO: u32 = 1;
pub const WKB_SFSQL: u32 = 2;
pub const WKB_EXTENDED: u32 = 4;
pub const WKB_NDR: u32 = 8;
pub const WKB_XDR: u32 = 16;
pub const WKB_HEX: u32 = 32;
pub const WKB_NO_NPOINTS: u32 = 64;
pub const WKB_NO_SRID: u32 = 128;
pub const WKT_ISO: u32 = 1;
pub const WKT_SFSQL: u32 = 2;
pub const WKT_EXTENDED: u32 = 4;
pub const TWKB_BBOX: u32 = 1;
pub const TWKB_SIZE: u32 = 2;
pub const TWKB_ID: u32 = 4;
pub const TWKB_NO_TYPE: u32 = 16;
pub const TWKB_NO_ID: u32 = 32;
pub const TWKB_DEFAULT_PRECISION: u32 = 0;
pub const ALIGNOF_DOUBLE: u32 = 8;
pub const ALIGNOF_INT: u32 = 4;
pub const ALIGNOF_LONG: u32 = 8;
pub const ALIGNOF_PG_INT128_TYPE: u32 = 16;
pub const ALIGNOF_SHORT: u32 = 2;
pub const BLCKSZ: u32 = 8192;
pub const CONFIGURE_ARGS: &[u8; 65] =
    b" '--prefix=/usr/local/pgsql/14/' '--with-libxml' 'CFLAGS=-g -O0'\0";
pub const DEF_PGPORT: u32 = 5432;
pub const DEF_PGPORT_STR: &[u8; 5] = b"5432\0";
pub const ENABLE_THREAD_SAFETY: u32 = 1;
pub const HAVE_APPEND_HISTORY: u32 = 1;
pub const HAVE_ATOMICS: u32 = 1;
pub const HAVE_BACKTRACE_SYMBOLS: u32 = 1;
pub const HAVE_CLOCK_GETTIME: u32 = 1;
pub const HAVE_COMPUTED_GOTO: u32 = 1;
pub const HAVE_DECL_FDATASYNC: u32 = 1;
pub const HAVE_DECL_F_FULLFSYNC: u32 = 0;
pub const HAVE_DECL_POSIX_FADVISE: u32 = 1;
pub const HAVE_DECL_PREADV: u32 = 1;
pub const HAVE_DECL_PWRITEV: u32 = 1;
pub const HAVE_DECL_RTLD_GLOBAL: u32 = 1;
pub const HAVE_DECL_RTLD_NOW: u32 = 1;
pub const HAVE_DECL_STRLCAT: u32 = 0;
pub const HAVE_DECL_STRLCPY: u32 = 0;
pub const HAVE_DECL_STRNLEN: u32 = 1;
pub const HAVE_DECL_STRTOLL: u32 = 1;
pub const HAVE_DECL_STRTOULL: u32 = 1;
pub const HAVE_DLOPEN: u32 = 1;
pub const HAVE_EXECINFO_H: u32 = 1;
pub const HAVE_EXPLICIT_BZERO: u32 = 1;
pub const HAVE_FDATASYNC: u32 = 1;
pub const HAVE_FUNCNAME__FUNC: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__ATOMIC_INT64_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_CHAR_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_CAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT32_TAS: u32 = 1;
pub const HAVE_GCC__SYNC_INT64_CAS: u32 = 1;
pub const HAVE_GETADDRINFO: u32 = 1;
pub const HAVE_GETHOSTBYNAME_R: u32 = 1;
pub const HAVE_GETIFADDRS: u32 = 1;
pub const HAVE_GETOPT: u32 = 1;
pub const HAVE_GETOPT_H: u32 = 1;
pub const HAVE_GETOPT_LONG: u32 = 1;
pub const HAVE_GETPWUID_R: u32 = 1;
pub const HAVE_GETRLIMIT: u32 = 1;
pub const HAVE_GETRUSAGE: u32 = 1;
pub const HAVE_HISTORY_TRUNCATE_FILE: u32 = 1;
pub const HAVE_IFADDRS_H: u32 = 1;
pub const HAVE_INET_ATON: u32 = 1;
pub const HAVE_INTTYPES_H: u32 = 1;
pub const HAVE_INT_OPTERR: u32 = 1;
pub const HAVE_INT_TIMEZONE: u32 = 1;
pub const HAVE_IPV6: u32 = 1;
pub const HAVE_LANGINFO_H: u32 = 1;
pub const HAVE_LIBM: u32 = 1;
pub const HAVE_LIBREADLINE: u32 = 1;
pub const HAVE_LIBZ: u32 = 1;
pub const HAVE_LINK: u32 = 1;
pub const HAVE_LOCALE_T: u32 = 1;
pub const HAVE_LONG_INT_64: u32 = 1;
pub const HAVE_MEMORY_H: u32 = 1;
pub const HAVE_MKDTEMP: u32 = 1;
pub const HAVE_NETINET_TCP_H: u32 = 1;
pub const HAVE_NET_IF_H: u32 = 1;
pub const HAVE_POLL: u32 = 1;
pub const HAVE_POLL_H: u32 = 1;
pub const HAVE_POSIX_FADVISE: u32 = 1;
pub const HAVE_POSIX_FALLOCATE: u32 = 1;
pub const HAVE_PPOLL: u32 = 1;
pub const HAVE_PREAD: u32 = 1;
pub const HAVE_PTHREAD: u32 = 1;
pub const HAVE_PTHREAD_BARRIER_WAIT: u32 = 1;
pub const HAVE_PTHREAD_PRIO_INHERIT: u32 = 1;
pub const HAVE_PWRITE: u32 = 1;
pub const HAVE_RANDOM: u32 = 1;
pub const HAVE_READLINE_HISTORY_H: u32 = 1;
pub const HAVE_READLINE_READLINE_H: u32 = 1;
pub const HAVE_READLINK: u32 = 1;
pub const HAVE_READV: u32 = 1;
pub const HAVE_RL_COMPLETION_APPEND_CHARACTER: u32 = 1;
pub const HAVE_RL_COMPLETION_MATCHES: u32 = 1;
pub const HAVE_RL_COMPLETION_SUPPRESS_QUOTE: u32 = 1;
pub const HAVE_RL_FILENAME_COMPLETION_FUNCTION: u32 = 1;
pub const HAVE_RL_FILENAME_QUOTE_CHARACTERS: u32 = 1;
pub const HAVE_RL_FILENAME_QUOTING_FUNCTION: u32 = 1;
pub const HAVE_RL_RESET_SCREEN_SIZE: u32 = 1;
pub const HAVE_SETENV: u32 = 1;
pub const HAVE_SETSID: u32 = 1;
pub const HAVE_SHM_OPEN: u32 = 1;
pub const HAVE_SPINLOCKS: u32 = 1;
pub const HAVE_SRANDOM: u32 = 1;
pub const HAVE_STDBOOL_H: u32 = 1;
pub const HAVE_STDINT_H: u32 = 1;
pub const HAVE_STDLIB_H: u32 = 1;
pub const HAVE_STRCHRNUL: u32 = 1;
pub const HAVE_STRERROR_R: u32 = 1;
pub const HAVE_STRINGS_H: u32 = 1;
pub const HAVE_STRING_H: u32 = 1;
pub const HAVE_STRNLEN: u32 = 1;
pub const HAVE_STRSIGNAL: u32 = 1;
pub const HAVE_STRTOF: u32 = 1;
pub const HAVE_STRTOLL: u32 = 1;
pub const HAVE_STRTOULL: u32 = 1;
pub const HAVE_STRUCT_ADDRINFO: u32 = 1;
pub const HAVE_STRUCT_OPTION: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_STORAGE: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_store_SS_FAMILY: u32 = 1;
pub const HAVE_STRUCT_SOCKADDR_UN: u32 = 1;
pub const HAVE_STRUCT_TM_TM_ZONE: u32 = 1;
pub const HAVE_SYMLINK: u32 = 1;
pub const HAVE_SYNCFS: u32 = 1;
pub const HAVE_SYNC_FILE_RANGE: u32 = 1;
pub const HAVE_SYSLOG: u32 = 1;
pub const HAVE_SYS_EPOLL_H: u32 = 1;
pub const HAVE_SYS_IPC_H: u32 = 1;
pub const HAVE_SYS_PRCTL_H: u32 = 1;
pub const HAVE_SYS_RESOURCE_H: u32 = 1;
pub const HAVE_SYS_SELECT_H: u32 = 1;
pub const HAVE_SYS_SEM_H: u32 = 1;
pub const HAVE_SYS_SHM_H: u32 = 1;
pub const HAVE_SYS_STAT_H: u32 = 1;
pub const HAVE_SYS_TYPES_H: u32 = 1;
pub const HAVE_SYS_UIO_H: u32 = 1;
pub const HAVE_SYS_UN_H: u32 = 1;
pub const HAVE_TERMIOS_H: u32 = 1;
pub const HAVE_TYPEOF: u32 = 1;
pub const HAVE_UNSETENV: u32 = 1;
pub const HAVE_USELOCALE: u32 = 1;
pub const HAVE_WCTYPE_H: u32 = 1;
pub const HAVE_WRITEV: u32 = 1;
pub const HAVE_X86_64_POPCNTQ: u32 = 1;
pub const HAVE__BOOL: u32 = 1;
pub const HAVE__BUILTIN_BSWAP16: u32 = 1;
pub const HAVE__BUILTIN_BSWAP32: u32 = 1;
pub const HAVE__BUILTIN_BSWAP64: u32 = 1;
pub const HAVE__BUILTIN_CLZ: u32 = 1;
pub const HAVE__BUILTIN_CONSTANT_P: u32 = 1;
pub const HAVE__BUILTIN_CTZ: u32 = 1;
pub const HAVE__BUILTIN_OP_OVERFLOW: u32 = 1;
pub const HAVE__BUILTIN_POPCOUNT: u32 = 1;
pub const HAVE__BUILTIN_TYPES_COMPATIBLE_P: u32 = 1;
pub const HAVE__BUILTIN_UNREACHABLE: u32 = 1;
pub const HAVE__GET_CPUID: u32 = 1;
pub const HAVE__STATIC_ASSERT: u32 = 1;
pub const INT64_MODIFIER: &[u8; 2] = b"l\0";
pub const MAXIMUM_ALIGNOF: u32 = 8;
pub const MEMSET_LOOP_LIMIT: u32 = 1024;
pub const PACKAGE_BUGREPORT: &[u8; 32] = b"pgsql-bugs@lists.postgresql.org\0";
pub const PACKAGE_NAME: &[u8; 11] = b"PostgreSQL\0";
pub const PACKAGE_STRING: &[u8; 16] = b"PostgreSQL 14.2\0";
pub const PACKAGE_TARNAME: &[u8; 11] = b"postgresql\0";
pub const PACKAGE_URL: &[u8; 28] = b"https://www.postgresql.org/\0";
pub const PACKAGE_VERSION: &[u8; 5] = b"14.2\0";
pub const PG_KRB_SRVNAM: &[u8; 9] = b"postgres\0";
pub const PG_MAJORVERSION: &[u8; 3] = b"14\0";
pub const PG_MAJORVERSION_NUM: u32 = 14;
pub const PG_MINORVERSION_NUM: u32 = 2;
pub const PG_USE_STDBOOL: u32 = 1;
pub const PG_VERSION: &[u8; 5] = b"14.2\0";
pub const PG_VERSION_NUM: u32 = 140002;
pub const PG_VERSION_STR : & [u8 ; 102] = b"PostgreSQL 14.2 on x86_64-pc-linux-gnu, compiled by gcc (Ubuntu 9.4.0-1ubuntu1~20.04.1) 9.4.0, 64-bit\0" ;
pub const RELSEG_SIZE: u32 = 131072;
pub const SIZEOF_BOOL: u32 = 1;
pub const SIZEOF_LONG: u32 = 8;
pub const SIZEOF_OFF_T: u32 = 8;
pub const SIZEOF_SIZE_T: u32 = 8;
pub const SIZEOF_VOID_P: u32 = 8;
pub const USE_LIBXML: u32 = 1;
pub const USE_SSE42_CRC32C_WITH_RUNTIME_CHECK: u32 = 1;
pub const USE_SYSV_SHARED_MEMORY: u32 = 1;
pub const USE_UNNAMED_POSIX_SEMAPHORES: u32 = 1;
pub const XLOG_BLCKSZ: u32 = 8192;
pub const DEFAULT_XLOG_SEG_SIZE: u32 = 16777216;
pub const NAMEDATALEN: u32 = 64;
pub const FUNC_MAX_ARGS: u32 = 100;
pub const FMGR_ABI_EXTRA: &[u8; 11] = b"PostgreSQL\0";
pub const INDEX_MAX_KEYS: u32 = 32;
pub const PARTITION_MAX_KEYS: u32 = 32;
pub const USE_FLOAT8_BYVAL: u32 = 1;
pub const NUM_SPINLOCK_SEMAPHORES: u32 = 128;
pub const NUM_ATOMICS_SEMAPHORES: u32 = 64;
pub const MAXPGPATH: u32 = 1024;
pub const PG_SOMAXCONN: u32 = 10000;
pub const BITS_PER_BYTE: u32 = 8;
pub const ALIGNOF_BUFFER: u32 = 32;
pub const HAVE_WORKING_LINK: u32 = 1;
pub const DEFAULT_BACKEND_FLUSH_AFTER: u32 = 0;
pub const DEFAULT_BGWRITER_FLUSH_AFTER: u32 = 64;
pub const DEFAULT_CHECKPOINT_FLUSH_AFTER: u32 = 32;
pub const WRITEBACK_MAX_PENDING_FLUSHES: u32 = 256;
pub const DEFAULT_PGSOCKET_DIR: &[u8; 5] = b"/tmp\0";
pub const DEFAULT_EVENT_SOURCE: &[u8; 11] = b"PostgreSQL\0";
pub const PG_CACHE_LINE_SIZE: u32 = 128;
pub const TRACE_SORT: u32 = 1;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const _BITS_ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const _BITS_ENDIANNESS_H: u32 = 1;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &[u8; 6] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const _THREAD_MUTEX_INTERNAL_H: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _ERRNO_H: u32 = 1;
pub const _BITS_ERRNO_H: u32 = 1;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EAGAIN: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EDEADLK: u32 = 35;
pub const ENAMETOOLONG: u32 = 36;
pub const ENOLCK: u32 = 37;
pub const ENOSYS: u32 = 38;
pub const ENOTEMPTY: u32 = 39;
pub const ELOOP: u32 = 40;
pub const EWOULDBLOCK: u32 = 11;
pub const ENOMSG: u32 = 42;
pub const EIDRM: u32 = 43;
pub const ECHRNG: u32 = 44;
pub const EL2NSYNC: u32 = 45;
pub const EL3HLT: u32 = 46;
pub const EL3RST: u32 = 47;
pub const ELNRNG: u32 = 48;
pub const EUNATCH: u32 = 49;
pub const ENOCSI: u32 = 50;
pub const EL2HLT: u32 = 51;
pub const EBADE: u32 = 52;
pub const EBADR: u32 = 53;
pub const EXFULL: u32 = 54;
pub const ENOANO: u32 = 55;
pub const EBADRQC: u32 = 56;
pub const EBADSLT: u32 = 57;
pub const EDEADLOCK: u32 = 35;
pub const EBFONT: u32 = 59;
pub const ENOSTR: u32 = 60;
pub const ENODATA: u32 = 61;
pub const ETIME: u32 = 62;
pub const ENOSR: u32 = 63;
pub const ENONET: u32 = 64;
pub const ENOPKG: u32 = 65;
pub const EREMOTE: u32 = 66;
pub const ENOLINK: u32 = 67;
pub const EADV: u32 = 68;
pub const ESRMNT: u32 = 69;
pub const ECOMM: u32 = 70;
pub const EPROTO: u32 = 71;
pub const EMULTIHOP: u32 = 72;
pub const EDOTDOT: u32 = 73;
pub const EBADMSG: u32 = 74;
pub const EOVERFLOW: u32 = 75;
pub const ENOTUNIQ: u32 = 76;
pub const EBADFD: u32 = 77;
pub const EREMCHG: u32 = 78;
pub const ELIBACC: u32 = 79;
pub const ELIBBAD: u32 = 80;
pub const ELIBSCN: u32 = 81;
pub const ELIBMAX: u32 = 82;
pub const ELIBEXEC: u32 = 83;
pub const EILSEQ: u32 = 84;
pub const ERESTART: u32 = 85;
pub const ESTRPIPE: u32 = 86;
pub const EUSERS: u32 = 87;
pub const ENOTSOCK: u32 = 88;
pub const EDESTADDRREQ: u32 = 89;
pub const EMSGSIZE: u32 = 90;
pub const EPROTOTYPE: u32 = 91;
pub const ENOPROTOOPT: u32 = 92;
pub const EPROTONOSUPPORT: u32 = 93;
pub const ESOCKTNOSUPPORT: u32 = 94;
pub const EOPNOTSUPP: u32 = 95;
pub const EPFNOSUPPORT: u32 = 96;
pub const EAFNOSUPPORT: u32 = 97;
pub const EADDRINUSE: u32 = 98;
pub const EADDRNOTAVAIL: u32 = 99;
pub const ENETDOWN: u32 = 100;
pub const ENETUNREACH: u32 = 101;
pub const ENETRESET: u32 = 102;
pub const ECONNABORTED: u32 = 103;
pub const ECONNRESET: u32 = 104;
pub const ENOBUFS: u32 = 105;
pub const EISCONN: u32 = 106;
pub const ENOTCONN: u32 = 107;
pub const ESHUTDOWN: u32 = 108;
pub const ETOOMANYREFS: u32 = 109;
pub const ETIMEDOUT: u32 = 110;
pub const ECONNREFUSED: u32 = 111;
pub const EHOSTDOWN: u32 = 112;
pub const EHOSTUNREACH: u32 = 113;
pub const EALREADY: u32 = 114;
pub const EINPROGRESS: u32 = 115;
pub const ESTALE: u32 = 116;
pub const EUCLEAN: u32 = 117;
pub const ENOTNAM: u32 = 118;
pub const ENAVAIL: u32 = 119;
pub const EISNAM: u32 = 120;
pub const EREMOTEIO: u32 = 121;
pub const EDQUOT: u32 = 122;
pub const ENOMEDIUM: u32 = 123;
pub const EMEDIUMTYPE: u32 = 124;
pub const ECANCELED: u32 = 125;
pub const ENOKEY: u32 = 126;
pub const EKEYEXPIRED: u32 = 127;
pub const EKEYREVOKED: u32 = 128;
pub const EKEYREJECTED: u32 = 129;
pub const EOWNERDEAD: u32 = 130;
pub const ENOTRECOVERABLE: u32 = 131;
pub const ERFKILL: u32 = 132;
pub const EHWPOISON: u32 = 133;
pub const ENOTSUP: u32 = 95;
pub const _LOCALE_H: u32 = 1;
pub const _BITS_LOCALE_H: u32 = 1;
pub const __LC_CTYPE: u32 = 0;
pub const __LC_NUMERIC: u32 = 1;
pub const __LC_TIME: u32 = 2;
pub const __LC_COLLATE: u32 = 3;
pub const __LC_MONETARY: u32 = 4;
pub const __LC_MESSAGES: u32 = 5;
pub const __LC_ALL: u32 = 6;
pub const __LC_PAPER: u32 = 7;
pub const __LC_NAME: u32 = 8;
pub const __LC_ADDRESS: u32 = 9;
pub const __LC_TELEPHONE: u32 = 10;
pub const __LC_MEASUREMENT: u32 = 11;
pub const __LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE: u32 = 0;
pub const LC_NUMERIC: u32 = 1;
pub const LC_TIME: u32 = 2;
pub const LC_COLLATE: u32 = 3;
pub const LC_MONETARY: u32 = 4;
pub const LC_MESSAGES: u32 = 5;
pub const LC_ALL: u32 = 6;
pub const LC_PAPER: u32 = 7;
pub const LC_NAME: u32 = 8;
pub const LC_ADDRESS: u32 = 9;
pub const LC_TELEPHONE: u32 = 10;
pub const LC_MEASUREMENT: u32 = 11;
pub const LC_IDENTIFICATION: u32 = 12;
pub const LC_CTYPE_MASK: u32 = 1;
pub const LC_NUMERIC_MASK: u32 = 2;
pub const LC_TIME_MASK: u32 = 4;
pub const LC_COLLATE_MASK: u32 = 8;
pub const LC_MONETARY_MASK: u32 = 16;
pub const LC_MESSAGES_MASK: u32 = 32;
pub const LC_PAPER_MASK: u32 = 128;
pub const LC_NAME_MASK: u32 = 256;
pub const LC_ADDRESS_MASK: u32 = 512;
pub const LC_TELEPHONE_MASK: u32 = 1024;
pub const LC_MEASUREMENT_MASK: u32 = 2048;
pub const LC_IDENTIFICATION_MASK: u32 = 4096;
pub const LC_ALL_MASK: u32 = 8127;
pub const HAVE_PG_ATTRIBUTE_NORETURN: u32 = 1;
pub const INT64_FORMAT: &[u8; 4] = b"%ld\0";
pub const UINT64_FORMAT: &[u8; 4] = b"%lu\0";
pub const HAVE_INT128: u32 = 1;
pub const PG_INT8_MIN: i32 = -128;
pub const PG_INT8_MAX: u32 = 127;
pub const PG_UINT8_MAX: u32 = 255;
pub const PG_INT16_MIN: i32 = -32768;
pub const PG_INT16_MAX: u32 = 32767;
pub const PG_UINT16_MAX: u32 = 65535;
pub const PG_INT32_MIN: i32 = -2147483648;
pub const PG_INT32_MAX: u32 = 2147483647;
pub const PG_UINT32_MAX: u32 = 4294967295;
pub const FLOAT8PASSBYVAL: u32 = 1;
pub const HAVE_UNIX_SOCKETS: u32 = 1;
pub const HIGHBIT: u32 = 128;
pub const ESCAPE_STRING_SYNTAX: u8 = 69u8;
pub const STATUS_OK: u32 = 0;
pub const STATUS_ERROR: i32 = -1;
pub const STATUS_EOF: i32 = -2;
pub const PG_BINARY: u32 = 0;
pub const PG_BINARY_A: &[u8; 2] = b"a\0";
pub const PG_BINARY_R: &[u8; 2] = b"r\0";
pub const PG_BINARY_W: &[u8; 2] = b"w\0";
pub const _CTYPE_H: u32 = 1;
pub const INFO: u32 = 17;
pub const NOTICE: u32 = 18;
pub const WARNING: u32 = 19;
pub const ERROR: u32 = 21;
pub const VARLENA_EXTSIZE_BITS: u32 = 30;
pub const VARLENA_EXTSIZE_MASK: u32 = 1073741823;
pub const VARATT_SHORT_MAX: u32 = 127;
pub const FIELDNO_NULLABLE_DATUM_DATUM: u32 = 0;
pub const FIELDNO_NULLABLE_DATUM_ISNULL: u32 = 1;
pub const SIZEOF_DATUM: u32 = 8;
pub const MAX_TIMESTAMP_PRECISION: u32 = 6;
pub const MAX_INTERVAL_PRECISION: u32 = 6;
pub const TS_PREC_INV: f64 = 1000000.0;
pub const DAYS_PER_YEAR: f64 = 365.25;
pub const MONTHS_PER_YEAR: u32 = 12;
pub const DAYS_PER_MONTH: u32 = 30;
pub const HOURS_PER_DAY: u32 = 24;
pub const SECS_PER_YEAR: u32 = 31557600;
pub const SECS_PER_DAY: u32 = 86400;
pub const SECS_PER_HOUR: u32 = 3600;
pub const SECS_PER_MINUTE: u32 = 60;
pub const MINS_PER_HOUR: u32 = 60;
pub const MAX_TZDISP_HOUR: u32 = 15;
pub const TZDISP_LIMIT: u32 = 57600;
pub const JULIAN_MINYEAR: i32 = -4713;
pub const JULIAN_MINMONTH: u32 = 11;
pub const JULIAN_MINDAY: u32 = 24;
pub const JULIAN_MAXYEAR: u32 = 5874898;
pub const JULIAN_MAXMONTH: u32 = 6;
pub const JULIAN_MAXDAY: u32 = 3;
pub const UNIX_EPOCH_JDATE: u32 = 2440588;
pub const POSTGRES_EPOCH_JDATE: u32 = 2451545;
pub const DATETIME_MIN_JULIAN: u32 = 0;
pub const DATE_END_JULIAN: u32 = 2147483494;
pub const TIMESTAMP_END_JULIAN: u32 = 109203528;
pub const _MATH_H: u32 = 1;
pub const _BITS_LIBM_SIMD_DECL_STUBS_H: u32 = 1;
pub const __FP_LOGB0_IS_MIN: u32 = 1;
pub const __FP_LOGBNAN_IS_MIN: u32 = 1;
pub const FP_ILOGB0: i32 = -2147483648;
pub const FP_ILOGBNAN: i32 = -2147483648;
pub const __MATH_DECLARING_DOUBLE: u32 = 1;
pub const __MATH_DECLARING_FLOATN: u32 = 0;
pub const __MATH_DECLARE_LDOUBLE: u32 = 1;
pub const FP_NAN: u32 = 0;
pub const FP_INFINITE: u32 = 1;
pub const FP_ZERO: u32 = 2;
pub const FP_SUBNORMAL: u32 = 3;
pub const FP_NORMAL: u32 = 4;
pub const MATH_ERRNO: u32 = 1;
pub const MATH_ERREXCEPT: u32 = 2;
pub const math_errhandling: u32 = 3;
pub const M_E: f64 = 2.718281828459045;
pub const M_LOG2E: f64 = 1.4426950408889634;
pub const M_LOG10E: f64 = 0.4342944819032518;
pub const M_LN2: f64 = 0.6931471805599453;
pub const M_LN10: f64 = 2.302585092994046;
pub const M_PI: f64 = 3.141592653589793;
pub const M_PI_2: f64 = 1.5707963267948966;
pub const M_PI_4: f64 = 0.7853981633974483;
pub const M_1_PI: f64 = 0.3183098861837907;
pub const M_2_PI: f64 = 0.6366197723675814;
pub const M_2_SQRTPI: f64 = 1.1283791670955126;
pub const M_SQRT2: f64 = 1.4142135623730951;
pub const M_SQRT1_2: f64 = 0.7071067811865476;
pub const TZ_STRLEN_MAX: u32 = 255;
pub const MAX_TIME_PRECISION: u32 = 6;
pub const INTERVAL_FULL_RANGE: u32 = 32767;
pub const INTERVAL_RANGE_MASK: u32 = 32767;
pub const INTERVAL_FULL_PRECISION: u32 = 65535;
pub const INTERVAL_PRECISION_MASK: u32 = 65535;
pub const SKIPLIST_MAXLEVEL: u32 = 32;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    pub static sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    pub static pj_release: [::std::os::raw::c_char; 0usize];
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_AREA {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct P5_FACTORS {
    pub meridional_scale: f64,
    pub parallel_scale: f64,
    pub areal_scale: f64,
    pub angular_distortion: f64,
    pub meridian_parallel_angle: f64,
    pub meridian_convergence: f64,
    pub tissot_semimajor: f64,
    pub tissot_semiminor: f64,
    pub dx_dlam: f64,
    pub dx_dphi: f64,
    pub dy_dlam: f64,
    pub dy_dphi: f64,
}
#[test]
fn bindgen_test_layout_P5_FACTORS() {
    const UNINIT: ::std::mem::MaybeUninit<P5_FACTORS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<P5_FACTORS>(),
        96usize,
        concat!("Size of: ", stringify!(P5_FACTORS))
    );
    assert_eq!(
        ::std::mem::align_of::<P5_FACTORS>(),
        8usize,
        concat!("Alignment of ", stringify!(P5_FACTORS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meridional_scale) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(meridional_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parallel_scale) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(parallel_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).areal_scale) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(areal_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).angular_distortion) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(angular_distortion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meridian_parallel_angle) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(meridian_parallel_angle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).meridian_convergence) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(meridian_convergence)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tissot_semimajor) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(tissot_semimajor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tissot_semiminor) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(tissot_semiminor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dx_dlam) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(dx_dlam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dx_dphi) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(dx_dphi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dy_dlam) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(dy_dlam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dy_dphi) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(P5_FACTORS),
            "::",
            stringify!(dy_dphi)
        )
    );
}
pub type PJ_FACTORS = P5_FACTORS;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJconsts {
    _unused: [u8; 0],
}
pub type PJ = PJconsts;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LIST {
    pub id: *const ::std::os::raw::c_char,
    pub proj: ::std::option::Option<unsafe extern "C" fn(arg1: *mut PJ) -> *mut PJ>,
    pub descr: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_LIST() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_LIST> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_LIST>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_LIST))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LIST>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LIST))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LIST),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).proj) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LIST),
            "::",
            stringify!(proj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descr) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LIST),
            "::",
            stringify!(descr)
        )
    );
}
pub type PJ_OPERATIONS = PJ_LIST;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_ELLPS {
    pub id: *const ::std::os::raw::c_char,
    pub major: *const ::std::os::raw::c_char,
    pub ell: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_ELLPS() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_ELLPS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_ELLPS>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_ELLPS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_ELLPS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_ELLPS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_ELLPS),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_ELLPS),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ell) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_ELLPS),
            "::",
            stringify!(ell)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_ELLPS),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UNITS {
    pub id: *const ::std::os::raw::c_char,
    pub to_meter: *const ::std::os::raw::c_char,
    pub name: *const ::std::os::raw::c_char,
    pub factor: f64,
}
#[test]
fn bindgen_test_layout_PJ_UNITS() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_UNITS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_UNITS>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_UNITS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UNITS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UNITS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UNITS),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).to_meter) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UNITS),
            "::",
            stringify!(to_meter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UNITS),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).factor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UNITS),
            "::",
            stringify!(factor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_PRIME_MERIDIANS {
    pub id: *const ::std::os::raw::c_char,
    pub defn: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PJ_PRIME_MERIDIANS() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_PRIME_MERIDIANS> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_PRIME_MERIDIANS>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_PRIME_MERIDIANS))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_PRIME_MERIDIANS>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_PRIME_MERIDIANS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PRIME_MERIDIANS),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).defn) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PRIME_MERIDIANS),
            "::",
            stringify!(defn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XYZT {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_XYZT() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_XYZT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_XYZT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_XYZT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XYZT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XYZT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_XYZT),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_XYZT),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_XYZT),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_XYZT),
            "::",
            stringify!(t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UVWT {
    pub u: f64,
    pub v: f64,
    pub w: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_UVWT() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_UVWT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_UVWT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_UVWT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UVWT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UVWT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UVWT),
            "::",
            stringify!(u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UVWT),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UVWT),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_UVWT),
            "::",
            stringify!(t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LPZT {
    pub lam: f64,
    pub phi: f64,
    pub z: f64,
    pub t: f64,
}
#[test]
fn bindgen_test_layout_PJ_LPZT() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_LPZT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_LPZT>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_LPZT))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LPZT>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LPZT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZT),
            "::",
            stringify!(lam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZT),
            "::",
            stringify!(phi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZT),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZT),
            "::",
            stringify!(t)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OPK {
    pub o: f64,
    pub p: f64,
    pub k: f64,
}
#[test]
fn bindgen_test_layout_PJ_OPK() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_OPK> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_OPK>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_OPK))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_OPK>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_OPK))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).o) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(o))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(p))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).k) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(PJ_OPK), "::", stringify!(k))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_ENU {
    pub e: f64,
    pub n: f64,
    pub u: f64,
}
#[test]
fn bindgen_test_layout_PJ_ENU() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_ENU> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_ENU>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_ENU))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_ENU>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_ENU))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(e))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(PJ_ENU), "::", stringify!(u))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_GEOD {
    pub s: f64,
    pub a1: f64,
    pub a2: f64,
}
#[test]
fn bindgen_test_layout_PJ_GEOD() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_GEOD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_GEOD>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_GEOD))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_GEOD>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_GEOD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).s) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GEOD),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GEOD),
            "::",
            stringify!(a1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GEOD),
            "::",
            stringify!(a2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UV {
    pub u: f64,
    pub v: f64,
}
#[test]
fn bindgen_test_layout_PJ_UV() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_UV> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_UV>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_UV))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UV>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UV))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_UV), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_UV), "::", stringify!(v))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XY {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_PJ_XY() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_XY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_XY>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_XY))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XY>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_XY), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_XY), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LP {
    pub lam: f64,
    pub phi: f64,
}
#[test]
fn bindgen_test_layout_PJ_LP() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_LP> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_LP>(),
        16usize,
        concat!("Size of: ", stringify!(PJ_LP))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LP>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LP))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LP),
            "::",
            stringify!(lam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LP),
            "::",
            stringify!(phi)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_XYZ {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_PJ_XYZ() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_XYZ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_XYZ>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_XYZ))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_XYZ>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_XYZ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(y))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(PJ_XYZ), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_UVW {
    pub u: f64,
    pub v: f64,
    pub w: f64,
}
#[test]
fn bindgen_test_layout_PJ_UVW() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_UVW> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_UVW>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_UVW))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_UVW>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_UVW))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        8usize,
        concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(v))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(PJ_UVW), "::", stringify!(w))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_LPZ {
    pub lam: f64,
    pub phi: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_PJ_LPZ() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_LPZ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_LPZ>(),
        24usize,
        concat!("Size of: ", stringify!(PJ_LPZ))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_LPZ>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_LPZ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lam) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZ),
            "::",
            stringify!(lam)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).phi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_LPZ),
            "::",
            stringify!(phi)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!("Offset of field: ", stringify!(PJ_LPZ), "::", stringify!(z))
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PJ_COORD {
    pub v: [f64; 4usize],
    pub xyzt: PJ_XYZT,
    pub uvwt: PJ_UVWT,
    pub lpzt: PJ_LPZT,
    pub geod: PJ_GEOD,
    pub opk: PJ_OPK,
    pub enu: PJ_ENU,
    pub xyz: PJ_XYZ,
    pub uvw: PJ_UVW,
    pub lpz: PJ_LPZ,
    pub xy: PJ_XY,
    pub uv: PJ_UV,
    pub lp: PJ_LP,
}
#[test]
fn bindgen_test_layout_PJ_COORD() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_COORD> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_COORD>(),
        32usize,
        concat!("Size of: ", stringify!(PJ_COORD))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_COORD>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_COORD))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xyzt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(xyzt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uvwt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(uvwt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpzt) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(lpzt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geod) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(geod)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opk) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(opk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enu) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(enu)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xyz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(xyz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uvw) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(uvw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpz) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(lpz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xy) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(xy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(uv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_COORD),
            "::",
            stringify!(lp)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_INFO {
    pub major: ::std::os::raw::c_int,
    pub minor: ::std::os::raw::c_int,
    pub patch: ::std::os::raw::c_int,
    pub release: *const ::std::os::raw::c_char,
    pub version: *const ::std::os::raw::c_char,
    pub searchpath: *const ::std::os::raw::c_char,
    pub paths: *const *const ::std::os::raw::c_char,
    pub path_count: usize,
}
#[test]
fn bindgen_test_layout_PJ_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_INFO>(),
        56usize,
        concat!("Size of: ", stringify!(PJ_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(release)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).searchpath) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(searchpath)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).paths) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(paths)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_count) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INFO),
            "::",
            stringify!(path_count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_PROJ_INFO {
    pub id: *const ::std::os::raw::c_char,
    pub description: *const ::std::os::raw::c_char,
    pub definition: *const ::std::os::raw::c_char,
    pub has_inverse: ::std::os::raw::c_int,
    pub accuracy: f64,
}
#[test]
fn bindgen_test_layout_PJ_PROJ_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_PROJ_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_PROJ_INFO>(),
        40usize,
        concat!("Size of: ", stringify!(PJ_PROJ_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_PROJ_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_PROJ_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PROJ_INFO),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).description) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PROJ_INFO),
            "::",
            stringify!(description)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).definition) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PROJ_INFO),
            "::",
            stringify!(definition)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).has_inverse) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PROJ_INFO),
            "::",
            stringify!(has_inverse)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).accuracy) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_PROJ_INFO),
            "::",
            stringify!(accuracy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_GRID_INFO {
    pub gridname: [::std::os::raw::c_char; 32usize],
    pub filename: [::std::os::raw::c_char; 260usize],
    pub format: [::std::os::raw::c_char; 8usize],
    pub lowerleft: PJ_LP,
    pub upperright: PJ_LP,
    pub n_lon: ::std::os::raw::c_int,
    pub n_lat: ::std::os::raw::c_int,
    pub cs_lon: f64,
    pub cs_lat: f64,
}
#[test]
fn bindgen_test_layout_PJ_GRID_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_GRID_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_GRID_INFO>(),
        360usize,
        concat!("Size of: ", stringify!(PJ_GRID_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_GRID_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PJ_GRID_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gridname) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(gridname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).format) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lowerleft) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(lowerleft)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upperright) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(upperright)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_lon) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(n_lon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_lat) as usize - ptr as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(n_lat)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_lon) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(cs_lon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cs_lat) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_GRID_INFO),
            "::",
            stringify!(cs_lat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_INIT_INFO {
    pub name: [::std::os::raw::c_char; 32usize],
    pub filename: [::std::os::raw::c_char; 260usize],
    pub version: [::std::os::raw::c_char; 32usize],
    pub origin: [::std::os::raw::c_char; 32usize],
    pub lastupdate: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout_PJ_INIT_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PJ_INIT_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PJ_INIT_INFO>(),
        372usize,
        concat!("Size of: ", stringify!(PJ_INIT_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PJ_INIT_INFO>(),
        1usize,
        concat!("Alignment of ", stringify!(PJ_INIT_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INIT_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INIT_INFO),
            "::",
            stringify!(filename)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INIT_INFO),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).origin) as usize - ptr as usize },
        324usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INIT_INFO),
            "::",
            stringify!(origin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lastupdate) as usize - ptr as usize },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(PJ_INIT_INFO),
            "::",
            stringify!(lastupdate)
        )
    );
}
pub const PJ_LOG_LEVEL_PJ_LOG_NONE: PJ_LOG_LEVEL = 0;
pub const PJ_LOG_LEVEL_PJ_LOG_ERROR: PJ_LOG_LEVEL = 1;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG: PJ_LOG_LEVEL = 2;
pub const PJ_LOG_LEVEL_PJ_LOG_TRACE: PJ_LOG_LEVEL = 3;
pub const PJ_LOG_LEVEL_PJ_LOG_TELL: PJ_LOG_LEVEL = 4;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG_MAJOR: PJ_LOG_LEVEL = 2;
pub const PJ_LOG_LEVEL_PJ_LOG_DEBUG_MINOR: PJ_LOG_LEVEL = 3;
pub type PJ_LOG_LEVEL = ::std::os::raw::c_uint;
pub type PJ_LOG_FUNCTION = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: ::std::os::raw::c_int,
        arg3: *const ::std::os::raw::c_char,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct projCtx_t {
    _unused: [u8; 0],
}
pub type PJ_CONTEXT = projCtx_t;
extern "C" {
    pub fn proj_context_create() -> *mut PJ_CONTEXT;
}
extern "C" {
    pub fn proj_context_destroy(ctx: *mut PJ_CONTEXT) -> *mut PJ_CONTEXT;
}
pub type proj_file_finder = ::std::option::Option<
    unsafe extern "C" fn(
        ctx: *mut PJ_CONTEXT,
        arg1: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char,
>;
extern "C" {
    pub fn proj_context_set_file_finder(
        ctx: *mut PJ_CONTEXT,
        finder: proj_file_finder,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn proj_context_set_search_paths(
        ctx: *mut PJ_CONTEXT,
        count_paths: ::std::os::raw::c_int,
        paths: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_context_use_proj4_init_rules(ctx: *mut PJ_CONTEXT, enable: ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_context_get_use_proj4_init_rules(
        ctx: *mut PJ_CONTEXT,
        from_legacy_code_path: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_create(ctx: *mut PJ_CONTEXT, definition: *const ::std::os::raw::c_char) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_argv(
        ctx: *mut PJ_CONTEXT,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_crs_to_crs(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const ::std::os::raw::c_char,
        target_crs: *const ::std::os::raw::c_char,
        area: *mut PJ_AREA,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_crs_to_crs_from_pj(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const PJ,
        target_crs: *const PJ,
        area: *mut PJ_AREA,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_normalize_for_visualization(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_assign_context(pj: *mut PJ, ctx: *mut PJ_CONTEXT);
}
extern "C" {
    pub fn proj_destroy(P: *mut PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_area_create() -> *mut PJ_AREA;
}
extern "C" {
    pub fn proj_area_set_bbox(
        area: *mut PJ_AREA,
        west_lon_degree: f64,
        south_lat_degree: f64,
        east_lon_degree: f64,
        north_lat_degree: f64,
    );
}
extern "C" {
    pub fn proj_area_destroy(area: *mut PJ_AREA);
}
pub const PJ_DIRECTION_PJ_FWD: PJ_DIRECTION = 1;
pub const PJ_DIRECTION_PJ_IDENT: PJ_DIRECTION = 0;
pub const PJ_DIRECTION_PJ_INV: PJ_DIRECTION = -1;
pub type PJ_DIRECTION = ::std::os::raw::c_int;
extern "C" {
    pub fn proj_angular_input(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_angular_output(P: *mut PJ, dir: PJ_DIRECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_trans(P: *mut PJ, direction: PJ_DIRECTION, coord: PJ_COORD) -> PJ_COORD;
}
extern "C" {
    pub fn proj_trans_array(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        n: usize,
        coord: *mut PJ_COORD,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_trans_generic(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        x: *mut f64,
        sx: usize,
        nx: usize,
        y: *mut f64,
        sy: usize,
        ny: usize,
        z: *mut f64,
        sz: usize,
        nz: usize,
        t: *mut f64,
        st: usize,
        nt: usize,
    ) -> usize;
}
extern "C" {
    pub fn proj_coord(x: f64, y: f64, z: f64, t: f64) -> PJ_COORD;
}
extern "C" {
    pub fn proj_roundtrip(
        P: *mut PJ,
        direction: PJ_DIRECTION,
        n: ::std::os::raw::c_int,
        coord: *mut PJ_COORD,
    ) -> f64;
}
extern "C" {
    pub fn proj_lp_dist(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_lpz_dist(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_xy_dist(a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_xyz_dist(a: PJ_COORD, b: PJ_COORD) -> f64;
}
extern "C" {
    pub fn proj_geod(P: *const PJ, a: PJ_COORD, b: PJ_COORD) -> PJ_COORD;
}
extern "C" {
    pub fn proj_context_errno(ctx: *mut PJ_CONTEXT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno(P: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_set(P: *const PJ, err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_reset(P: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_restore(P: *const PJ, err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_errno_string(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_log_level(ctx: *mut PJ_CONTEXT, log_level: PJ_LOG_LEVEL) -> PJ_LOG_LEVEL;
}
extern "C" {
    pub fn proj_log_func(
        ctx: *mut PJ_CONTEXT,
        app_data: *mut ::std::os::raw::c_void,
        logf: PJ_LOG_FUNCTION,
    );
}
extern "C" {
    pub fn proj_factors(P: *mut PJ, lp: PJ_COORD) -> PJ_FACTORS;
}
extern "C" {
    pub fn proj_info() -> PJ_INFO;
}
extern "C" {
    pub fn proj_pj_info(P: *mut PJ) -> PJ_PROJ_INFO;
}
extern "C" {
    pub fn proj_grid_info(gridname: *const ::std::os::raw::c_char) -> PJ_GRID_INFO;
}
extern "C" {
    pub fn proj_init_info(initname: *const ::std::os::raw::c_char) -> PJ_INIT_INFO;
}
extern "C" {
    pub fn proj_list_operations() -> *const PJ_OPERATIONS;
}
extern "C" {
    pub fn proj_list_ellps() -> *const PJ_ELLPS;
}
extern "C" {
    pub fn proj_list_units() -> *const PJ_UNITS;
}
extern "C" {
    pub fn proj_list_angular_units() -> *const PJ_UNITS;
}
extern "C" {
    pub fn proj_list_prime_meridians() -> *const PJ_PRIME_MERIDIANS;
}
extern "C" {
    pub fn proj_torad(angle_in_degrees: f64) -> f64;
}
extern "C" {
    pub fn proj_todeg(angle_in_radians: f64) -> f64;
}
extern "C" {
    pub fn proj_dmstor(
        is: *const ::std::os::raw::c_char,
        rs: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn proj_rtodms(
        s: *mut ::std::os::raw::c_char,
        r: f64,
        pos: ::std::os::raw::c_int,
        neg: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_cleanup();
}
pub type PROJ_STRING_LIST = *mut *mut ::std::os::raw::c_char;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2019: PJ_GUESSED_WKT_DIALECT = 0;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2018: PJ_GUESSED_WKT_DIALECT = 0;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT2_2015: PJ_GUESSED_WKT_DIALECT = 1;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT1_GDAL: PJ_GUESSED_WKT_DIALECT = 2;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_WKT1_ESRI: PJ_GUESSED_WKT_DIALECT = 3;
pub const PJ_GUESSED_WKT_DIALECT_PJ_GUESSED_NOT_WKT: PJ_GUESSED_WKT_DIALECT = 4;
pub type PJ_GUESSED_WKT_DIALECT = ::std::os::raw::c_uint;
pub const PJ_CATEGORY_PJ_CATEGORY_ELLIPSOID: PJ_CATEGORY = 0;
pub const PJ_CATEGORY_PJ_CATEGORY_PRIME_MERIDIAN: PJ_CATEGORY = 1;
pub const PJ_CATEGORY_PJ_CATEGORY_DATUM: PJ_CATEGORY = 2;
pub const PJ_CATEGORY_PJ_CATEGORY_CRS: PJ_CATEGORY = 3;
pub const PJ_CATEGORY_PJ_CATEGORY_COORDINATE_OPERATION: PJ_CATEGORY = 4;
pub type PJ_CATEGORY = ::std::os::raw::c_uint;
pub const PJ_TYPE_PJ_TYPE_UNKNOWN: PJ_TYPE = 0;
pub const PJ_TYPE_PJ_TYPE_ELLIPSOID: PJ_TYPE = 1;
pub const PJ_TYPE_PJ_TYPE_PRIME_MERIDIAN: PJ_TYPE = 2;
pub const PJ_TYPE_PJ_TYPE_GEODETIC_REFERENCE_FRAME: PJ_TYPE = 3;
pub const PJ_TYPE_PJ_TYPE_DYNAMIC_GEODETIC_REFERENCE_FRAME: PJ_TYPE = 4;
pub const PJ_TYPE_PJ_TYPE_VERTICAL_REFERENCE_FRAME: PJ_TYPE = 5;
pub const PJ_TYPE_PJ_TYPE_DYNAMIC_VERTICAL_REFERENCE_FRAME: PJ_TYPE = 6;
pub const PJ_TYPE_PJ_TYPE_DATUM_ENSEMBLE: PJ_TYPE = 7;
pub const PJ_TYPE_PJ_TYPE_CRS: PJ_TYPE = 8;
pub const PJ_TYPE_PJ_TYPE_GEODETIC_CRS: PJ_TYPE = 9;
pub const PJ_TYPE_PJ_TYPE_GEOCENTRIC_CRS: PJ_TYPE = 10;
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_CRS: PJ_TYPE = 11;
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_2D_CRS: PJ_TYPE = 12;
pub const PJ_TYPE_PJ_TYPE_GEOGRAPHIC_3D_CRS: PJ_TYPE = 13;
pub const PJ_TYPE_PJ_TYPE_VERTICAL_CRS: PJ_TYPE = 14;
pub const PJ_TYPE_PJ_TYPE_PROJECTED_CRS: PJ_TYPE = 15;
pub const PJ_TYPE_PJ_TYPE_COMPOUND_CRS: PJ_TYPE = 16;
pub const PJ_TYPE_PJ_TYPE_TEMPORAL_CRS: PJ_TYPE = 17;
pub const PJ_TYPE_PJ_TYPE_ENGINEERING_CRS: PJ_TYPE = 18;
pub const PJ_TYPE_PJ_TYPE_BOUND_CRS: PJ_TYPE = 19;
pub const PJ_TYPE_PJ_TYPE_OTHER_CRS: PJ_TYPE = 20;
pub const PJ_TYPE_PJ_TYPE_CONVERSION: PJ_TYPE = 21;
pub const PJ_TYPE_PJ_TYPE_TRANSFORMATION: PJ_TYPE = 22;
pub const PJ_TYPE_PJ_TYPE_CONCATENATED_OPERATION: PJ_TYPE = 23;
pub const PJ_TYPE_PJ_TYPE_OTHER_COORDINATE_OPERATION: PJ_TYPE = 24;
pub type PJ_TYPE = ::std::os::raw::c_uint;
pub const PJ_COMPARISON_CRITERION_PJ_COMP_STRICT: PJ_COMPARISON_CRITERION = 0;
pub const PJ_COMPARISON_CRITERION_PJ_COMP_EQUIVALENT: PJ_COMPARISON_CRITERION = 1;
pub const PJ_COMPARISON_CRITERION_PJ_COMP_EQUIVALENT_EXCEPT_AXIS_ORDER_GEOGCRS:
    PJ_COMPARISON_CRITERION = 2;
pub type PJ_COMPARISON_CRITERION = ::std::os::raw::c_uint;
pub const PJ_WKT_TYPE_PJ_WKT2_2015: PJ_WKT_TYPE = 0;
pub const PJ_WKT_TYPE_PJ_WKT2_2015_SIMPLIFIED: PJ_WKT_TYPE = 1;
pub const PJ_WKT_TYPE_PJ_WKT2_2019: PJ_WKT_TYPE = 2;
pub const PJ_WKT_TYPE_PJ_WKT2_2018: PJ_WKT_TYPE = 2;
pub const PJ_WKT_TYPE_PJ_WKT2_2019_SIMPLIFIED: PJ_WKT_TYPE = 3;
pub const PJ_WKT_TYPE_PJ_WKT2_2018_SIMPLIFIED: PJ_WKT_TYPE = 3;
pub const PJ_WKT_TYPE_PJ_WKT1_GDAL: PJ_WKT_TYPE = 4;
pub const PJ_WKT_TYPE_PJ_WKT1_ESRI: PJ_WKT_TYPE = 5;
pub type PJ_WKT_TYPE = ::std::os::raw::c_uint;
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_NONE: PROJ_CRS_EXTENT_USE = 0;
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_BOTH: PROJ_CRS_EXTENT_USE = 1;
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_INTERSECTION: PROJ_CRS_EXTENT_USE = 2;
pub const PROJ_CRS_EXTENT_USE_PJ_CRS_EXTENT_SMALLEST: PROJ_CRS_EXTENT_USE = 3;
pub type PROJ_CRS_EXTENT_USE = ::std::os::raw::c_uint;
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_USED_FOR_SORTING:
    PROJ_GRID_AVAILABILITY_USE = 0;
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_DISCARD_OPERATION_IF_MISSING_GRID:
    PROJ_GRID_AVAILABILITY_USE = 1;
pub const PROJ_GRID_AVAILABILITY_USE_PROJ_GRID_AVAILABILITY_IGNORED: PROJ_GRID_AVAILABILITY_USE = 2;
pub type PROJ_GRID_AVAILABILITY_USE = ::std::os::raw::c_uint;
pub const PJ_PROJ_STRING_TYPE_PJ_PROJ_5: PJ_PROJ_STRING_TYPE = 0;
pub const PJ_PROJ_STRING_TYPE_PJ_PROJ_4: PJ_PROJ_STRING_TYPE = 1;
pub type PJ_PROJ_STRING_TYPE = ::std::os::raw::c_uint;
pub const PROJ_SPATIAL_CRITERION_PROJ_SPATIAL_CRITERION_STRICT_CONTAINMENT: PROJ_SPATIAL_CRITERION =
    0;
pub const PROJ_SPATIAL_CRITERION_PROJ_SPATIAL_CRITERION_PARTIAL_INTERSECTION:
    PROJ_SPATIAL_CRITERION = 1;
pub type PROJ_SPATIAL_CRITERION = ::std::os::raw::c_uint;
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_ALWAYS: PROJ_INTERMEDIATE_CRS_USE = 0;
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_IF_NO_DIRECT_TRANSFORMATION:
    PROJ_INTERMEDIATE_CRS_USE = 1;
pub const PROJ_INTERMEDIATE_CRS_USE_PROJ_INTERMEDIATE_CRS_USE_NEVER: PROJ_INTERMEDIATE_CRS_USE = 2;
pub type PROJ_INTERMEDIATE_CRS_USE = ::std::os::raw::c_uint;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_UNKNOWN: PJ_COORDINATE_SYSTEM_TYPE = 0;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_CARTESIAN: PJ_COORDINATE_SYSTEM_TYPE = 1;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_ELLIPSOIDAL: PJ_COORDINATE_SYSTEM_TYPE = 2;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_VERTICAL: PJ_COORDINATE_SYSTEM_TYPE = 3;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_SPHERICAL: PJ_COORDINATE_SYSTEM_TYPE = 4;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_ORDINAL: PJ_COORDINATE_SYSTEM_TYPE = 5;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_PARAMETRIC: PJ_COORDINATE_SYSTEM_TYPE = 6;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_DATETIMETEMPORAL: PJ_COORDINATE_SYSTEM_TYPE = 7;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_TEMPORALCOUNT: PJ_COORDINATE_SYSTEM_TYPE = 8;
pub const PJ_COORDINATE_SYSTEM_TYPE_PJ_CS_TYPE_TEMPORALMEASURE: PJ_COORDINATE_SYSTEM_TYPE = 9;
pub type PJ_COORDINATE_SYSTEM_TYPE = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_CRS_INFO {
    pub auth_name: *mut ::std::os::raw::c_char,
    pub code: *mut ::std::os::raw::c_char,
    pub name: *mut ::std::os::raw::c_char,
    pub type_: PJ_TYPE,
    pub deprecated: ::std::os::raw::c_int,
    pub bbox_valid: ::std::os::raw::c_int,
    pub west_lon_degree: f64,
    pub south_lat_degree: f64,
    pub east_lon_degree: f64,
    pub north_lat_degree: f64,
    pub area_name: *mut ::std::os::raw::c_char,
    pub projection_method_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_PROJ_CRS_INFO() {
    const UNINIT: ::std::mem::MaybeUninit<PROJ_CRS_INFO> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROJ_CRS_INFO>(),
        88usize,
        concat!("Size of: ", stringify!(PROJ_CRS_INFO))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_CRS_INFO>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_CRS_INFO))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).auth_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(auth_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).deprecated) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(deprecated)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox_valid) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(bbox_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).west_lon_degree) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(west_lon_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).south_lat_degree) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(south_lat_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).east_lon_degree) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(east_lon_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).north_lat_degree) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(north_lat_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).area_name) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(area_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).projection_method_name) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_INFO),
            "::",
            stringify!(projection_method_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PROJ_CRS_LIST_PARAMETERS {
    pub types: *const PJ_TYPE,
    pub typesCount: usize,
    pub crs_area_of_use_contains_bbox: ::std::os::raw::c_int,
    pub bbox_valid: ::std::os::raw::c_int,
    pub west_lon_degree: f64,
    pub south_lat_degree: f64,
    pub east_lon_degree: f64,
    pub north_lat_degree: f64,
    pub allow_deprecated: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_PROJ_CRS_LIST_PARAMETERS() {
    const UNINIT: ::std::mem::MaybeUninit<PROJ_CRS_LIST_PARAMETERS> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PROJ_CRS_LIST_PARAMETERS>(),
        64usize,
        concat!("Size of: ", stringify!(PROJ_CRS_LIST_PARAMETERS))
    );
    assert_eq!(
        ::std::mem::align_of::<PROJ_CRS_LIST_PARAMETERS>(),
        8usize,
        concat!("Alignment of ", stringify!(PROJ_CRS_LIST_PARAMETERS))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).types) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).typesCount) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(typesCount)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).crs_area_of_use_contains_bbox) as usize - ptr as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(crs_area_of_use_contains_bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox_valid) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(bbox_valid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).west_lon_degree) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(west_lon_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).south_lat_degree) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(south_lat_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).east_lon_degree) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(east_lon_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).north_lat_degree) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(north_lat_degree)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_deprecated) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(PROJ_CRS_LIST_PARAMETERS),
            "::",
            stringify!(allow_deprecated)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OBJ_LIST {
    _unused: [u8; 0],
}
extern "C" {
    pub fn proj_string_list_destroy(list: PROJ_STRING_LIST);
}
extern "C" {
    pub fn proj_context_set_autoclose_database(
        ctx: *mut PJ_CONTEXT,
        autoclose: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_context_set_database_path(
        ctx: *mut PJ_CONTEXT,
        dbPath: *const ::std::os::raw::c_char,
        auxDbPaths: *const *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_context_get_database_path(ctx: *mut PJ_CONTEXT) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_get_database_metadata(
        ctx: *mut PJ_CONTEXT,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_context_guess_wkt_dialect(
        ctx: *mut PJ_CONTEXT,
        wkt: *const ::std::os::raw::c_char,
    ) -> PJ_GUESSED_WKT_DIALECT;
}
extern "C" {
    pub fn proj_create_from_wkt(
        ctx: *mut PJ_CONTEXT,
        wkt: *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
        out_warnings: *mut PROJ_STRING_LIST,
        out_grammar_errors: *mut PROJ_STRING_LIST,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        category: PJ_CATEGORY,
        usePROJAlternativeGridNames: ::std::os::raw::c_int,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_uom_get_info_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        code: *const ::std::os::raw::c_char,
        out_name: *mut *const ::std::os::raw::c_char,
        out_conv_factor: *mut f64,
        out_category: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_grid_get_info_from_database(
        ctx: *mut PJ_CONTEXT,
        grid_name: *const ::std::os::raw::c_char,
        out_full_name: *mut *const ::std::os::raw::c_char,
        out_package_name: *mut *const ::std::os::raw::c_char,
        out_url: *mut *const ::std::os::raw::c_char,
        out_direct_download: *mut ::std::os::raw::c_int,
        out_open_license: *mut ::std::os::raw::c_int,
        out_available: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_clone(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_create_from_name(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        searchedName: *const ::std::os::raw::c_char,
        types: *const PJ_TYPE,
        typesCount: usize,
        approximateMatch: ::std::os::raw::c_int,
        limitResultCount: usize,
        options: *const *const ::std::os::raw::c_char,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_get_type(obj: *const PJ) -> PJ_TYPE;
}
extern "C" {
    pub fn proj_is_deprecated(obj: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_non_deprecated(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_is_equivalent_to(
        obj: *const PJ,
        other: *const PJ,
        criterion: PJ_COMPARISON_CRITERION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_is_equivalent_to_with_ctx(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        other: *const PJ,
        criterion: PJ_COMPARISON_CRITERION,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_is_crs(obj: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_name(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_id_auth_name(
        obj: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_id_code(
        obj: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_remarks(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_scope(obj: *const PJ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_area_of_use(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        out_west_lon_degree: *mut f64,
        out_south_lat_degree: *mut f64,
        out_east_lon_degree: *mut f64,
        out_north_lat_degree: *mut f64,
        out_area_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_as_wkt(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        type_: PJ_WKT_TYPE,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_as_proj_string(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        type_: PJ_PROJ_STRING_TYPE,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_as_projjson(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        options: *const *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn proj_get_source_crs(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_get_target_crs(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_identify(
        ctx: *mut PJ_CONTEXT,
        obj: *const PJ,
        auth_name: *const ::std::os::raw::c_char,
        options: *const *const ::std::os::raw::c_char,
        out_confidence: *mut *mut ::std::os::raw::c_int,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_int_list_destroy(list: *mut ::std::os::raw::c_int);
}
extern "C" {
    pub fn proj_get_authorities_from_database(ctx: *mut PJ_CONTEXT) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_get_codes_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        type_: PJ_TYPE,
        allow_deprecated: ::std::os::raw::c_int,
    ) -> PROJ_STRING_LIST;
}
extern "C" {
    pub fn proj_get_crs_list_parameters_create() -> *mut PROJ_CRS_LIST_PARAMETERS;
}
extern "C" {
    pub fn proj_get_crs_list_parameters_destroy(params: *mut PROJ_CRS_LIST_PARAMETERS);
}
extern "C" {
    pub fn proj_get_crs_info_list_from_database(
        ctx: *mut PJ_CONTEXT,
        auth_name: *const ::std::os::raw::c_char,
        params: *const PROJ_CRS_LIST_PARAMETERS,
        out_result_count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut PROJ_CRS_INFO;
}
extern "C" {
    pub fn proj_crs_info_list_destroy(list: *mut *mut PROJ_CRS_INFO);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct PJ_OPERATION_FACTORY_CONTEXT {
    _unused: [u8; 0],
}
extern "C" {
    pub fn proj_create_operation_factory_context(
        ctx: *mut PJ_CONTEXT,
        authority: *const ::std::os::raw::c_char,
    ) -> *mut PJ_OPERATION_FACTORY_CONTEXT;
}
extern "C" {
    pub fn proj_operation_factory_context_destroy(ctx: *mut PJ_OPERATION_FACTORY_CONTEXT);
}
extern "C" {
    pub fn proj_operation_factory_context_set_desired_accuracy(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        accuracy: f64,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_area_of_interest(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        west_lon_degree: f64,
        south_lat_degree: f64,
        east_lon_degree: f64,
        north_lat_degree: f64,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_crs_extent_use(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_CRS_EXTENT_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_spatial_criterion(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        criterion: PROJ_SPATIAL_CRITERION,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_grid_availability_use(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_GRID_AVAILABILITY_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_use_proj_alternative_grid_names(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        usePROJNames: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_allow_use_intermediate_crs(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        use_: PROJ_INTERMEDIATE_CRS_USE,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_allowed_intermediate_crs(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        list_of_auth_name_codes: *const *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn proj_operation_factory_context_set_discard_superseded(
        ctx: *mut PJ_CONTEXT,
        factory_ctx: *mut PJ_OPERATION_FACTORY_CONTEXT,
        discard: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn proj_create_operations(
        ctx: *mut PJ_CONTEXT,
        source_crs: *const PJ,
        target_crs: *const PJ,
        operationContext: *const PJ_OPERATION_FACTORY_CONTEXT,
    ) -> *mut PJ_OBJ_LIST;
}
extern "C" {
    pub fn proj_list_get_count(result: *const PJ_OBJ_LIST) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_list_get(
        ctx: *mut PJ_CONTEXT,
        result: *const PJ_OBJ_LIST,
        index: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_list_destroy(result: *mut PJ_OBJ_LIST);
}
extern "C" {
    pub fn proj_crs_get_geodetic_crs(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_horizontal_datum(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_sub_crs(
        ctx: *mut PJ_CONTEXT,
        crs: *const PJ,
        index: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_datum(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_crs_get_coordinate_system(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_cs_get_type(ctx: *mut PJ_CONTEXT, cs: *const PJ) -> PJ_COORDINATE_SYSTEM_TYPE;
}
extern "C" {
    pub fn proj_cs_get_axis_count(ctx: *mut PJ_CONTEXT, cs: *const PJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_cs_get_axis_info(
        ctx: *mut PJ_CONTEXT,
        cs: *const PJ,
        index: ::std::os::raw::c_int,
        out_name: *mut *const ::std::os::raw::c_char,
        out_abbrev: *mut *const ::std::os::raw::c_char,
        out_direction: *mut *const ::std::os::raw::c_char,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
        out_unit_auth_name: *mut *const ::std::os::raw::c_char,
        out_unit_code: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_ellipsoid(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_ellipsoid_get_parameters(
        ctx: *mut PJ_CONTEXT,
        ellipsoid: *const PJ,
        out_semi_major_metre: *mut f64,
        out_semi_minor_metre: *mut f64,
        out_is_semi_minor_computed: *mut ::std::os::raw::c_int,
        out_inv_flattening: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_get_prime_meridian(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_prime_meridian_get_parameters(
        ctx: *mut PJ_CONTEXT,
        prime_meridian: *const PJ,
        out_longitude: *mut f64,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_crs_get_coordoperation(ctx: *mut PJ_CONTEXT, crs: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_coordoperation_get_method_info(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        out_method_name: *mut *const ::std::os::raw::c_char,
        out_method_auth_name: *mut *const ::std::os::raw::c_char,
        out_method_code: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_is_instantiable(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_has_ballpark_transformation(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param_count(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param_index(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_param(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        index: ::std::os::raw::c_int,
        out_name: *mut *const ::std::os::raw::c_char,
        out_auth_name: *mut *const ::std::os::raw::c_char,
        out_code: *mut *const ::std::os::raw::c_char,
        out_value: *mut f64,
        out_value_string: *mut *const ::std::os::raw::c_char,
        out_unit_conv_factor: *mut f64,
        out_unit_name: *mut *const ::std::os::raw::c_char,
        out_unit_auth_name: *mut *const ::std::os::raw::c_char,
        out_unit_code: *mut *const ::std::os::raw::c_char,
        out_unit_category: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_grid_used_count(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_grid_used(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        index: ::std::os::raw::c_int,
        out_short_name: *mut *const ::std::os::raw::c_char,
        out_full_name: *mut *const ::std::os::raw::c_char,
        out_package_name: *mut *const ::std::os::raw::c_char,
        out_url: *mut *const ::std::os::raw::c_char,
        out_direct_download: *mut ::std::os::raw::c_int,
        out_open_license: *mut ::std::os::raw::c_int,
        out_available: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_get_accuracy(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> f64;
}
extern "C" {
    pub fn proj_coordoperation_get_towgs84_values(
        ctx: *mut PJ_CONTEXT,
        coordoperation: *const PJ,
        out_values: *mut f64,
        value_count: ::std::os::raw::c_int,
        emit_error_if_incompatible: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_coordoperation_create_inverse(ctx: *mut PJ_CONTEXT, obj: *const PJ) -> *mut PJ;
}
extern "C" {
    pub fn proj_concatoperation_get_step_count(
        ctx: *mut PJ_CONTEXT,
        concatoperation: *const PJ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn proj_concatoperation_get_step(
        ctx: *mut PJ_CONTEXT,
        concatoperation: *const PJ,
        i_step: ::std::os::raw::c_int,
    ) -> *mut PJ;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPROJ {
    pub pj: *mut PJ,
    pub pipeline_is_forward: bool,
    pub source_is_latlong: u8,
    pub source_semi_major_metre: f64,
    pub source_semi_minor_metre: f64,
}
#[test]
fn bindgen_test_layout_LWPROJ() {
    const UNINIT: ::std::mem::MaybeUninit<LWPROJ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPROJ>(),
        32usize,
        concat!("Size of: ", stringify!(LWPROJ))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPROJ>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPROJ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pj) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(pj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pipeline_is_forward) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(pipeline_is_forward)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_is_latlong) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_is_latlong)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_semi_major_metre) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_semi_major_metre)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).source_semi_minor_metre) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPROJ),
            "::",
            stringify!(source_semi_minor_metre)
        )
    );
}
extern "C" {
    #[doc = " Return lwgeom version string (not to be freed)"]
    pub fn lwgeom_version() -> *const ::std::os::raw::c_char;
}
pub const LWORD_T_LWORD_X: LWORD_T = 0;
pub const LWORD_T_LWORD_Y: LWORD_T = 1;
pub const LWORD_T_LWORD_Z: LWORD_T = 2;
pub const LWORD_T_LWORD_M: LWORD_T = 3;
#[doc = " Ordinate names"]
pub type LWORD_T = ::std::os::raw::c_uint;
#[doc = " Ordinate names"]
pub use self::LWORD_T as LWORD;
extern "C" {
    #[doc = " Return a valid SRID from an arbitrary integer\n Raises a notice if what comes out is different from\n what went in.\n Raises an error if SRID value is out of bounds."]
    pub fn clamp_srid(srid: i32) -> i32;
}
#[doc = " Global functions for memory/logging handlers."]
pub type lwallocator =
    ::std::option::Option<unsafe extern "C" fn(size: usize) -> *mut ::std::os::raw::c_void>;
pub type lwreallocator = ::std::option::Option<
    unsafe extern "C" fn(
        mem: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type lwfreeor = ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
pub type lwreporter = ::std::option::Option<
    unsafe extern "C" fn(fmt: *const ::std::os::raw::c_char, ap: *mut __va_list_tag),
>;
pub type lwdebuglogger = ::std::option::Option<
    unsafe extern "C" fn(
        level: ::std::os::raw::c_int,
        fmt: *const ::std::os::raw::c_char,
        ap: *mut __va_list_tag,
    ),
>;
extern "C" {
    #[doc = " Install custom memory management and error handling functions you want your\n application to use.\n @ingroup system\n @todo take a structure ?"]
    pub fn lwgeom_set_handlers(
        allocator: lwallocator,
        reallocator: lwreallocator,
        freeor: lwfreeor,
        errorreporter: lwreporter,
        noticereporter: lwreporter,
    );
}
extern "C" {
    pub fn lwgeom_set_debuglogger(debuglogger: lwdebuglogger);
}
extern "C" {
    #[doc = " Request interruption of any running code\n\n Safe for use from signal handlers\n\n Interrupted code will (as soon as it finds out\n to be interrupted) cleanup and return as soon as possible.\n\n The return value from interrupted code is undefined,\n it is the caller responsibility to not take it in consideration.\n"]
    pub fn lwgeom_request_interrupt();
}
extern "C" {
    #[doc = " Cancel any interruption request"]
    pub fn lwgeom_cancel_interrupt();
}
#[doc = " Install a callback to be called periodically during\n algorithm execution. Mostly only needed on WIN32 to\n dispatch queued signals.\n\n The callback is invoked before checking for interrupt\n being requested, so you can request interruption from\n the callback, if you want (see lwgeom_request_interrupt).\n"]
pub type lwinterrupt_callback = ::std::option::Option<unsafe extern "C" fn()>;
extern "C" {
    pub fn lwgeom_register_interrupt_callback(arg1: lwinterrupt_callback) -> lwinterrupt_callback;
}
#[doc = " LWGEOM and GBOX both use LWFLAGS bit mask.\n Serializations (may) use different bit mask schemes."]
pub type lwflags_t = u16;
#[doc = " LWGEOM varlena equivalent type that contains both the size and\n data(see Postgresql c.h)"]
#[repr(C)]
#[derive(Debug)]
pub struct lwvarlena_t {
    pub size: u32,
    pub data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_lwvarlena_t() {
    const UNINIT: ::std::mem::MaybeUninit<lwvarlena_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lwvarlena_t>(),
        4usize,
        concat!("Size of: ", stringify!(lwvarlena_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lwvarlena_t>(),
        4usize,
        concat!("Alignment of ", stringify!(lwvarlena_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lwvarlena_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(lwvarlena_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct AFFINE {
    pub afac: f64,
    pub bfac: f64,
    pub cfac: f64,
    pub dfac: f64,
    pub efac: f64,
    pub ffac: f64,
    pub gfac: f64,
    pub hfac: f64,
    pub ifac: f64,
    pub xoff: f64,
    pub yoff: f64,
    pub zoff: f64,
}
#[test]
fn bindgen_test_layout_AFFINE() {
    const UNINIT: ::std::mem::MaybeUninit<AFFINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<AFFINE>(),
        96usize,
        concat!("Size of: ", stringify!(AFFINE))
    );
    assert_eq!(
        ::std::mem::align_of::<AFFINE>(),
        8usize,
        concat!("Alignment of ", stringify!(AFFINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).afac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(afac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bfac) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(bfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfac) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(cfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dfac) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(dfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).efac) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(efac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ffac) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(ffac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gfac) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(gfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hfac) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(hfac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ifac) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(ifac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xoff) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(xoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yoff) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(yoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zoff) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(AFFINE),
            "::",
            stringify!(zoff)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BOX3D {
    pub xmin: f64,
    pub ymin: f64,
    pub zmin: f64,
    pub xmax: f64,
    pub ymax: f64,
    pub zmax: f64,
    pub srid: i32,
}
#[test]
fn bindgen_test_layout_BOX3D() {
    const UNINIT: ::std::mem::MaybeUninit<BOX3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<BOX3D>(),
        56usize,
        concat!("Size of: ", stringify!(BOX3D))
    );
    assert_eq!(
        ::std::mem::align_of::<BOX3D>(),
        8usize,
        concat!("Alignment of ", stringify!(BOX3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BOX3D),
            "::",
            stringify!(srid)
        )
    );
}
#[doc = " GBOX structure.\n We include the flags (information about dimensionality),\n so we don't have to constantly pass them\n into functions that use the GBOX."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GBOX {
    pub flags: lwflags_t,
    pub xmin: f64,
    pub xmax: f64,
    pub ymin: f64,
    pub ymax: f64,
    pub zmin: f64,
    pub zmax: f64,
    pub mmin: f64,
    pub mmax: f64,
}
#[test]
fn bindgen_test_layout_GBOX() {
    const UNINIT: ::std::mem::MaybeUninit<GBOX> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GBOX>(),
        72usize,
        concat!("Size of: ", stringify!(GBOX))
    );
    assert_eq!(
        ::std::mem::align_of::<GBOX>(),
        8usize,
        concat!("Alignment of ", stringify!(GBOX))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmin) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(mmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mmax) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(GBOX),
            "::",
            stringify!(mmax)
        )
    );
}
#[doc = " SPHEROID\n\n  Standard definition of an ellipsoid (what wkt calls a spheroid)\n    f = (a-b)/a\n    e_sq = (a*a - b*b)/(a*a)\n    b = a - fa"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SPHEROID {
    pub a: f64,
    pub b: f64,
    pub f: f64,
    pub e: f64,
    pub e_sq: f64,
    pub radius: f64,
    pub name: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout_SPHEROID() {
    const UNINIT: ::std::mem::MaybeUninit<SPHEROID> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SPHEROID>(),
        72usize,
        concat!("Size of: ", stringify!(SPHEROID))
    );
    assert_eq!(
        ::std::mem::align_of::<SPHEROID>(),
        8usize,
        concat!("Alignment of ", stringify!(SPHEROID))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(e)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).e_sq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(e_sq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SPHEROID),
            "::",
            stringify!(name)
        )
    );
}
#[doc = " POINT2D, POINT3D, POINT3DM, POINT4D"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT2D {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_POINT2D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT2D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT2D>(),
        16usize,
        concat!("Size of: ", stringify!(POINT2D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT2D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT2D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT2D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT2D),
            "::",
            stringify!(y)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3DZ {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_POINT3DZ() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3DZ> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3DZ>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3DZ))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3DZ>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3DZ))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DZ),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
}
#[test]
fn bindgen_test_layout_POINT3D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3D>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3D),
            "::",
            stringify!(z)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT3DM {
    pub x: f64,
    pub y: f64,
    pub m: f64,
}
#[test]
fn bindgen_test_layout_POINT3DM() {
    const UNINIT: ::std::mem::MaybeUninit<POINT3DM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT3DM>(),
        24usize,
        concat!("Size of: ", stringify!(POINT3DM))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT3DM>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT3DM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT3DM),
            "::",
            stringify!(m)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINT4D {
    pub x: f64,
    pub y: f64,
    pub z: f64,
    pub m: f64,
}
#[test]
fn bindgen_test_layout_POINT4D() {
    const UNINIT: ::std::mem::MaybeUninit<POINT4D> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINT4D>(),
        32usize,
        concat!("Size of: ", stringify!(POINT4D))
    );
    assert_eq!(
        ::std::mem::align_of::<POINT4D>(),
        8usize,
        concat!("Alignment of ", stringify!(POINT4D))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(POINT4D),
            "::",
            stringify!(m)
        )
    );
}
#[doc = "  POINTARRAY\n  Point array abstracts a lot of the complexity of points and point lists.\n  It handles 2d/3d translation\n    (2d points converted to 3d will have z=0 or NaN)\n  DO NOT MIX 2D and 3D POINTS! EVERYTHING* is either one or the other"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct POINTARRAY {
    pub npoints: u32,
    pub maxpoints: u32,
    pub flags: lwflags_t,
    pub serialized_pointlist: *mut u8,
}
#[test]
fn bindgen_test_layout_POINTARRAY() {
    const UNINIT: ::std::mem::MaybeUninit<POINTARRAY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<POINTARRAY>(),
        24usize,
        concat!("Size of: ", stringify!(POINTARRAY))
    );
    assert_eq!(
        ::std::mem::align_of::<POINTARRAY>(),
        8usize,
        concat!("Alignment of ", stringify!(POINTARRAY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).npoints) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(npoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxpoints) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(maxpoints)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialized_pointlist) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(POINTARRAY),
            "::",
            stringify!(serialized_pointlist)
        )
    );
}
#[doc = " GSERIALIZED"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GSERIALIZED {
    pub size: u32,
    pub srid: [u8; 3usize],
    pub gflags: u8,
    pub data: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_GSERIALIZED() {
    const UNINIT: ::std::mem::MaybeUninit<GSERIALIZED> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<GSERIALIZED>(),
        12usize,
        concat!("Size of: ", stringify!(GSERIALIZED))
    );
    assert_eq!(
        ::std::mem::align_of::<GSERIALIZED>(),
        4usize,
        concat!("Alignment of ", stringify!(GSERIALIZED))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gflags) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(gflags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(GSERIALIZED),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " LWGEOM (any geometry type)\n\n Abstract type, note that 'type', 'bbox' and 'srid' are available in\n all geometry variants."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWGEOM {
    pub bbox: *mut GBOX,
    pub data: *mut ::std::os::raw::c_void,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWGEOM() {
    const UNINIT: ::std::mem::MaybeUninit<LWGEOM> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWGEOM>(),
        24usize,
        concat!("Size of: ", stringify!(LWGEOM))
    );
    assert_eq!(
        ::std::mem::align_of::<LWGEOM>(),
        8usize,
        concat!("Alignment of ", stringify!(LWGEOM))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWGEOM),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPOINT {
    pub bbox: *mut GBOX,
    pub point: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<LWPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPOINT>(),
        24usize,
        concat!("Size of: ", stringify!(LWPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPOINT>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).point) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOINT),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWLINE {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWLINE() {
    const UNINIT: ::std::mem::MaybeUninit<LWLINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWLINE>(),
        24usize,
        concat!("Size of: ", stringify!(LWLINE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWLINE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWLINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWLINE),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWTRIANGLE {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWTRIANGLE() {
    const UNINIT: ::std::mem::MaybeUninit<LWTRIANGLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWTRIANGLE>(),
        24usize,
        concat!("Size of: ", stringify!(LWTRIANGLE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWTRIANGLE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWTRIANGLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTRIANGLE),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCIRCSTRING {
    pub bbox: *mut GBOX,
    pub points: *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
}
#[test]
fn bindgen_test_layout_LWCIRCSTRING() {
    const UNINIT: ::std::mem::MaybeUninit<LWCIRCSTRING> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCIRCSTRING>(),
        24usize,
        concat!("Size of: ", stringify!(LWCIRCSTRING))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCIRCSTRING>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCIRCSTRING))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCIRCSTRING),
            "::",
            stringify!(pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPOLY {
    pub bbox: *mut GBOX,
    pub rings: *mut *mut POINTARRAY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub nrings: u32,
    pub maxrings: u32,
}
#[test]
fn bindgen_test_layout_LWPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(rings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(nrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrings) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPOLY),
            "::",
            stringify!(maxrings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMPOINT {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOINT,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMPOINT() {
    const UNINIT: ::std::mem::MaybeUninit<LWMPOINT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMPOINT>(),
        32usize,
        concat!("Size of: ", stringify!(LWMPOINT))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMPOINT>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMPOINT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOINT),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMLINE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWLINE,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMLINE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMLINE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMLINE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMLINE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMLINE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMLINE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMLINE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMPOLY {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOLY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWMPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWMPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMPOLY),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCOLLECTION {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWCOLLECTION() {
    const UNINIT: ::std::mem::MaybeUninit<LWCOLLECTION> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCOLLECTION>(),
        32usize,
        concat!("Size of: ", stringify!(LWCOLLECTION))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCOLLECTION>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCOLLECTION))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOLLECTION),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCOMPOUND {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWCOMPOUND() {
    const UNINIT: ::std::mem::MaybeUninit<LWCOMPOUND> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCOMPOUND>(),
        32usize,
        concat!("Size of: ", stringify!(LWCOMPOUND))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCOMPOUND>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCOMPOUND))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCOMPOUND),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWCURVEPOLY {
    pub bbox: *mut GBOX,
    pub rings: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub nrings: u32,
    pub maxrings: u32,
}
#[test]
fn bindgen_test_layout_LWCURVEPOLY() {
    const UNINIT: ::std::mem::MaybeUninit<LWCURVEPOLY> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWCURVEPOLY>(),
        32usize,
        concat!("Size of: ", stringify!(LWCURVEPOLY))
    );
    assert_eq!(
        ::std::mem::align_of::<LWCURVEPOLY>(),
        8usize,
        concat!("Alignment of ", stringify!(LWCURVEPOLY))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rings) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(rings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nrings) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(nrings)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxrings) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWCURVEPOLY),
            "::",
            stringify!(maxrings)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMCURVE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMCURVE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMCURVE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMCURVE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMCURVE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMCURVE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMCURVE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMCURVE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWMSURFACE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWGEOM,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWMSURFACE() {
    const UNINIT: ::std::mem::MaybeUninit<LWMSURFACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWMSURFACE>(),
        32usize,
        concat!("Size of: ", stringify!(LWMSURFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWMSURFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWMSURFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWMSURFACE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPSURFACE {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWPOLY,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWPSURFACE() {
    const UNINIT: ::std::mem::MaybeUninit<LWPSURFACE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWPSURFACE>(),
        32usize,
        concat!("Size of: ", stringify!(LWPSURFACE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWPSURFACE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWPSURFACE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWPSURFACE),
            "::",
            stringify!(maxgeoms)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWTIN {
    pub bbox: *mut GBOX,
    pub geoms: *mut *mut LWTRIANGLE,
    pub srid: i32,
    pub flags: lwflags_t,
    pub type_: u8,
    pub pad: [::std::os::raw::c_char; 1usize],
    pub ngeoms: u32,
    pub maxgeoms: u32,
}
#[test]
fn bindgen_test_layout_LWTIN() {
    const UNINIT: ::std::mem::MaybeUninit<LWTIN> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWTIN>(),
        32usize,
        concat!("Size of: ", stringify!(LWTIN))
    );
    assert_eq!(
        ::std::mem::align_of::<LWTIN>(),
        8usize,
        concat!("Alignment of ", stringify!(LWTIN))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bbox) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(bbox)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geoms) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(geoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pad) as usize - ptr as usize },
        23usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(pad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ngeoms) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(ngeoms)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxgeoms) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(LWTIN),
            "::",
            stringify!(maxgeoms)
        )
    );
}
extern "C" {
    pub fn lwgeom_as_lwmpoly(lwgeom: *const LWGEOM) -> *mut LWMPOLY;
}
extern "C" {
    pub fn lwgeom_as_lwmline(lwgeom: *const LWGEOM) -> *mut LWMLINE;
}
extern "C" {
    pub fn lwgeom_as_lwmpoint(lwgeom: *const LWGEOM) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwgeom_as_lwcollection(lwgeom: *const LWGEOM) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwgeom_as_lwpoly(lwgeom: *const LWGEOM) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwgeom_as_lwline(lwgeom: *const LWGEOM) -> *mut LWLINE;
}
extern "C" {
    pub fn lwgeom_as_lwcircstring(lwgeom: *const LWGEOM) -> *mut LWCIRCSTRING;
}
extern "C" {
    pub fn lwgeom_as_lwcurvepoly(lwgeom: *const LWGEOM) -> *mut LWCURVEPOLY;
}
extern "C" {
    pub fn lwgeom_as_lwcompound(lwgeom: *const LWGEOM) -> *mut LWCOMPOUND;
}
extern "C" {
    pub fn lwgeom_as_lwpsurface(lwgeom: *const LWGEOM) -> *mut LWPSURFACE;
}
extern "C" {
    pub fn lwgeom_as_lwtriangle(lwgeom: *const LWGEOM) -> *mut LWTRIANGLE;
}
extern "C" {
    pub fn lwgeom_as_lwtin(lwgeom: *const LWGEOM) -> *mut LWTIN;
}
extern "C" {
    pub fn lwgeom_as_multi(lwgeom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_as_curve(lwgeom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwtin_as_lwgeom(obj: *const LWTIN) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwtriangle_as_lwgeom(obj: *const LWTRIANGLE) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwpsurface_as_lwgeom(obj: *const LWPSURFACE) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwmpoly_as_lwgeom(obj: *const LWMPOLY) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwmline_as_lwgeom(obj: *const LWMLINE) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwmpoint_as_lwgeom(obj: *const LWMPOINT) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcollection_as_lwgeom(obj: *const LWCOLLECTION) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcircstring_as_lwgeom(obj: *const LWCIRCSTRING) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcompound_as_lwgeom(obj: *const LWCOMPOUND) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcurvepoly_as_lwgeom(obj: *const LWCURVEPOLY) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwpoly_as_lwgeom(obj: *const LWPOLY) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwline_as_lwgeom(obj: *const LWLINE) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwpoint_as_lwgeom(obj: *const LWPOINT) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcollection_add_lwgeom(
        col: *mut LWCOLLECTION,
        geom: *const LWGEOM,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwmpoint_add_lwpoint(mobj: *mut LWMPOINT, obj: *const LWPOINT) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwmline_add_lwline(mobj: *mut LWMLINE, obj: *const LWLINE) -> *mut LWMLINE;
}
extern "C" {
    pub fn lwmpoly_add_lwpoly(mobj: *mut LWMPOLY, obj: *const LWPOLY) -> *mut LWMPOLY;
}
extern "C" {
    pub fn lwpsurface_add_lwpoly(mobj: *mut LWPSURFACE, obj: *const LWPOLY) -> *mut LWPSURFACE;
}
extern "C" {
    pub fn lwtin_add_lwtriangle(mobj: *mut LWTIN, obj: *const LWTRIANGLE) -> *mut LWTIN;
}
extern "C" {
    pub fn lwcollection_concat_in_place(
        col1: *mut LWCOLLECTION,
        col2: *const LWCOLLECTION,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    #[doc = " Construct a new flags bitmask."]
    pub fn lwflags(
        hasz: ::std::os::raw::c_int,
        hasm: ::std::os::raw::c_int,
        geodetic: ::std::os::raw::c_int,
    ) -> lwflags_t;
}
extern "C" {
    #[doc = " Read standard lwflags from gserialized"]
    pub fn gserialized_get_lwflags(g: *const GSERIALIZED) -> lwflags_t;
}
extern "C" {
    #[doc = " Access to the float bounding box, if there is one.\n NULL if there is not."]
    pub fn gserialized_get_float_box_p(g: *const GSERIALIZED, ndims: *mut usize) -> *const f32;
}
extern "C" {
    #[doc = " Extract the geometry type from the serialized form (it hides in\n the anonymous data area, so this is a handy function)."]
    pub fn gserialized_get_type(g: *const GSERIALIZED) -> u32;
}
extern "C" {
    #[doc = " Returns the size in bytes to read from toast to get the basic\n information from a geometry: GSERIALIZED struct, bbox and type"]
    pub fn gserialized_max_header_size() -> u32;
}
extern "C" {
    #[doc = " Returns a hash code for the srid/type/geometry information\n in the GSERIALIZED. Ignores metadata like flags and optional\n boxes, etc."]
    pub fn gserialized_hash(g: *const GSERIALIZED) -> i32;
}
extern "C" {
    #[doc = " Extract the SRID from the serialized form (it is packed into\n three bytes so this is a handy function)."]
    pub fn gserialized_get_srid(g: *const GSERIALIZED) -> i32;
}
extern "C" {
    #[doc = " Write the SRID into the serialized form (it is packed into\n three bytes so this is a handy function)."]
    pub fn gserialized_set_srid(g: *mut GSERIALIZED, srid: i32);
}
extern "C" {
    #[doc = " Check if a #GSERIALIZED is empty without deserializing first.\n Only checks if the number of elements of the parent geometry\n is zero, will not catch collections of empty, eg:\n GEOMETRYCOLLECTION(POINT EMPTY)"]
    pub fn gserialized_is_empty(g: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a #GSERIALIZED has a bounding box without deserializing first."]
    pub fn gserialized_has_bbox(gser: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a #GSERIALIZED has a Z ordinate."]
    pub fn gserialized_has_z(gser: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a #GSERIALIZED has an M ordinate."]
    pub fn gserialized_has_m(gser: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a #GSERIALIZED is a geography."]
    pub fn gserialized_is_geodetic(gser: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of dimensions (2, 3, 4) in a geometry"]
    pub fn gserialized_ndims(gser: *const GSERIALIZED) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return -1 if g1 is \"less than\" g2, 1 if g1 is \"greater than\"\n g2 and 0 if g1 and g2 are the \"same\". Equality is evaluated\n with a memcmp and size check. So it is possible that two\n identical objects where one lacks a bounding box could be\n evaluated as non-equal initially. Greater and less than\n are evaluated by calculating a sortable key from the center\n point of the object bounds."]
    pub fn gserialized_cmp(g1: *const GSERIALIZED, g2: *const GSERIALIZED)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new #GSERIALIZED from an #LWGEOM. For all non-point types, a bounding\n box will be calculated and embedded in the serialization. The geodetic flag is used\n to control the box calculation (cartesian or geocentric). If set, the size pointer\n will contain the size of the final output, which is useful for setting the PgSQL\n VARSIZE information."]
    pub fn gserialized_from_lwgeom(geom: *mut LWGEOM, size: *mut usize) -> *mut GSERIALIZED;
}
extern "C" {
    #[doc = " Allocate a new #LWGEOM from a #GSERIALIZED. The resulting #LWGEOM will have coordinates\n that are double aligned and suitable for direct reading using getPoint2d_cp"]
    pub fn lwgeom_from_gserialized(g: *const GSERIALIZED) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Pull a #GBOX from the header of a #GSERIALIZED, if one is available. If\n it is not, calculate it from the geometry. If that doesn't work (null\n or empty) return LW_FAILURE."]
    pub fn gserialized_get_gbox_p(g: *const GSERIALIZED, box_: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Pull a #GBOX from the header of a #GSERIALIZED, if one is available. If\n it is not, return LW_FAILURE."]
    pub fn gserialized_fast_gbox_p(g: *const GSERIALIZED, box_: *mut GBOX)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy a new bounding box into an existing gserialized.\n If necessary a new #GSERIALIZED will be allocated. Test\n that input != output before freeing input."]
    pub fn gserialized_set_gbox(g: *mut GSERIALIZED, gbox: *mut GBOX) -> *mut GSERIALIZED;
}
extern "C" {
    #[doc = " Remove the bounding box from a #GSERIALIZED. Returns a freshly\n allocated #GSERIALIZED every time."]
    pub fn gserialized_drop_gbox(g: *mut GSERIALIZED) -> *mut GSERIALIZED;
}
extern "C" {
    #[doc = " Return the serialization version"]
    pub fn gserialized_get_version(g: *const GSERIALIZED) -> u32;
}
extern "C" {
    #[doc = " Pull the first point values of a #GSERIALIZED. Only works for POINTTYPE"]
    pub fn gserialized_peek_first_point(
        g: *const GSERIALIZED,
        out_point: *mut POINT4D,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Call this function to drop BBOX and SRID\n from LWGEOM. If LWGEOM type is *not* flagged\n with the HASBBOX flag and has a bbox, it\n will be released."]
    pub fn lwgeom_drop_bbox(lwgeom: *mut LWGEOM);
}
extern "C" {
    pub fn lwgeom_drop_srid(lwgeom: *mut LWGEOM);
}
extern "C" {
    #[doc = " Compute a bbox if not already computed\n\n After calling this function lwgeom->bbox is only\n NULL if the geometry is empty."]
    pub fn lwgeom_add_bbox(lwgeom: *mut LWGEOM);
}
extern "C" {
    #[doc = " Drop current bbox and calculate a fresh one."]
    pub fn lwgeom_refresh_bbox(lwgeom: *mut LWGEOM);
}
extern "C" {
    #[doc = " Compute a box for geom and all sub-geometries, if not already computed"]
    pub fn lwgeom_add_bbox_deep(lwgeom: *mut LWGEOM, gbox: *mut GBOX);
}
extern "C" {
    #[doc = " Get a non-empty geometry bounding box, computing and\n caching it if not already there\n\n NOTE: empty geometries don't have a bounding box so\n       you'd still get a NULL for them."]
    pub fn lwgeom_get_bbox(lwgeom: *const LWGEOM) -> *const GBOX;
}
extern "C" {
    #[doc = " Determine whether a LWGEOM can contain sub-geometries or not"]
    pub fn lwgeom_is_collection(lwgeom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if a LWGEOM has any non-finite (NaN or Inf) coordinates."]
    pub fn lwgeom_isfinite(lwgeom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine whether a type number is a collection or not"]
    pub fn lwtype_is_collection(type_: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given an lwtype number, what homogeneous collection can hold it?"]
    pub fn lwtype_get_collectiontype(type_: u8) -> u32;
}
extern "C" {
    #[doc = " Return the type name string associated with a type number\n (e.g. Point, LineString, Polygon)"]
    pub fn lwtype_name(type_: u8) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwtype_multitype(type_: u8) -> u8;
}
extern "C" {
    pub fn getPoint4d(pa: *const POINTARRAY, n: u32) -> POINT4D;
}
extern "C" {
    pub fn getPoint4d_p(
        pa: *const POINTARRAY,
        n: u32,
        point: *mut POINT4D,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getPoint3dz(pa: *const POINTARRAY, n: u32) -> POINT3DZ;
}
extern "C" {
    pub fn getPoint3dm(pa: *const POINTARRAY, n: u32) -> POINT3DM;
}
extern "C" {
    pub fn getPoint3dz_p(
        pa: *const POINTARRAY,
        n: u32,
        point: *mut POINT3DZ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getPoint3dm_p(
        pa: *const POINTARRAY,
        n: u32,
        point: *mut POINT3DM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getPoint2d(pa: *const POINTARRAY, n: u32) -> POINT2D;
}
extern "C" {
    pub fn getPoint2d_p(
        pa: *const POINTARRAY,
        n: u32,
        point: *mut POINT2D,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_set_point4d(pa: *mut POINTARRAY, n: u32, p4d: *const POINT4D);
}
extern "C" {
    #[doc = " Construct an empty pointarray, allocating storage and setting\n the npoints, but not filling in any information. Should be used in conjunction\n with ptarray_set_point4d to fill in the information in the array."]
    pub fn ptarray_construct(
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
        npoints: u32,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " Construct a new #POINTARRAY, <em>copying</em> in the data from ptlist"]
    pub fn ptarray_construct_copy_data(
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
        npoints: u32,
        ptlist: *const u8,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " Construct a new #POINTARRAY, <em>referencing</em> to the data from ptlist"]
    pub fn ptarray_construct_reference_data(
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
        npoints: u32,
        ptlist: *mut u8,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " Create a new #POINTARRAY with no points. Allocate enough storage\n to hold maxpoints vertices before having to reallocate the storage\n area."]
    pub fn ptarray_construct_empty(
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
        maxpoints: u32,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " Append a point to the end of an existing #POINTARRAY\n If allow_duplicate is LW_FALSE, then a duplicate point will\n not be added."]
    pub fn ptarray_append_point(
        pa: *mut POINTARRAY,
        pt: *const POINT4D,
        allow_duplicates: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Append a #POINTARRAY, pa2 to the end of an existing #POINTARRAY, pa1.\n\n If gap_tolerance is >= 0 then the end point of pa1 will be checked for\n being within gap_tolerance 2d distance from start point of pa2 or an\n error will be raised and LW_FAILURE returned.\n A gap_tolerance < 0 disables the check.\n\n If end point of pa1 and start point of pa2 are 2d-equal, then pa2 first\n point will not be appended."]
    pub fn ptarray_append_ptarray(
        pa1: *mut POINTARRAY,
        pa2: *mut POINTARRAY,
        gap_tolerance: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Insert a point into an existing #POINTARRAY. Zero\n is the index of the start of the array."]
    pub fn ptarray_insert_point(
        pa: *mut POINTARRAY,
        p: *const POINT4D,
        where_: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Remove a point from an existing #POINTARRAY. Zero\n is the index of the start of the array."]
    pub fn ptarray_remove_point(pa: *mut POINTARRAY, where_: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief Add a point in a pointarray.\n\n @param pa the source POINTARRAY\n @param p the point to add\n @param pdims number of ordinates in p (2..4)\n @param where to insert the point. 0 prepends, pa->npoints appends\n\n @returns a newly constructed POINTARRAY using a newly allocated buffer\n          for the actual points, or NULL on error."]
    pub fn ptarray_addPoint(
        pa: *const POINTARRAY,
        p: *mut u8,
        pdims: usize,
        where_: u32,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " @brief Remove a point from a pointarray.\n @param where -  is the offset (starting at 0)\n @return #POINTARRAY is newly allocated"]
    pub fn ptarray_removePoint(pa: *mut POINTARRAY, where_: u32) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " @brief Merge two given POINTARRAY and returns a pointer\n on the new aggregate one.\n Warning: this function free the two inputs POINTARRAY\n @return #POINTARRAY is newly allocated"]
    pub fn ptarray_merge(pa1: *mut POINTARRAY, pa2: *mut POINTARRAY) -> *mut POINTARRAY;
}
extern "C" {
    pub fn ptarray_is_closed(pa: *const POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_is_closed_2d(pa: *const POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_is_closed_3d(pa: *const POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_is_closed_z(pa: *const POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_flip_coordinates(pa: *mut POINTARRAY) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " @d1 start location (distance from start / total distance)\n @d2   end location (distance from start / total distance)\n @param tolerance snap to vertices at locations < tolerance away from given ones"]
    pub fn ptarray_substring(
        pa: *mut POINTARRAY,
        d1: f64,
        d2: f64,
        tolerance: f64,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " @param pa the subject pointarray\n @param qp the query point\n @param dist optional output for actual distance from vertex"]
    pub fn ptarray_closest_vertex_2d(
        pa: *const POINTARRAY,
        qp: *const POINT2D,
        dist: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @param pa the subject pointarray\n @param qp the query point\n @param dist optional output for actual distance from segment\n @return 0-based segment index for the closest segment\n         (earliest segment in case of same distance)"]
    pub fn ptarray_closest_segment_2d(
        pa: *const POINTARRAY,
        qp: *const POINT2D,
        dist: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Strip out the Z/M components of an #LWGEOM"]
    pub fn lwgeom_force_2d(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_force_3dz(geom: *const LWGEOM, zval: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_force_3dm(geom: *const LWGEOM, mval: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_force_4d(geom: *const LWGEOM, zval: f64, mval: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_set_effective_area(
        igeom: *const LWGEOM,
        set_area: ::std::os::raw::c_int,
        area: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_chaikin(
        igeom: *const LWGEOM,
        n_iterations: ::std::os::raw::c_int,
        preserve_endpoint: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_filter_m(
        geom: *mut LWGEOM,
        min: f64,
        max: f64,
        returnm: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_force_sfs(geom: *mut LWGEOM, version: ::std::os::raw::c_int) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwpoint_getPoint2d_p(point: *const LWPOINT, out: *mut POINT2D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwpoint_getPoint3dz_p(
        point: *const LWPOINT,
        out: *mut POINT3DZ,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwpoint_getPoint3dm_p(
        point: *const LWPOINT,
        out: *mut POINT3DM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwpoint_getPoint4d_p(point: *const LWPOINT, out: *mut POINT4D) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a LWPOINT to an LWLINE"]
    pub fn lwline_add_lwpoint(
        line: *mut LWLINE,
        point: *mut LWPOINT,
        where_: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Interpolate one or more points along a line"]
    pub fn lwline_interpolate_points(
        line: *const LWLINE,
        length_fraction: f64,
        repeat: ::std::os::raw::c_char,
    ) -> *mut POINTARRAY;
}
extern "C" {
    #[doc = " Interpolate one point along a line in 3D"]
    pub fn lwline_interpolate_point_3d(line: *const LWLINE, distance: f64) -> *mut LWPOINT;
}
extern "C" {
    #[doc = " Extend the ends of a line"]
    pub fn lwline_extend(
        line: *const LWLINE,
        distance_forward: f64,
        distance_backward: f64,
    ) -> *mut LWLINE;
}
extern "C" {
    #[doc = " Add a ring, allocating extra space if necessary. The polygon takes\n ownership of the passed point array."]
    pub fn lwpoly_add_ring(poly: *mut LWPOLY, pa: *mut POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a ring, allocating extra space if necessary. The curvepolygon takes\n ownership of the passed point array."]
    pub fn lwcurvepoly_add_ring(poly: *mut LWCURVEPOLY, ring: *mut LWGEOM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Add a component, allocating extra space if necessary. The compoundcurve\n takes owership of the passed geometry."]
    pub fn lwcompound_add_lwgeom(comp: *mut LWCOMPOUND, geom: *mut LWGEOM)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Construct an equivalent compound curve from a linestring.\n Compound curves can have linear components, so this works fine"]
    pub fn lwcompound_construct_from_lwline(lwpoly: *const LWLINE) -> *mut LWCOMPOUND;
}
extern "C" {
    #[doc = " Construct an equivalent curve polygon from a polygon. Curve polygons\n can have linear rings as their rings, so this works fine (in theory?)"]
    pub fn lwcurvepoly_construct_from_lwpoly(lwpoly: *mut LWPOLY) -> *mut LWCURVEPOLY;
}
extern "C" {
    #[doc = " LWGEOM functions"]
    pub fn lwcollection_ngeoms(col: *const LWCOLLECTION) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_homogenize(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " LWMULTIx and LWCOLLECTION functions"]
    pub fn lwcollection_getsubgeom(
        col: *mut LWCOLLECTION,
        gnum: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwcollection_extract(col: *const LWCOLLECTION, type_: u32) -> *mut LWCOLLECTION;
}
extern "C" {
    #[doc = " Set the SRID on an LWGEOM\n For collections, only the parent gets an SRID, all\n the children get SRID_UNKNOWN."]
    pub fn lwgeom_set_srid(geom: *mut LWGEOM, srid: i32);
}
extern "C" {
    pub fn box3d_from_gbox(gbox: *const GBOX) -> *mut BOX3D;
}
extern "C" {
    pub fn box3d_to_gbox(b3d: *const BOX3D) -> *mut GBOX;
}
extern "C" {
    pub fn expand_box3d(box_: *mut BOX3D, d: f64);
}
extern "C" {
    #[doc = " MEMORY MANAGEMENT"]
    pub fn ptarray_free(pa: *mut POINTARRAY);
}
extern "C" {
    pub fn lwpoint_free(pt: *mut LWPOINT);
}
extern "C" {
    pub fn lwline_free(line: *mut LWLINE);
}
extern "C" {
    pub fn lwpoly_free(poly: *mut LWPOLY);
}
extern "C" {
    pub fn lwtriangle_free(triangle: *mut LWTRIANGLE);
}
extern "C" {
    pub fn lwmpoint_free(mpt: *mut LWMPOINT);
}
extern "C" {
    pub fn lwmline_free(mline: *mut LWMLINE);
}
extern "C" {
    pub fn lwmpoly_free(mpoly: *mut LWMPOLY);
}
extern "C" {
    pub fn lwpsurface_free(psurf: *mut LWPSURFACE);
}
extern "C" {
    pub fn lwtin_free(tin: *mut LWTIN);
}
extern "C" {
    pub fn lwcollection_free(col: *mut LWCOLLECTION);
}
extern "C" {
    pub fn lwcircstring_free(curve: *mut LWCIRCSTRING);
}
extern "C" {
    pub fn lwgeom_free(geom: *mut LWGEOM);
}
extern "C" {
    pub fn lwpoint_release(lwpoint: *mut LWPOINT);
}
extern "C" {
    pub fn lwline_release(lwline: *mut LWLINE);
}
extern "C" {
    pub fn lwpoly_release(lwpoly: *mut LWPOLY);
}
extern "C" {
    pub fn lwtriangle_release(lwtriangle: *mut LWTRIANGLE);
}
extern "C" {
    pub fn lwcircstring_release(lwcirc: *mut LWCIRCSTRING);
}
extern "C" {
    pub fn lwmpoint_release(lwpoint: *mut LWMPOINT);
}
extern "C" {
    pub fn lwmline_release(lwline: *mut LWMLINE);
}
extern "C" {
    pub fn lwmpoly_release(lwpoly: *mut LWMPOLY);
}
extern "C" {
    pub fn lwpsurface_release(lwpsurface: *mut LWPSURFACE);
}
extern "C" {
    pub fn lwtin_release(lwtin: *mut LWTIN);
}
extern "C" {
    pub fn lwcollection_release(lwcollection: *mut LWCOLLECTION);
}
extern "C" {
    pub fn lwgeom_release(lwgeom: *mut LWGEOM);
}
extern "C" {
    #[doc = " Utility"]
    pub fn printBOX3D(b: *mut BOX3D);
}
extern "C" {
    pub fn printPA(pa: *mut POINTARRAY);
}
extern "C" {
    pub fn printLWPOINT(point: *mut LWPOINT);
}
extern "C" {
    pub fn printLWLINE(line: *mut LWLINE);
}
extern "C" {
    pub fn printLWPOLY(poly: *mut LWPOLY);
}
extern "C" {
    pub fn printLWTRIANGLE(triangle: *mut LWTRIANGLE);
}
extern "C" {
    pub fn printLWPSURFACE(psurf: *mut LWPSURFACE);
}
extern "C" {
    pub fn printLWTIN(tin: *mut LWTIN);
}
extern "C" {
    pub fn next_float_down(d: f64) -> f32;
}
extern "C" {
    pub fn next_float_up(d: f64) -> f32;
}
extern "C" {
    pub fn distance2d_pt_pt(p1: *const POINT2D, p2: *const POINT2D) -> f64;
}
extern "C" {
    pub fn distance2d_sqr_pt_seg(p: *const POINT2D, A: *const POINT2D, B: *const POINT2D) -> f64;
}
extern "C" {
    pub fn lwgeom_closest_line(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_furthest_line(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_closest_point(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_furthest_point(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_mindistance2d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_mindistance2d_tolerance(
        lw1: *const LWGEOM,
        lw2: *const LWGEOM,
        tolerance: f64,
    ) -> f64;
}
extern "C" {
    pub fn lwgeom_maxdistance2d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_maxdistance2d_tolerance(
        lw1: *const LWGEOM,
        lw2: *const LWGEOM,
        tolerance: f64,
    ) -> f64;
}
extern "C" {
    pub fn distance3d_pt_pt(p1: *const POINT3D, p2: *const POINT3D) -> f64;
}
extern "C" {
    pub fn distance3d_pt_seg(p: *const POINT3D, A: *const POINT3D, B: *const POINT3D) -> f64;
}
extern "C" {
    pub fn lwgeom_furthest_line_3d(lw1: *mut LWGEOM, lw2: *mut LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_closest_line_3d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_closest_point_3d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_mindistance3d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_mindistance3d_tolerance(
        lw1: *const LWGEOM,
        lw2: *const LWGEOM,
        tolerance: f64,
    ) -> f64;
}
extern "C" {
    pub fn lwgeom_maxdistance3d(lw1: *const LWGEOM, lw2: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_maxdistance3d_tolerance(
        lw1: *const LWGEOM,
        lw2: *const LWGEOM,
        tolerance: f64,
    ) -> f64;
}
extern "C" {
    pub fn lwgeom_area(geom: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_length(geom: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_length_2d(geom: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_perimeter(geom: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_perimeter_2d(geom: *const LWGEOM) -> f64;
}
extern "C" {
    pub fn lwgeom_dimension(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwline_get_lwpoint(line: *const LWLINE, where_: u32) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwcircstring_get_lwpoint(circ: *const LWCIRCSTRING, where_: u32) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwcompound_get_startpoint(lwcmp: *const LWCOMPOUND) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwcompound_get_endpoint(lwcmp: *const LWCOMPOUND) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwcompound_get_lwpoint(lwcmp: *const LWCOMPOUND, where_: u32) -> *mut LWPOINT;
}
extern "C" {
    pub fn ptarray_length_2d(pts: *const POINTARRAY) -> f64;
}
extern "C" {
    pub fn pt_in_ring_2d(p: *const POINT2D, ring: *const POINTARRAY) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn azimuth_pt_pt(
        p1: *const POINT2D,
        p2: *const POINT2D,
        ret: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwpoint_project_lwpoint(
        lwpoint1: *const LWPOINT,
        lwpoint2: *const LWPOINT,
        distance: f64,
    ) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_project(lwpoint1: *const LWPOINT, distance: f64, azimuth: f64) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_inside_circle(
        p: *const LWPOINT,
        cx: f64,
        cy: f64,
        rad: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_reverse(lwgeom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_summary(
        lwgeom: *const LWGEOM,
        offset: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwpoint_to_latlon(
        p: *const LWPOINT,
        format: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwgeom_startpoint(lwgeom: *const LWGEOM, pt: *mut POINT4D) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn interpolate_point4d(A: *const POINT4D, B: *const POINT4D, I: *mut POINT4D, F: f64);
}
extern "C" {
    #[doc = " Ensure the outer ring is clockwise oriented and all inner rings\n are counter-clockwise."]
    pub fn lwgeom_is_clockwise(lwgeom: *mut LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Simplification"]
    pub fn lwgeom_simplify(
        igeom: *const LWGEOM,
        dist: f64,
        preserve_collapsed: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_remove_repeated_points(in_: *const LWGEOM, tolerance: f64) -> *mut LWGEOM;
}
#[doc = " Snap-to-grid"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct gridspec_t {
    pub ipx: f64,
    pub ipy: f64,
    pub ipz: f64,
    pub ipm: f64,
    pub xsize: f64,
    pub ysize: f64,
    pub zsize: f64,
    pub msize: f64,
}
#[test]
fn bindgen_test_layout_gridspec_t() {
    const UNINIT: ::std::mem::MaybeUninit<gridspec_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<gridspec_t>(),
        64usize,
        concat!("Size of: ", stringify!(gridspec_t))
    );
    assert_eq!(
        ::std::mem::align_of::<gridspec_t>(),
        8usize,
        concat!("Alignment of ", stringify!(gridspec_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipx) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(ipx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(ipy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipz) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(ipz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ipm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(ipm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xsize) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(xsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ysize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(ysize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zsize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(zsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).msize) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gridspec_t),
            "::",
            stringify!(msize)
        )
    );
}
#[doc = " Snap-to-grid"]
pub type gridspec = gridspec_t;
extern "C" {
    pub fn lwgeom_grid(lwgeom: *const LWGEOM, grid: *const gridspec) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_grid_in_place(lwgeom: *mut LWGEOM, grid: *const gridspec);
}
extern "C" {
    #[doc = " READ/WRITE FUNCTIONS\n\n Coordinate writing functions, which will alter the coordinates\n and potentially the structure of the input geometry. When\n called from within PostGIS, the LWGEOM argument should be built\n on top of a gserialized copy, created using\n PG_GETARG_GSERIALIZED_P_COPY()"]
    pub fn lwgeom_reverse_in_place(lwgeom: *mut LWGEOM);
}
extern "C" {
    pub fn lwgeom_force_clockwise(lwgeom: *mut LWGEOM);
}
extern "C" {
    pub fn lwgeom_longitude_shift(lwgeom: *mut LWGEOM);
}
extern "C" {
    pub fn lwgeom_simplify_in_place(
        igeom: *mut LWGEOM,
        dist: f64,
        preserve_collapsed: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_affine(geom: *mut LWGEOM, affine: *const AFFINE);
}
extern "C" {
    pub fn lwgeom_scale(geom: *mut LWGEOM, factors: *const POINT4D);
}
extern "C" {
    pub fn lwgeom_remove_repeated_points_in_place(
        in_: *mut LWGEOM,
        tolerance: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief wrap geometry on given cut x value\n\n For a positive amount, shifts anything that is on the left\n of \"cutx\" to the right by the given amount.\n\n For a negative amount, shifts anything that is on the right\n of \"cutx\" to the left by the given absolute amount.\n\n @param cutx the X value to perform wrapping on\n @param amount shift amount and wrapping direction"]
    pub fn lwgeom_wrapx(lwgeom: *const LWGEOM, cutx: f64, amount: f64) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " @brief Check whether or not a lwgeom is big enough to warrant a bounding box.\n\n Check whether or not a lwgeom is big enough to warrant a bounding box\n when stored in the serialized form on disk. Currently only points are\n considered small enough to not require a bounding box, because the\n index operations can generate a large number of box-retrieval operations\n when scanning keys."]
    pub fn lwgeom_needs_bbox(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Count the total number of vertices in any #LWGEOM."]
    pub fn lwgeom_count_vertices(geom: *const LWGEOM) -> u32;
}
extern "C" {
    #[doc = " Count the total number of rings in any #LWGEOM. Multipolygons\n and other collections get counted, not the same as OGC st_numrings."]
    pub fn lwgeom_count_rings(geom: *const LWGEOM) -> u32;
}
extern "C" {
    #[doc = " Return true or false depending on whether a geometry has\n a valid SRID set."]
    pub fn lwgeom_has_srid(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return true or false depending on whether a geometry is a linear\n feature that closes on itself."]
    pub fn lwgeom_is_closed(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the dimensionality (relating to point/line/poly) of an lwgeom"]
    pub fn lwgeom_dimensionality(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_same(lwgeom1: *const LWGEOM, lwgeom2: *const LWGEOM) -> ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief Clone LWGEOM object. Serialized point lists are not copied.\n\n #GBOX are copied\n\n @see ptarray_clone"]
    pub fn lwgeom_clone(lwgeom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Deep clone an LWGEOM, everything is copied"]
    pub fn lwgeom_clone_deep(lwgeom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn ptarray_clone_deep(ptarray: *const POINTARRAY) -> *mut POINTARRAY;
}
extern "C" {
    pub fn lwpoint_construct(srid: i32, bbox: *mut GBOX, point: *mut POINTARRAY) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwmpoint_construct(srid: i32, pa: *const POINTARRAY) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwline_construct(srid: i32, bbox: *mut GBOX, points: *mut POINTARRAY) -> *mut LWLINE;
}
extern "C" {
    pub fn lwcircstring_construct(
        srid: i32,
        bbox: *mut GBOX,
        points: *mut POINTARRAY,
    ) -> *mut LWCIRCSTRING;
}
extern "C" {
    pub fn lwpoly_construct(
        srid: i32,
        bbox: *mut GBOX,
        nrings: u32,
        points: *mut *mut POINTARRAY,
    ) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwcurvepoly_construct(
        srid: i32,
        bbox: *mut GBOX,
        nrings: u32,
        geoms: *mut *mut LWGEOM,
    ) -> *mut LWCURVEPOLY;
}
extern "C" {
    pub fn lwtriangle_construct(
        srid: i32,
        bbox: *mut GBOX,
        points: *mut POINTARRAY,
    ) -> *mut LWTRIANGLE;
}
extern "C" {
    pub fn lwcollection_construct(
        type_: u8,
        srid: i32,
        bbox: *mut GBOX,
        ngeoms: u32,
        geoms: *mut *mut LWGEOM,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwgeom_construct_empty(
        type_: u8,
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwpoint_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwline_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWLINE;
}
extern "C" {
    pub fn lwpoly_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwcurvepoly_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWCURVEPOLY;
}
extern "C" {
    pub fn lwcircstring_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWCIRCSTRING;
}
extern "C" {
    pub fn lwcompound_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWCOMPOUND;
}
extern "C" {
    pub fn lwtriangle_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWTRIANGLE;
}
extern "C" {
    pub fn lwmpoint_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwmline_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWMLINE;
}
extern "C" {
    pub fn lwmpoly_construct_empty(
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWMPOLY;
}
extern "C" {
    pub fn lwcollection_construct_empty(
        type_: u8,
        srid: i32,
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwpoint_make2d(srid: i32, x: f64, y: f64) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_make3dz(srid: i32, x: f64, y: f64, z: f64) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_make3dm(srid: i32, x: f64, y: f64, m: f64) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_make4d(srid: i32, x: f64, y: f64, z: f64, m: f64) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwpoint_make(
        srid: i32,
        hasz: ::std::os::raw::c_int,
        hasm: ::std::os::raw::c_int,
        p: *const POINT4D,
    ) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwline_from_lwgeom_array(srid: i32, ngeoms: u32, geoms: *mut *mut LWGEOM)
        -> *mut LWLINE;
}
extern "C" {
    pub fn lwline_from_ptarray(srid: i32, npoints: u32, points: *mut *mut LWPOINT) -> *mut LWLINE;
}
extern "C" {
    pub fn lwline_from_lwmpoint(srid: i32, mpoint: *const LWMPOINT) -> *mut LWLINE;
}
extern "C" {
    pub fn lwline_addpoint(line: *mut LWLINE, point: *mut LWPOINT, where_: u32) -> *mut LWLINE;
}
extern "C" {
    pub fn lwline_removepoint(line: *mut LWLINE, which: u32) -> *mut LWLINE;
}
extern "C" {
    pub fn lwline_setPoint4d(line: *mut LWLINE, which: u32, newpoint: *mut POINT4D);
}
extern "C" {
    pub fn lwpoly_from_lwlines(
        shell: *const LWLINE,
        nholes: u32,
        holes: *mut *const LWLINE,
    ) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwpoly_construct_rectangle(
        hasz: ::std::os::raw::c_char,
        hasm: ::std::os::raw::c_char,
        p1: *mut POINT4D,
        p2: *mut POINT4D,
        p3: *mut POINT4D,
        p4: *mut POINT4D,
    ) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwpoly_construct_envelope(srid: i32, x1: f64, y1: f64, x2: f64, y2: f64) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwpoly_construct_circle(
        srid: i32,
        x: f64,
        y: f64,
        radius: f64,
        segments_per_quarter: u32,
        exterior: ::std::os::raw::c_char,
    ) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwtriangle_from_lwline(shell: *const LWLINE) -> *mut LWTRIANGLE;
}
extern "C" {
    pub fn lwmpoint_from_lwgeom(g: *const LWGEOM) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwpoint_get_x(point: *const LWPOINT) -> f64;
}
extern "C" {
    pub fn lwpoint_get_y(point: *const LWPOINT) -> f64;
}
extern "C" {
    pub fn lwpoint_get_z(point: *const LWPOINT) -> f64;
}
extern "C" {
    pub fn lwpoint_get_m(point: *const LWPOINT) -> f64;
}
extern "C" {
    #[doc = " Return SRID number"]
    pub fn lwgeom_get_srid(geom: *const LWGEOM) -> i32;
}
extern "C" {
    #[doc = " Return #LW_TRUE if geometry has Z ordinates"]
    pub fn lwgeom_has_z(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return #LW_TRUE if geometry has M ordinates."]
    pub fn lwgeom_has_m(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return #LW_TRUE if geometry has SOLID flag."]
    pub fn lwgeom_is_solid(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return the number of dimensions (2, 3, 4) in a geometry"]
    pub fn lwgeom_ndims(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_locate_point(
        pa: *const POINTARRAY,
        pt: *const POINT4D,
        dist: *mut f64,
        p_located: *mut POINT4D,
    ) -> f64;
}
extern "C" {
    #[doc = " Add a measure dimension to a line, interpolating linearly from the start\n to the end value."]
    pub fn lwline_measured_from_lwline(
        lwline: *const LWLINE,
        m_start: f64,
        m_end: f64,
    ) -> *mut LWLINE;
}
extern "C" {
    pub fn lwmline_measured_from_lwmline(
        lwmline: *const LWMLINE,
        m_start: f64,
        m_end: f64,
    ) -> *mut LWMLINE;
}
extern "C" {
    #[doc = " Determine the location(s) along a measured line where m occurs and\n return as a multipoint. Offset to left (positive) or right (negative)."]
    pub fn lwgeom_locate_along(lwin: *const LWGEOM, m: f64, offset: f64) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Determine the segments along a measured line that fall within the m-range\n given. Return as a multiline or geometrycollection.\n Offset to left (positive) or right (negative)."]
    pub fn lwgeom_locate_between(
        lwin: *const LWGEOM,
        from: f64,
        to: f64,
        offset: f64,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    #[doc = " Find the measure value at the location on the line closest to the point."]
    pub fn lwgeom_interpolate_point(lwin: *const LWGEOM, lwpt: *const LWPOINT) -> f64;
}
extern "C" {
    #[doc = " Find the time of closest point of approach\n\n @param mindist if not null will be set to the minimum distance between\n                the trajectories at the closest point of approach.\n\n @return the time value in which the minimum distance was reached, -1\n         if inputs are invalid (lwerror is called in that case),\n         -2 if the trajectories do not share any point in time."]
    pub fn lwgeom_tcpa(g1: *const LWGEOM, g2: *const LWGEOM, mindist: *mut f64) -> f64;
}
extern "C" {
    #[doc = " Is the closest point of approach within a distance ?\n\n @return LW_TRUE or LW_FALSE"]
    pub fn lwgeom_cpa_within(
        g1: *const LWGEOM,
        g2: *const LWGEOM,
        maxdist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return LW_TRUE or LW_FALSE depending on whether or not a geometry is\n a linestring with measure value growing from start to end vertex"]
    pub fn lwgeom_is_trajectory(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwline_is_trajectory(geom: *const LWLINE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_segmentize2d(line: *const LWGEOM, dist: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn ptarray_segmentize2d(ipa: *const POINTARRAY, dist: f64) -> *mut POINTARRAY;
}
extern "C" {
    pub fn lwline_segmentize2d(line: *const LWLINE, dist: f64) -> *mut LWLINE;
}
extern "C" {
    pub fn lwpoly_segmentize2d(line: *const LWPOLY, dist: f64) -> *mut LWPOLY;
}
extern "C" {
    pub fn lwcollection_segmentize2d(coll: *const LWCOLLECTION, dist: f64) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwpoly_to_points(poly: *const LWPOLY, npoints: u32, seed: i32) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwmpoly_to_points(mpoly: *const LWMPOLY, npoints: u32, seed: i32) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwgeom_to_points(lwgeom: *const LWGEOM, npoints: u32, seed: i32) -> *mut LWMPOINT;
}
extern "C" {
    pub fn lwgeom_median(
        g: *const LWGEOM,
        tol: f64,
        maxiter: u32,
        fail_if_not_converged: ::std::os::raw::c_char,
    ) -> *mut LWPOINT;
}
extern "C" {
    pub fn lwmpoint_median(
        g: *const LWMPOINT,
        tol: f64,
        maxiter: u32,
        fail_if_not_converged: ::std::os::raw::c_char,
    ) -> *mut LWPOINT;
}
extern "C" {
    #[doc = " Calculate the GeoHash (http://geohash.org) string for a geometry. Caller must free."]
    pub fn lwgeom_geohash(
        lwgeom: *const LWGEOM,
        precision: ::std::os::raw::c_int,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn geohash_point_as_int(pt: *mut POINT2D) -> ::std::os::raw::c_uint;
}
pub const CG_LINE_CROSS_TYPE_LINE_NO_CROSS: CG_LINE_CROSS_TYPE = 0;
pub const CG_LINE_CROSS_TYPE_LINE_CROSS_LEFT: CG_LINE_CROSS_TYPE = -1;
pub const CG_LINE_CROSS_TYPE_LINE_CROSS_RIGHT: CG_LINE_CROSS_TYPE = 1;
pub const CG_LINE_CROSS_TYPE_LINE_MULTICROSS_END_LEFT: CG_LINE_CROSS_TYPE = -2;
pub const CG_LINE_CROSS_TYPE_LINE_MULTICROSS_END_RIGHT: CG_LINE_CROSS_TYPE = 2;
pub const CG_LINE_CROSS_TYPE_LINE_MULTICROSS_END_SAME_FIRST_LEFT: CG_LINE_CROSS_TYPE = -3;
pub const CG_LINE_CROSS_TYPE_LINE_MULTICROSS_END_SAME_FIRST_RIGHT: CG_LINE_CROSS_TYPE = 3;
#[doc = " The return values of lwline_crossing_direction()"]
pub type CG_LINE_CROSS_TYPE = ::std::os::raw::c_int;
extern "C" {
    #[doc = " Given two lines, characterize how (and if) they cross each other"]
    pub fn lwline_crossing_direction(l1: *const LWLINE, l2: *const LWLINE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Given a geometry clip  based on the from/to range of one of its ordinates (x, y, z, m). Use for m- and z- clipping."]
    pub fn lwgeom_clip_to_ordinate_range(
        lwin: *const LWGEOM,
        ordinate: ::std::os::raw::c_char,
        from: f64,
        to: f64,
        offset: f64,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwgeom_to_gml2(
        geom: *const LWGEOM,
        srs: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_extent_to_gml2(
        geom: *const LWGEOM,
        srs: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " @param opts output options bitfield, see LW_GML macros for meaning"]
    pub fn lwgeom_extent_to_gml3(
        geom: *const LWGEOM,
        srs: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        opts: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_gml3(
        geom: *const LWGEOM,
        srs: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        opts: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
        id: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_kml2(
        geom: *const LWGEOM,
        precision: ::std::os::raw::c_int,
        prefix: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_geojson(
        geo: *const LWGEOM,
        srs: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
        has_bbox: ::std::os::raw::c_int,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_x3d3(
        geom: *const LWGEOM,
        precision: ::std::os::raw::c_int,
        opts: ::std::os::raw::c_int,
        defid: *const ::std::os::raw::c_char,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_svg(
        geom: *const LWGEOM,
        precision: ::std::os::raw::c_int,
        relative: ::std::os::raw::c_int,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_encoded_polyline(
        geom: *const LWGEOM,
        precision: ::std::os::raw::c_int,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " Create an LWGEOM object from a GeoJSON representation\n\n @param geojson the GeoJSON input\n @param srs output parameter. Will be set to a newly allocated\n            string holding the spatial reference string, or NULL\n            if no such parameter is found in input.\n            If not null, the pointer must be freed with lwfree."]
    pub fn lwgeom_from_geojson(
        geojson: *const ::std::os::raw::c_char,
        srs: *mut *mut ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Create an LWGEOM object from an Encoded Polyline representation\n\n @param encodedpolyline the Encoded Polyline input"]
    pub fn lwgeom_from_encoded_polyline(
        encodedpolyline: *const ::std::os::raw::c_char,
        precision: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Initialize a spheroid object for use in geodetic functions."]
    pub fn spheroid_init(s: *mut SPHEROID, a: f64, b: f64);
}
extern "C" {
    #[doc = " Calculate the geodetic distance from lwgeom1 to lwgeom2 on the spheroid.\n A spheroid with major axis == minor axis will be treated as a sphere.\n Pass in a tolerance in spheroid units."]
    pub fn lwgeom_distance_spheroid(
        lwgeom1: *const LWGEOM,
        lwgeom2: *const LWGEOM,
        spheroid: *const SPHEROID,
        tolerance: f64,
    ) -> f64;
}
extern "C" {
    #[doc = " Calculate the location of a point on a spheroid, give a start point, bearing and distance."]
    pub fn lwgeom_project_spheroid(
        r: *const LWPOINT,
        spheroid: *const SPHEROID,
        distance: f64,
        azimuth: f64,
    ) -> *mut LWPOINT;
}
extern "C" {
    #[doc = " Calculate the location of a point on a spheroid, give a start point, end point and distance."]
    pub fn lwgeom_project_spheroid_lwpoint(
        from: *const LWPOINT,
        to: *const LWPOINT,
        spheroid: *const SPHEROID,
        distance: f64,
    ) -> *mut LWPOINT;
}
extern "C" {
    #[doc = " Derive a new geometry with vertices added to ensure no vertex is more\n than max_seg_length (in radians) from any other vertex."]
    pub fn lwgeom_segmentize_sphere(lwg_in: *const LWGEOM, max_seg_length: f64) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Calculate the bearing between two points on a spheroid."]
    pub fn lwgeom_azumith_spheroid(
        r: *const LWPOINT,
        s: *const LWPOINT,
        spheroid: *const SPHEROID,
    ) -> f64;
}
extern "C" {
    #[doc = " Calculate the geodetic area of a lwgeom on the sphere. The result\n will be multiplied by the average radius of the supplied spheroid."]
    pub fn lwgeom_area_sphere(lwgeom: *const LWGEOM, spheroid: *const SPHEROID) -> f64;
}
extern "C" {
    #[doc = " Calculate the geodetic area of a lwgeom on the spheroid. The result\n will have the squared units of the spheroid axes."]
    pub fn lwgeom_area_spheroid(lwgeom: *const LWGEOM, spheroid: *const SPHEROID) -> f64;
}
extern "C" {
    #[doc = " Calculate the geodetic length of a lwgeom on the unit sphere. The result\n will have to by multiplied by the real radius to get the real length."]
    pub fn lwgeom_length_spheroid(geom: *const LWGEOM, s: *const SPHEROID) -> f64;
}
extern "C" {
    #[doc = " Calculate covers predicate for two lwgeoms on the sphere. Currently\n only handles point-in-polygon."]
    pub fn lwgeom_covers_lwgeom_sphere(
        lwgeom1: *const LWGEOM,
        lwgeom2: *const LWGEOM,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geography_substring(
        line: *const LWLINE,
        s: *const SPHEROID,
        from: f64,
        to: f64,
        tolerance: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn geography_interpolate_points(
        line: *const LWLINE,
        length_fraction: f64,
        s: *const SPHEROID,
        repeat: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn ptarray_locate_point_spheroid(
        pa: *const POINTARRAY,
        p4d: *const POINT4D,
        s: *const SPHEROID,
        tolerance: f64,
        mindistout: *mut f64,
        proj4d: *mut POINT4D,
    ) -> f64;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWBOUNDINGCIRCLE {
    pub center: *mut POINT2D,
    pub radius: f64,
}
#[test]
fn bindgen_test_layout_LWBOUNDINGCIRCLE() {
    const UNINIT: ::std::mem::MaybeUninit<LWBOUNDINGCIRCLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<LWBOUNDINGCIRCLE>(),
        16usize,
        concat!("Size of: ", stringify!(LWBOUNDINGCIRCLE))
    );
    assert_eq!(
        ::std::mem::align_of::<LWBOUNDINGCIRCLE>(),
        8usize,
        concat!("Alignment of ", stringify!(LWBOUNDINGCIRCLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).center) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(LWBOUNDINGCIRCLE),
            "::",
            stringify!(center)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(LWBOUNDINGCIRCLE),
            "::",
            stringify!(radius)
        )
    );
}
extern "C" {
    pub fn lwboundingcircle_destroy(c: *mut LWBOUNDINGCIRCLE);
}
extern "C" {
    pub fn lwgeom_calculate_mbc(g: *const LWGEOM) -> *mut LWBOUNDINGCIRCLE;
}
extern "C" {
    #[doc = " Swap ordinate values in every vertex of the geometry.\n\n Ordinates to swap are specified using an index with meaning:\n 0=x, 1=y, 2=z, 3=m\n\n Swapping an existing ordinate with an unexisting one results\n in undefined value being written in the existing ordinate.\n Caller should verify and prevent such calls.\n\n Availability: 2.2.0"]
    pub fn lwgeom_swap_ordinates(in_: *mut LWGEOM, o1: LWORD, o2: LWORD);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LWPOINTITERATOR {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a new LWPOINTITERATOR over supplied LWGEOM*"]
    pub fn lwpointiterator_create(g: *const LWGEOM) -> *mut LWPOINTITERATOR;
}
extern "C" {
    #[doc = " Create a new LWPOINTITERATOR over supplied LWGEOM*\n Supports modification of coordinates during iteration."]
    pub fn lwpointiterator_create_rw(g: *mut LWGEOM) -> *mut LWPOINTITERATOR;
}
extern "C" {
    #[doc = " Free all memory associated with the iterator"]
    pub fn lwpointiterator_destroy(s: *mut LWPOINTITERATOR);
}
extern "C" {
    #[doc = " Returns LW_TRUE if there is another point available in the iterator."]
    pub fn lwpointiterator_has_next(s: *mut LWPOINTITERATOR) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to replace the next point int the iterator with p, and advances\n the iterator to the next point.\n Returns LW_SUCCESS if the assignment was successful, LW_FAILURE otherwise."]
    pub fn lwpointiterator_modify_next(
        s: *mut LWPOINTITERATOR,
        p: *const POINT4D,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to assign the next point in the iterator to p, and advances\n the iterator to the next point.  If p is NULL, the iterator will be\n advanced without reading a point.\n Returns LW_SUCCESS if the assignment was successful, LW_FAILURE otherwise."]
    pub fn lwpointiterator_next(s: *mut LWPOINTITERATOR, p: *mut POINT4D) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Attempts to assigns the next point in the iterator to p.  Does not advance.\n Returns LW_SUCCESS if the assignment was successful, LW_FAILURE otherwise."]
    pub fn lwpointiterator_peek(s: *mut LWPOINTITERATOR, p: *mut POINT4D) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert a single hex digit into the corresponding char"]
    pub fn parse_hex(str_: *mut ::std::os::raw::c_char) -> u8;
}
extern "C" {
    #[doc = " Convert a char into a human readable hex digit"]
    pub fn deparse_hex(str_: u8, result: *mut ::std::os::raw::c_char);
}
extern "C" {
    #[doc = " Check that coordinates of LWGEOM are all within the geodetic range (-180, -90, 180, 90)"]
    pub fn lwgeom_check_geodetic(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gently move coordinates of LWGEOM if they are close enough into geodetic range."]
    pub fn lwgeom_nudge_geodetic(geom: *mut LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Force coordinates of LWGEOM into geodetic range (-180, -90, 180, 90)"]
    pub fn lwgeom_force_geodetic(geom: *mut LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Set the FLAGS geodetic bit on geometry an all sub-geometries and pointlists"]
    pub fn lwgeom_set_geodetic(geom: *mut LWGEOM, value: ::std::os::raw::c_int);
}
extern "C" {
    #[doc = " Calculate the geodetic bounding box for an LWGEOM. Z/M coordinates are\n ignored for this calculation. Pass in non-null, geodetic bounding box for function\n to fill out. LWGEOM must have been built from a GSERIALIZED to provide\n double aligned point arrays."]
    pub fn lwgeom_calculate_gbox_geodetic(
        geom: *const LWGEOM,
        gbox: *mut GBOX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate the 2-4D bounding box of a geometry. Z/M coordinates are honored\n for this calculation, though for curves they are not included in calculations\n of curvature."]
    pub fn lwgeom_calculate_gbox_cartesian(
        lwgeom: *const LWGEOM,
        gbox: *mut GBOX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate bounding box of a geometry, automatically taking into account\n whether it is cartesian or geodetic."]
    pub fn lwgeom_calculate_gbox(lwgeom: *const LWGEOM, gbox: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate geodetic (x/y/z) box and add values to gbox. Return #LW_SUCCESS on success."]
    pub fn ptarray_calculate_gbox_geodetic(
        pa: *const POINTARRAY,
        gbox: *mut GBOX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate box (x/y) and add values to gbox. Return #LW_SUCCESS on success."]
    pub fn ptarray_calculate_gbox_cartesian(
        pa: *const POINTARRAY,
        gbox: *mut GBOX,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Calculate a spherical point that falls outside the geocentric gbox"]
    pub fn gbox_pt_outside(gbox: *const GBOX, pt_outside: *mut POINT2D) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Create a new gbox with the dimensionality indicated by the flags. Caller\n is responsible for freeing."]
    pub fn gbox_new(flags: lwflags_t) -> *mut GBOX;
}
extern "C" {
    #[doc = " Zero out all the entries in the #GBOX. Useful for cleaning\n statically allocated gboxes."]
    pub fn gbox_init(gbox: *mut GBOX);
}
extern "C" {
    #[doc = " Update the merged #GBOX to be large enough to include itself and the new box."]
    pub fn gbox_merge(new_box: *const GBOX, merged_box: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update the output #GBOX to be large enough to include both inputs."]
    pub fn gbox_union(g1: *const GBOX, g2: *const GBOX, gout: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Move the box minimums down and the maximums up by the distance provided."]
    pub fn gbox_expand(g: *mut GBOX, d: f64);
}
extern "C" {
    #[doc = " Move the box minimums down and the maximums up by the distances provided."]
    pub fn gbox_expand_xyzm(g: *mut GBOX, dx: f64, dy: f64, dz: f64, dm: f64);
}
extern "C" {
    #[doc = " Initialize a #GBOX using the values of the point."]
    pub fn gbox_init_point3d(p: *const POINT3D, gbox: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Update the #GBOX to be large enough to include itself and the new point."]
    pub fn gbox_merge_point3d(p: *const POINT3D, gbox: *mut GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return true if the point is inside the gbox"]
    pub fn gbox_contains_point3d(gbox: *const GBOX, pt: *const POINT3D) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a string representation of the #GBOX, based on dimensionality of flags."]
    pub fn gbox_to_string(gbox: *const GBOX) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Return a copy of the #GBOX, based on dimensionality of flags."]
    pub fn gbox_copy(gbox: *const GBOX) -> *mut GBOX;
}
extern "C" {
    #[doc = " Warning, do not use this function, it is very particular about inputs."]
    pub fn gbox_from_string(str_: *const ::std::os::raw::c_char) -> *mut GBOX;
}
extern "C" {
    #[doc = " Return #LW_TRUE if the #GBOX overlaps, #LW_FALSE otherwise."]
    pub fn gbox_overlaps(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return #LW_TRUE if the #GBOX overlaps on the 2d plane, #LW_FALSE otherwise."]
    pub fn gbox_overlaps_2d(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return #LW_TRUE if the first #GBOX contains the second on the 2d plane, #LW_FALSE otherwise."]
    pub fn gbox_contains_2d(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Copy the values of original #GBOX into duplicate."]
    pub fn gbox_duplicate(original: *const GBOX, duplicate: *mut GBOX);
}
extern "C" {
    #[doc = " Return the number of bytes necessary to hold a #GBOX of this dimension in\n serialized form."]
    pub fn gbox_serialized_size(flags: lwflags_t) -> usize;
}
extern "C" {
    #[doc = " Check if 2 given Gbox are the same"]
    pub fn gbox_same(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if 2 given GBOX are the same in x and y"]
    pub fn gbox_same_2d(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Check if two given GBOX are the same in x and y, or would round to the same\n GBOX in x and if serialized in GSERIALIZED"]
    pub fn gbox_same_2d_float(g1: *const GBOX, g2: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Round given GBOX to float boundaries\n\n This turns a GBOX into the version it would become\n after a serialize/deserialize round trip."]
    pub fn gbox_float_round(gbox: *mut GBOX);
}
extern "C" {
    #[doc = " Return false if any of the dimensions is NaN or infinite"]
    pub fn gbox_is_valid(gbox: *const GBOX) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a sortable key based on the center point of the GBOX."]
    pub fn gbox_get_sortable_hash(g: *const GBOX, srid: i32) -> u64;
}
extern "C" {
    #[doc = " Return a sortable key based on gserialized."]
    pub fn gserialized_get_sortable_hash(g: *const GSERIALIZED) -> u64;
}
extern "C" {
    #[doc = " Utility function to get type number from string. For example, a string 'POINTZ'\n would return type of 1 and z of 1 and m of 0. Valid"]
    pub fn geometry_type_from_string(
        str_: *const ::std::os::raw::c_char,
        type_: *mut u8,
        z: *mut ::std::os::raw::c_int,
        m: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Parser result structure: returns the result of attempting to convert\n (E)WKT/(E)WKB to LWGEOM"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct struct_lwgeom_parser_result {
    pub wkinput: *const ::std::os::raw::c_char,
    pub serialized_lwgeom: *mut u8,
    pub size: usize,
    pub geom: *mut LWGEOM,
    pub message: *const ::std::os::raw::c_char,
    pub errcode: ::std::os::raw::c_int,
    pub errlocation: ::std::os::raw::c_int,
    pub parser_check_flags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_struct_lwgeom_parser_result() {
    const UNINIT: ::std::mem::MaybeUninit<struct_lwgeom_parser_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<struct_lwgeom_parser_result>(),
        56usize,
        concat!("Size of: ", stringify!(struct_lwgeom_parser_result))
    );
    assert_eq!(
        ::std::mem::align_of::<struct_lwgeom_parser_result>(),
        8usize,
        concat!("Alignment of ", stringify!(struct_lwgeom_parser_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wkinput) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(wkinput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialized_lwgeom) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(serialized_lwgeom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).geom) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(geom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errcode) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(errcode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errlocation) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(errlocation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).parser_check_flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_parser_result),
            "::",
            stringify!(parser_check_flags)
        )
    );
}
#[doc = " Parser result structure: returns the result of attempting to convert\n (E)WKT/(E)WKB to LWGEOM"]
pub type LWGEOM_PARSER_RESULT = struct_lwgeom_parser_result;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct struct_lwgeom_unparser_result {
    pub serialized_lwgeom: *mut u8,
    pub wkoutput: *mut ::std::os::raw::c_char,
    pub size: usize,
    pub message: *const ::std::os::raw::c_char,
    pub errlocation: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_struct_lwgeom_unparser_result() {
    const UNINIT: ::std::mem::MaybeUninit<struct_lwgeom_unparser_result> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<struct_lwgeom_unparser_result>(),
        40usize,
        concat!("Size of: ", stringify!(struct_lwgeom_unparser_result))
    );
    assert_eq!(
        ::std::mem::align_of::<struct_lwgeom_unparser_result>(),
        8usize,
        concat!("Alignment of ", stringify!(struct_lwgeom_unparser_result))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serialized_lwgeom) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_unparser_result),
            "::",
            stringify!(serialized_lwgeom)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wkoutput) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_unparser_result),
            "::",
            stringify!(wkoutput)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_unparser_result),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).message) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_unparser_result),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).errlocation) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(struct_lwgeom_unparser_result),
            "::",
            stringify!(errlocation)
        )
    );
}
pub type LWGEOM_UNPARSER_RESULT = struct_lwgeom_unparser_result;
extern "C" {
    #[doc = " @param geom geometry to convert to WKT\n @param variant output format to use (WKT_ISO, WKT_SFSQL, WKT_EXTENDED)\n @param precision Double precision\n @param size_out (Out parameter) size of the buffer"]
    pub fn lwgeom_to_wkt(
        geom: *const LWGEOM,
        variant: u8,
        precision: ::std::os::raw::c_int,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param geom geometry to convert to WKT\n @param variant output format to use (WKT_ISO, WKT_SFSQL, WKT_EXTENDED)\n @param precision Double precision"]
    pub fn lwgeom_to_wkt_varlena(
        geom: *const LWGEOM,
        variant: u8,
        precision: ::std::os::raw::c_int,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " @param geom geometry to convert to WKB\n @param variant output format to use\n                (WKB_ISO, WKB_SFSQL, WKB_EXTENDED, WKB_NDR, WKB_XDR)"]
    pub fn lwgeom_to_wkb_buffer(geom: *const LWGEOM, variant: u8) -> *mut u8;
}
extern "C" {
    pub fn lwgeom_to_wkb_varlena(geom: *const LWGEOM, variant: u8) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " @param geom geometry to convert to HEXWKB\n @param variant output format to use\n                (WKB_ISO, WKB_SFSQL, WKB_EXTENDED, WKB_NDR, WKB_XDR)\n @param size_out (Out parameter) size of the buffer"]
    pub fn lwgeom_to_hexwkb_buffer(geom: *const LWGEOM, variant: u8)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwgeom_to_hexwkb_varlena(geom: *const LWGEOM, variant: u8) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " @param lwgeom geometry to convert to EWKT"]
    pub fn lwgeom_to_ewkt(lwgeom: *const LWGEOM) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param wkb_size length of WKB byte buffer\n @param wkb WKB byte buffer\n @param check parser check flags, see LW_PARSER_CHECK_* macros"]
    pub fn lwgeom_from_wkb(
        wkb: *const u8,
        wkb_size: usize,
        check: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " @param wkt WKT string\n @param check parser check flags, see LW_PARSER_CHECK_* macros"]
    pub fn lwgeom_from_wkt(
        wkt: *const ::std::os::raw::c_char,
        check: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " @param check parser check flags, see LW_PARSER_CHECK_* macros"]
    pub fn lwgeom_from_hexwkb(
        hexwkb: *const ::std::os::raw::c_char,
        check: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn bytes_from_hexbytes(hexbuf: *const ::std::os::raw::c_char, hexsize: usize) -> *mut u8;
}
extern "C" {
    pub fn hexbytes_from_bytes(bytes: *const u8, size: usize) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwgeom_parse_wkt(
        parser_result: *mut LWGEOM_PARSER_RESULT,
        wktstr: *mut ::std::os::raw::c_char,
        parse_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lwgeom_parser_result_init(parser_result: *mut LWGEOM_PARSER_RESULT);
}
extern "C" {
    pub fn lwgeom_parser_result_free(parser_result: *mut LWGEOM_PARSER_RESULT);
}
extern "C" {
    pub fn lwalloc(size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lwrealloc(mem: *mut ::std::os::raw::c_void, size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lwfree(mem: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn lwmessage_truncate(
        str_: *mut ::std::os::raw::c_char,
        startpos: ::std::os::raw::c_int,
        endpos: ::std::os::raw::c_int,
        maxlength: ::std::os::raw::c_int,
        truncdirection: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @param twkb Input twkb buffer\n @param twkb_size parser check flags, see LW_PARSER_CHECK_* macros\n @param check parser check flags, see LW_PARSER_CHECK_* macros"]
    pub fn lwgeom_from_twkb(
        twkb: *const u8,
        twkb_size: usize,
        check: ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " @param geom input geometry\n @param variant what variations on TWKB are requested?\n @param twkb_size returns the length of the output TWKB in bytes if set"]
    pub fn lwgeom_to_twkb(
        geom: *const LWGEOM,
        variant: u8,
        precision_xy: i8,
        precision_z: i8,
        precision_m: i8,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    pub fn lwgeom_to_twkb_with_idlist(
        geom: *const LWGEOM,
        idlist: *mut i64,
        variant: u8,
        precision_xy: i8,
        precision_z: i8,
        precision_m: i8,
    ) -> *mut lwvarlena_t;
}
extern "C" {
    #[doc = " Trim the bits of an LWGEOM in place, to optimize it for compression.\n Sets all bits to zero that are not required to maintain a specified\n number of digits after the decimal point. Negative precision values\n indicate digits before the decimal point do not need to be preserved.\n\n @param geom input geometry\n @param prec_x precision (digits after decimal point) in x dimension\n @param prec_y precision (digits after decimal point) in y dimension\n @param prec_z precision (digits after decimal point) in z dimension\n @param prec_m precision (digits after decimal point) in m dimension"]
    pub fn lwgeom_trim_bits_in_place(
        geom: *mut LWGEOM,
        prec_x: i32,
        prec_y: i32,
        prec_z: i32,
        prec_m: i32,
    );
}
extern "C" {
    pub fn lwgeom_boundary(lwgeom: *mut LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Geometry includes at least one actual circular arc"]
    pub fn lwgeom_has_arc(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Geometry type is one of the potentially \"arc containing\"\n types (circstring, multicurve, etc) but does not necessarily\n contain an actual arc."]
    pub fn lwgeom_type_arc(geom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Convert type with arcs into equivalent linearized type"]
    pub fn lwgeom_stroke(geom: *const LWGEOM, perQuad: u32) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Convert linearized type into arc type, de-linearizing the\n strokes where possible."]
    pub fn lwgeom_unstroke(geom: *const LWGEOM) -> *mut LWGEOM;
}
#[doc = " Tolerance expresses the number of segments to use\n for each quarter of circle (quadrant). Must be\n an integer."]
pub const LW_LINEARIZE_TOLERANCE_TYPE_LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD:
    LW_LINEARIZE_TOLERANCE_TYPE = 0;
#[doc = " Tolerance expresses the maximum distance between\n an arbitrary point on the curve and the closest\n point to it on the resulting approximation, in\n cartesian units."]
pub const LW_LINEARIZE_TOLERANCE_TYPE_LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION:
    LW_LINEARIZE_TOLERANCE_TYPE = 1;
#[doc = " Tolerance expresses the maximum angle between\n the radii generating approximation line vertices,\n given in radiuses. A value of 1 would result\n in an approximation of a semicircle composed by\n 180 segments"]
pub const LW_LINEARIZE_TOLERANCE_TYPE_LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE:
    LW_LINEARIZE_TOLERANCE_TYPE = 2;
#[doc = " Semantic of the `tolerance` argument passed to\n lwcurve_linearize"]
pub type LW_LINEARIZE_TOLERANCE_TYPE = ::std::os::raw::c_uint;
#[doc = " Symmetric linearization means that the output\n vertices would be the same no matter the order\n of the points defining the input curve."]
pub const LW_LINEARIZE_FLAGS_LW_LINEARIZE_FLAG_SYMMETRIC: LW_LINEARIZE_FLAGS = 1;
#[doc = " Retain angle instructs the engine to try its best\n to retain the requested angle between generating\n radii (where angle can be given explicitly with\n LW_LINEARIZE_TOLERANCE_TYPE_MAX_ANGLE or implicitly\n with LW_LINEARIZE_TOLERANCE_TYPE_SEGS_PER_QUAD or\n LW_LINEARIZE_TOLERANCE_TYPE_MAX_DEVIATION).\n\n It only makes sense with LW_LINEARIZE_FLAG_SYMMETRIC\n which would otherwise reduce the angle as needed to\n keep it constant among all radiis so that all\n segments are of the same length.\n\n When this flag is set, the first and last generating\n angles (and thus the first and last segments) may\n instead be smaller (shorter) than the others.\n"]
pub const LW_LINEARIZE_FLAGS_LW_LINEARIZE_FLAG_RETAIN_ANGLE: LW_LINEARIZE_FLAGS = 2;
pub type LW_LINEARIZE_FLAGS = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " @param geom input geometry\n @param tol tolerance, semantic driven by tolerance_type\n @param type see LW_LINEARIZE_TOLERANCE_TYPE\n @param flags bitwise OR of operational flags, see LW_LINEARIZE_FLAGS\n\n @return a newly allocated LWGEOM"]
    pub fn lwcurve_linearize(
        geom: *const LWGEOM,
        tol: f64,
        type_: LW_LINEARIZE_TOLERANCE_TYPE,
        flags: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Return GEOS version string (not to be freed)"]
    pub fn lwgeom_geos_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn lwgeom_geos_compiled_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Convert an LWGEOM to a GEOS Geometry and convert back -- for debug only"]
    pub fn lwgeom_geos_noop(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_normalize(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_intersection(geom1: *const LWGEOM, geom2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_intersection_prec(
        geom1: *const LWGEOM,
        geom2: *const LWGEOM,
        gridSize: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_difference(geom1: *const LWGEOM, geom2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_difference_prec(
        geom1: *const LWGEOM,
        geom2: *const LWGEOM,
        gridSize: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_symdifference(geom1: *const LWGEOM, geom2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_symdifference_prec(
        geom1: *const LWGEOM,
        geom2: *const LWGEOM,
        gridSize: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_pointonsurface(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_reduceprecision(geom: *const LWGEOM, gridSize: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_centroid(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_union(geom1: *const LWGEOM, geom2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_union_prec(
        geom1: *const LWGEOM,
        geom2: *const LWGEOM,
        gridSize: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_linemerge(geom1: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_linemerge_directed(
        geom1: *const LWGEOM,
        directed: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_unaryunion(geom1: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_unaryunion_prec(geom1: *const LWGEOM, gridSize: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_clip_by_rect(
        geom1: *const LWGEOM,
        x0: f64,
        y0: f64,
        x1: f64,
        y1: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_subdivide(geom: *const LWGEOM, maxvertices: u32) -> *mut LWCOLLECTION;
}
extern "C" {
    pub fn lwgeom_subdivide_prec(
        geom: *const LWGEOM,
        maxvertices: u32,
        gridSize: f64,
    ) -> *mut LWCOLLECTION;
}
extern "C" {
    #[doc = " Snap vertices and segments of a geometry to another using a given tolerance.\n\n @param geom1 the geometry to snap\n @param geom2 the geometry to snap to\n @param tolerance the distance under which vertices and segments are snapped"]
    pub fn lwgeom_snap(geom1: *const LWGEOM, geom2: *const LWGEOM, tolerance: f64) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_sharedpaths(geom1: *const LWGEOM, geom2: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_offsetcurve(
        geom: *const LWGEOM,
        size: f64,
        quadsegs: ::std::os::raw::c_int,
        joinStyle: ::std::os::raw::c_int,
        mitreLimit: f64,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_is_simple(lwgeom: *const LWGEOM) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " PROJ4-dependent extra functions on LWGEOM"]
    pub fn lwgeom_transform_from_str(
        geom: *mut LWGEOM,
        instr: *const ::std::os::raw::c_char,
        outstr: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Transform (reproject) a geometry in-place.\n @param geom the geometry to transform\n @param pj the transformation"]
    pub fn lwgeom_transform(geom: *mut LWGEOM, pj: *mut LWPROJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ptarray_transform(pa: *mut POINTARRAY, pj: *mut LWPROJ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn box3d_transform(box_: *mut GBOX, pj: *mut LWPROJ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new LWPROJ containing the reference to the PROJ's PJ\n If extra_geography_data is true, it will generate the following values for\n the source srs: is_latlong (geometric or not) and spheroid values"]
    pub fn lwproj_from_str(
        str_in: *const ::std::os::raw::c_char,
        str_out: *const ::std::os::raw::c_char,
    ) -> *mut LWPROJ;
}
extern "C" {
    #[doc = " Transform (reproject) a geometry in-place using a PROJ pipeline.\n @param geom the geometry to transform\n @param pipeline the coordinate operation pipeline string. Either:\n        - `urn:ogc:def:coordinateOperation:AUTHORITY::CODE`\n        - a PROJ pipeline string: `+proj=pipeline ...`\n        - concatenated operations: `urn:ogc:def:coordinateOperation,coordinateOperation:EPSG::3895,coordinateOperation:EPSG::1618`\n @param is_forward whether to execute the pipeline in a forward or inverse\n \t\t  direction."]
    pub fn lwgeom_transform_pipeline(
        geom: *mut LWGEOM,
        pipeline: *const ::std::os::raw::c_char,
        is_forward: bool,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Allocate a new LWPROJ containing the reference to the PROJ's PJ using a\n PROJ pipeline definition:\n @param str_pipeline the coordinate operation pipeline string. Either:\n        - `urn:ogc:def:coordinateOperation:AUTHORITY::CODE`\n        - a PROJ pipeline: `+proj=pipeline ...`\n        - concatenated operations: `urn:ogc:def:coordinateOperation,coordinateOperation:EPSG::3895,coordinateOperation:EPSG::1618`\n        - any other coordinate operation accepted via `proj_create()`\n @param is_foward whether to execute the the pipeline in a forward or inverse\n        direction."]
    pub fn lwproj_from_str_pipeline(
        str_pipeline: *const ::std::os::raw::c_char,
        is_forward: bool,
    ) -> *mut LWPROJ;
}
extern "C" {
    #[doc = " Take a geometry and return an areal geometry\n (Polygon or MultiPolygon).\n Actually a wrapper around GEOSpolygonize,\n transforming the resulting collection into\n a valid polygon Geometry."]
    pub fn lwgeom_buildarea(geom: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Attempts to make an invalid geometries valid w/out losing points."]
    pub fn lwgeom_make_valid(geom: *mut LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_make_valid_params(
        geom: *mut LWGEOM,
        make_valid_params: *mut ::std::os::raw::c_char,
    ) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_split(lwgeom_in: *const LWGEOM, blade_in: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    pub fn lwgeom_node(lwgeom_in: *const LWGEOM) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Take vertices of a geometry and build a delaunay\n triangulation on them.\n\n @param geom the input geometry\n @param tolerance an optional snapping tolerance for improved robustness\n @param edgeOnly if non-zero the result will be a MULTILINESTRING,\n                 otherwise it'll be a COLLECTION of polygons."]
    pub fn lwgeom_delaunay_triangulation(
        geom: *const LWGEOM,
        tolerance: f64,
        edgeOnly: i32,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Take vertices of a geometry and build the Voronoi diagram\n\n @param g the input geometry\n @param env an optional envelope for clipping the results\n @param tolerance an optional snapping tolerance for improved robustness\n @param output_edges if non-zero the result will be a MULTILINESTRING,\n                 otherwise it'll be a COLLECTION of polygons."]
    pub fn lwgeom_voronoi_diagram(
        g: *const LWGEOM,
        env: *const GBOX,
        tolerance: f64,
        output_edges: ::std::os::raw::c_int,
    ) -> *mut LWGEOM;
}
extern "C" {
    #[doc = " Take a list of LWGEOMs and a number of clusters and return an integer\n array indicating which cluster each geometry is in.\n\n @param geoms the input array of LWGEOM pointers\n @param ngeoms the number of elements in the array\n @param k the number of clusters to calculate\n @param max_radius maxmimum radius of cluster before it's split"]
    pub fn lwgeom_cluster_kmeans(
        geoms: *mut *const LWGEOM,
        n: u32,
        k: u32,
        max_radius: f64,
    ) -> *mut ::std::os::raw::c_int;
}
pub type Oid = ::std::os::raw::c_uint;
pub type pg_int64 = ::std::os::raw::c_long;
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::std::os::raw::c_uint;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtod(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn strtof(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn strtold(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
    ) -> u128;
}
extern "C" {
    pub fn strtol(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: ::std::os::raw::c_long) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn a64l(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = ::std::os::raw::c_ulong;
pub type ushort = ::std::os::raw::c_ushort;
pub type uint = ::std::os::raw::c_uint;
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    const UNINIT: ::std::mem::MaybeUninit<__sigset_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    const UNINIT: ::std::mem::MaybeUninit<fd_set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_list> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__prev) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_internal_slist> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_mutex_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lock) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__owner) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__nusers) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__kind) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__spins) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__elision) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: ::std::os::raw::c_uint,
    pub __writers: ::std::os::raw::c_uint,
    pub __wrphase_futex: ::std::os::raw::c_uint,
    pub __writers_futex: ::std::os::raw::c_uint,
    pub __pad3: ::std::os::raw::c_uint,
    pub __pad4: ::std::os::raw::c_uint,
    pub __cur_writer: ::std::os::raw::c_int,
    pub __shared: ::std::os::raw::c_int,
    pub __rwelision: ::std::os::raw::c_schar,
    pub __pad1: [::std::os::raw::c_uchar; 7usize],
    pub __pad2: ::std::os::raw::c_ulong,
    pub __flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_rwlock_arch_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__readers) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrphase_futex) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__writers_futex) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad3) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad4) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cur_writer) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__shared) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__rwelision) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad1) as usize - ptr as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wseq32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__low) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__high) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_start32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    const UNINIT: ::std::mem::MaybeUninit<__pthread_cond_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_refs) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g1_orig_size) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wrefs) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__g_signals) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutexattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_condattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_attr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_mutex_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_cond_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [::std::os::raw::c_char; 56usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlock_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_rwlockattr_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrier_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<pthread_barrierattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__align) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srandom(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: ::std::os::raw::c_int,
    pub rand_deg: ::std::os::raw::c_int,
    pub rand_sep: ::std::os::raw::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    const UNINIT: ::std::mem::MaybeUninit<random_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::std::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_type) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_deg) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rand_sep) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srandom_r(
        __seed: ::std::os::raw::c_uint,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: ::std::os::raw::c_uint,
        __statebuf: *mut ::std::os::raw::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut ::std::os::raw::c_char,
        __buf: *mut random_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand(__seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut ::std::os::raw::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn mrand48() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut ::std::os::raw::c_ushort) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn srand48(__seedval: ::std::os::raw::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut ::std::os::raw::c_ushort) -> *mut ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut ::std::os::raw::c_ushort);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct drand48_data {
    pub __x: [::std::os::raw::c_ushort; 3usize],
    pub __old_x: [::std::os::raw::c_ushort; 3usize],
    pub __c: ::std::os::raw::c_ushort,
    pub __init: ::std::os::raw::c_ushort,
    pub __a: ::std::os::raw::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    const UNINIT: ::std::mem::MaybeUninit<drand48_data> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::std::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__old_x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__c) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__init) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__a) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut ::std::os::raw::c_long,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn srand48_r(
        __seedval: ::std::os::raw::c_long,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut ::std::os::raw::c_ushort,
        __buffer: *mut drand48_data,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn alloca(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::std::os::raw::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn atexit(__func: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::std::option::Option<
            unsafe extern "C" fn(
                __status: ::std::os::raw::c_int,
                __arg: *mut ::std::os::raw::c_void,
            ),
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(__status: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn getenv(__name: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const ::std::os::raw::c_char,
        __value: *const ::std::os::raw::c_char,
        __replace: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearenv() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut ::std::os::raw::c_char,
        __suffixlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn system(__command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const ::std::os::raw::c_char,
        __resolved: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
pub type __compar_fn_t = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const ::std::os::raw::c_void,
        __base: *const ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(__x: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(__x: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn div(__numer: ::std::os::raw::c_int, __denom: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: ::std::os::raw::c_long, __denom: ::std::os::raw::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        __numer: ::std::os::raw::c_longlong,
        __denom: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: u128,
        __ndigit: ::std::os::raw::c_int,
        __decpt: *mut ::std::os::raw::c_int,
        __sign: *mut ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(__s: *const ::std::os::raw::c_char, __n: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut ::std::os::raw::c_char, __wchar: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const ::std::os::raw::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut ::std::os::raw::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut ::std::os::raw::c_char,
        __tokens: *const *mut ::std::os::raw::c_char,
        __valuep: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __errno_location() -> *mut ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lconv {
    pub decimal_point: *mut ::std::os::raw::c_char,
    pub thousands_sep: *mut ::std::os::raw::c_char,
    pub grouping: *mut ::std::os::raw::c_char,
    pub int_curr_symbol: *mut ::std::os::raw::c_char,
    pub currency_symbol: *mut ::std::os::raw::c_char,
    pub mon_decimal_point: *mut ::std::os::raw::c_char,
    pub mon_thousands_sep: *mut ::std::os::raw::c_char,
    pub mon_grouping: *mut ::std::os::raw::c_char,
    pub positive_sign: *mut ::std::os::raw::c_char,
    pub negative_sign: *mut ::std::os::raw::c_char,
    pub int_frac_digits: ::std::os::raw::c_char,
    pub frac_digits: ::std::os::raw::c_char,
    pub p_cs_precedes: ::std::os::raw::c_char,
    pub p_sep_by_space: ::std::os::raw::c_char,
    pub n_cs_precedes: ::std::os::raw::c_char,
    pub n_sep_by_space: ::std::os::raw::c_char,
    pub p_sign_posn: ::std::os::raw::c_char,
    pub n_sign_posn: ::std::os::raw::c_char,
    pub int_p_cs_precedes: ::std::os::raw::c_char,
    pub int_p_sep_by_space: ::std::os::raw::c_char,
    pub int_n_cs_precedes: ::std::os::raw::c_char,
    pub int_n_sep_by_space: ::std::os::raw::c_char,
    pub int_p_sign_posn: ::std::os::raw::c_char,
    pub int_n_sign_posn: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_lconv() {
    const UNINIT: ::std::mem::MaybeUninit<lconv> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lconv>(),
        96usize,
        concat!("Size of: ", stringify!(lconv))
    );
    assert_eq!(
        ::std::mem::align_of::<lconv>(),
        8usize,
        concat!("Alignment of ", stringify!(lconv))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decimal_point) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).thousands_sep) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grouping) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_curr_symbol) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_curr_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).currency_symbol) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(currency_symbol)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_decimal_point) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_decimal_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_thousands_sep) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_thousands_sep)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mon_grouping) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(mon_grouping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).positive_sign) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(positive_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).negative_sign) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(negative_sign)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_frac_digits) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frac_digits) as usize - ptr as usize },
        81usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(frac_digits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_cs_precedes) as usize - ptr as usize },
        82usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sep_by_space) as usize - ptr as usize },
        83usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_cs_precedes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sep_by_space) as usize - ptr as usize },
        85usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p_sign_posn) as usize - ptr as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_sign_posn) as usize - ptr as usize },
        87usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(n_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_cs_precedes) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_sep_by_space) as usize - ptr as usize },
        89usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_cs_precedes) as usize - ptr as usize },
        90usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_cs_precedes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_sep_by_space) as usize - ptr as usize },
        91usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sep_by_space)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_p_sign_posn) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_p_sign_posn)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).int_n_sign_posn) as usize - ptr as usize },
        93usize,
        concat!(
            "Offset of field: ",
            stringify!(lconv),
            "::",
            stringify!(int_n_sign_posn)
        )
    );
}
extern "C" {
    pub fn setlocale(
        __category: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn localeconv() -> *mut lconv;
}
extern "C" {
    pub fn newlocale(
        __category_mask: ::std::os::raw::c_int,
        __locale: *const ::std::os::raw::c_char,
        __base: locale_t,
    ) -> locale_t;
}
extern "C" {
    pub fn duplocale(__dataset: locale_t) -> locale_t;
}
extern "C" {
    pub fn freelocale(__dataset: locale_t);
}
extern "C" {
    pub fn uselocale(__dataset: locale_t) -> locale_t;
}
pub type pg_funcptr_t = ::std::option::Option<unsafe extern "C" fn()>;
pub type Pointer = *mut ::std::os::raw::c_char;
pub type int8 = ::std::os::raw::c_schar;
pub type int16 = ::std::os::raw::c_short;
pub type int32 = ::std::os::raw::c_int;
pub type uint8 = ::std::os::raw::c_uchar;
pub type uint16 = ::std::os::raw::c_ushort;
pub type uint32 = ::std::os::raw::c_uint;
pub type bits8 = uint8;
pub type bits16 = uint16;
pub type bits32 = uint32;
pub type int64 = ::std::os::raw::c_long;
pub type uint64 = ::std::os::raw::c_ulong;
pub type int128 = i128;
pub type uint128 = u128;
pub type Size = usize;
pub type Index = ::std::os::raw::c_uint;
pub type Offset = ::std::os::raw::c_int;
pub type float4 = f32;
pub type float8 = f64;
pub type regproc = Oid;
pub type RegProcedure = regproc;
pub type TransactionId = uint32;
pub type LocalTransactionId = uint32;
pub type SubTransactionId = uint32;
pub type MultiXactId = TransactionId;
pub type MultiXactOffset = uint32;
pub type CommandId = uint32;
#[repr(C)]
#[derive(Debug)]
pub struct varlena {
    pub vl_len_: [::std::os::raw::c_char; 4usize],
    pub vl_dat: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varlena() {
    const UNINIT: ::std::mem::MaybeUninit<varlena> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varlena>(),
        4usize,
        concat!("Size of: ", stringify!(varlena))
    );
    assert_eq!(
        ::std::mem::align_of::<varlena>(),
        1usize,
        concat!("Alignment of ", stringify!(varlena))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varlena),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_dat) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varlena),
            "::",
            stringify!(vl_dat)
        )
    );
}
pub type bytea = varlena;
pub type text = varlena;
pub type BpChar = varlena;
pub type VarChar = varlena;
extern "C" {
    pub fn ExceptionalCondition(
        conditionName: *const ::std::os::raw::c_char,
        errorType: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
    ) -> !;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
#[test]
fn bindgen_test_layout_PGAlignedBlock() {
    const UNINIT: ::std::mem::MaybeUninit<PGAlignedBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PGAlignedBlock>(),
        8192usize,
        concat!("Size of: ", stringify!(PGAlignedBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<PGAlignedBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(PGAlignedBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_align_d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(force_align_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_align_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedBlock),
            "::",
            stringify!(force_align_i64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union PGAlignedXLogBlock {
    pub data: [::std::os::raw::c_char; 8192usize],
    pub force_align_d: f64,
    pub force_align_i64: int64,
}
#[test]
fn bindgen_test_layout_PGAlignedXLogBlock() {
    const UNINIT: ::std::mem::MaybeUninit<PGAlignedXLogBlock> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<PGAlignedXLogBlock>(),
        8192usize,
        concat!("Size of: ", stringify!(PGAlignedXLogBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<PGAlignedXLogBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(PGAlignedXLogBlock))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_align_d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(force_align_d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_align_i64) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(PGAlignedXLogBlock),
            "::",
            stringify!(force_align_i64)
        )
    );
}
pub const _ISupper: _bindgen_ty_1 = 256;
pub const _ISlower: _bindgen_ty_1 = 512;
pub const _ISalpha: _bindgen_ty_1 = 1024;
pub const _ISdigit: _bindgen_ty_1 = 2048;
pub const _ISxdigit: _bindgen_ty_1 = 4096;
pub const _ISspace: _bindgen_ty_1 = 8192;
pub const _ISprint: _bindgen_ty_1 = 16384;
pub const _ISgraph: _bindgen_ty_1 = 32768;
pub const _ISblank: _bindgen_ty_1 = 1;
pub const _IScntrl: _bindgen_ty_1 = 2;
pub const _ISpunct: _bindgen_ty_1 = 4;
pub const _ISalnum: _bindgen_ty_1 = 8;
pub type _bindgen_ty_1 = ::std::os::raw::c_uint;
extern "C" {
    pub fn __ctype_b_loc() -> *mut *const ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn isalnum(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toascii(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _toupper(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tolower(arg1: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalnum_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isalpha_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iscntrl_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn islower_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isgraph_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isprint_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ispunct_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isspace_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isupper_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isxdigit_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isblank_l(arg1: ::std::os::raw::c_int, arg2: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tolower_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn toupper_l(__c: ::std::os::raw::c_int, __l: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_strcasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_strncasecmp(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_toupper(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_ascii_tolower(ch: ::std::os::raw::c_uchar) -> ::std::os::raw::c_uchar;
}
extern "C" {
    pub fn pg_qsort(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::std::os::raw::c_void,
                arg2: *const ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_int,
        >,
    );
}
extern "C" {
    pub fn pg_qsort_strcmp(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
pub type qsort_arg_comparator = ::std::option::Option<
    unsafe extern "C" fn(
        a: *const ::std::os::raw::c_void,
        b: *const ::std::os::raw::c_void,
        arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn qsort_arg(
        base: *mut ::std::os::raw::c_void,
        nel: usize,
        elsize: usize,
        cmp: qsort_arg_comparator,
        arg: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_external {
    pub va_rawsize: int32,
    pub va_extinfo: uint32,
    pub va_valueid: Oid,
    pub va_toastrelid: Oid,
}
#[test]
fn bindgen_test_layout_varatt_external() {
    const UNINIT: ::std::mem::MaybeUninit<varatt_external> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varatt_external>(),
        16usize,
        concat!("Size of: ", stringify!(varatt_external))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_external>(),
        4usize,
        concat!("Alignment of ", stringify!(varatt_external))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_rawsize) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_rawsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_extinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_extinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_valueid) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_valueid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_toastrelid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_external),
            "::",
            stringify!(va_toastrelid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_indirect {
    pub pointer: *mut varlena,
}
#[test]
fn bindgen_test_layout_varatt_indirect() {
    const UNINIT: ::std::mem::MaybeUninit<varatt_indirect> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varatt_indirect>(),
        8usize,
        concat!("Size of: ", stringify!(varatt_indirect))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_indirect>(),
        8usize,
        concat!("Alignment of ", stringify!(varatt_indirect))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pointer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_indirect),
            "::",
            stringify!(pointer)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExpandedObjectHeader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct varatt_expanded {
    pub eohptr: *mut ExpandedObjectHeader,
}
#[test]
fn bindgen_test_layout_varatt_expanded() {
    const UNINIT: ::std::mem::MaybeUninit<varatt_expanded> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varatt_expanded>(),
        8usize,
        concat!("Size of: ", stringify!(varatt_expanded))
    );
    assert_eq!(
        ::std::mem::align_of::<varatt_expanded>(),
        8usize,
        concat!("Alignment of ", stringify!(varatt_expanded))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).eohptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varatt_expanded),
            "::",
            stringify!(eohptr)
        )
    );
}
pub const vartag_external_VARTAG_INDIRECT: vartag_external = 1;
pub const vartag_external_VARTAG_EXPANDED_RO: vartag_external = 2;
pub const vartag_external_VARTAG_EXPANDED_RW: vartag_external = 3;
pub const vartag_external_VARTAG_ONDISK: vartag_external = 18;
pub type vartag_external = ::std::os::raw::c_uint;
#[repr(C)]
pub struct varattrib_4b {
    pub va_4byte: __BindgenUnionField<varattrib_4b__bindgen_ty_1>,
    pub va_compressed: __BindgenUnionField<varattrib_4b__bindgen_ty_2>,
    pub bindgen_union_field: [u32; 2usize],
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_4b__bindgen_ty_1 {
    pub va_header: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<varattrib_4b__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(varattrib_4b__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b__bindgen_ty_1),
            "::",
            stringify!(va_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_data) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b__bindgen_ty_1),
            "::",
            stringify!(va_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_4b__bindgen_ty_2 {
    pub va_header: uint32,
    pub va_tcinfo: uint32,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_4b__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<varattrib_4b__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(varattrib_4b__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b__bindgen_ty_2),
            "::",
            stringify!(va_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_tcinfo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b__bindgen_ty_2),
            "::",
            stringify!(va_tcinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_data) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b__bindgen_ty_2),
            "::",
            stringify!(va_data)
        )
    );
}
#[test]
fn bindgen_test_layout_varattrib_4b() {
    const UNINIT: ::std::mem::MaybeUninit<varattrib_4b> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varattrib_4b>(),
        8usize,
        concat!("Size of: ", stringify!(varattrib_4b))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_4b>(),
        4usize,
        concat!("Alignment of ", stringify!(varattrib_4b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_4byte) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b),
            "::",
            stringify!(va_4byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_compressed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_4b),
            "::",
            stringify!(va_compressed)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_1b {
    pub va_header: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b() {
    const UNINIT: ::std::mem::MaybeUninit<varattrib_1b> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varattrib_1b>(),
        1usize,
        concat!("Size of: ", stringify!(varattrib_1b))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_1b>(),
        1usize,
        concat!("Alignment of ", stringify!(varattrib_1b))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_1b),
            "::",
            stringify!(va_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_data) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_1b),
            "::",
            stringify!(va_data)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct varattrib_1b_e {
    pub va_header: uint8,
    pub va_tag: uint8,
    pub va_data: __IncompleteArrayField<::std::os::raw::c_char>,
}
#[test]
fn bindgen_test_layout_varattrib_1b_e() {
    const UNINIT: ::std::mem::MaybeUninit<varattrib_1b_e> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<varattrib_1b_e>(),
        2usize,
        concat!("Size of: ", stringify!(varattrib_1b_e))
    );
    assert_eq!(
        ::std::mem::align_of::<varattrib_1b_e>(),
        1usize,
        concat!("Alignment of ", stringify!(varattrib_1b_e))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_1b_e),
            "::",
            stringify!(va_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_tag) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_1b_e),
            "::",
            stringify!(va_tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).va_data) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(varattrib_1b_e),
            "::",
            stringify!(va_data)
        )
    );
}
pub type Datum = usize;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NullableDatum {
    pub value: Datum,
    pub isnull: bool,
}
#[test]
fn bindgen_test_layout_NullableDatum() {
    const UNINIT: ::std::mem::MaybeUninit<NullableDatum> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<NullableDatum>(),
        16usize,
        concat!("Size of: ", stringify!(NullableDatum))
    );
    assert_eq!(
        ::std::mem::align_of::<NullableDatum>(),
        8usize,
        concat!("Alignment of ", stringify!(NullableDatum))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(NullableDatum),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).isnull) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(NullableDatum),
            "::",
            stringify!(isnull)
        )
    );
}
pub type Timestamp = int64;
pub type fsec_t = int32;
pub type TimestampTz = int64;
pub type TimeOffset = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Interval {
    pub time: TimeOffset,
    pub day: int32,
    pub month: int32,
}
#[test]
fn bindgen_test_layout_Interval() {
    const UNINIT: ::std::mem::MaybeUninit<Interval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Interval>(),
        16usize,
        concat!("Size of: ", stringify!(Interval))
    );
    assert_eq!(
        ::std::mem::align_of::<Interval>(),
        8usize,
        concat!("Alignment of ", stringify!(Interval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).day) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).month) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Interval),
            "::",
            stringify!(month)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn __fpclassify(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbit(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsig(__x: f64, __y: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignaling(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acos(__x: f64) -> f64;
}
extern "C" {
    pub fn __acos(__x: f64) -> f64;
}
extern "C" {
    pub fn asin(__x: f64) -> f64;
}
extern "C" {
    pub fn __asin(__x: f64) -> f64;
}
extern "C" {
    pub fn atan(__x: f64) -> f64;
}
extern "C" {
    pub fn __atan(__x: f64) -> f64;
}
extern "C" {
    pub fn atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn __atan2(__y: f64, __x: f64) -> f64;
}
extern "C" {
    pub fn cos(__x: f64) -> f64;
}
extern "C" {
    pub fn __cos(__x: f64) -> f64;
}
extern "C" {
    pub fn sin(__x: f64) -> f64;
}
extern "C" {
    pub fn __sin(__x: f64) -> f64;
}
extern "C" {
    pub fn tan(__x: f64) -> f64;
}
extern "C" {
    pub fn __tan(__x: f64) -> f64;
}
extern "C" {
    pub fn cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __cosh(__x: f64) -> f64;
}
extern "C" {
    pub fn sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __sinh(__x: f64) -> f64;
}
extern "C" {
    pub fn tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __tanh(__x: f64) -> f64;
}
extern "C" {
    pub fn acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn __acosh(__x: f64) -> f64;
}
extern "C" {
    pub fn asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn __asinh(__x: f64) -> f64;
}
extern "C" {
    pub fn atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn __atanh(__x: f64) -> f64;
}
extern "C" {
    pub fn exp(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp(__x: f64) -> f64;
}
extern "C" {
    pub fn frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __frexp(__x: f64, __exponent: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __ldexp(__x: f64, __exponent: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn log(__x: f64) -> f64;
}
extern "C" {
    pub fn __log(__x: f64) -> f64;
}
extern "C" {
    pub fn log10(__x: f64) -> f64;
}
extern "C" {
    pub fn __log10(__x: f64) -> f64;
}
extern "C" {
    pub fn modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn __modf(__x: f64, __iptr: *mut f64) -> f64;
}
extern "C" {
    pub fn expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn __expm1(__x: f64) -> f64;
}
extern "C" {
    pub fn log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn __log1p(__x: f64) -> f64;
}
extern "C" {
    pub fn logb(__x: f64) -> f64;
}
extern "C" {
    pub fn __logb(__x: f64) -> f64;
}
extern "C" {
    pub fn exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn __exp2(__x: f64) -> f64;
}
extern "C" {
    pub fn log2(__x: f64) -> f64;
}
extern "C" {
    pub fn __log2(__x: f64) -> f64;
}
extern "C" {
    pub fn pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __pow(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __sqrt(__x: f64) -> f64;
}
extern "C" {
    pub fn hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __hypot(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn __cbrt(__x: f64) -> f64;
}
extern "C" {
    pub fn ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn __ceil(__x: f64) -> f64;
}
extern "C" {
    pub fn fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn __fabs(__x: f64) -> f64;
}
extern "C" {
    pub fn floor(__x: f64) -> f64;
}
extern "C" {
    pub fn __floor(__x: f64) -> f64;
}
extern "C" {
    pub fn fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmod(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn isinf(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finite(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __drem(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn significand(__x: f64) -> f64;
}
extern "C" {
    pub fn __significand(__x: f64) -> f64;
}
extern "C" {
    pub fn copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __copysign(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn __nan(__tagb: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn isnan(__value: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j0(arg1: f64) -> f64;
}
extern "C" {
    pub fn j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __j1(arg1: f64) -> f64;
}
extern "C" {
    pub fn jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __jn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y0(arg1: f64) -> f64;
}
extern "C" {
    pub fn y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn __y1(arg1: f64) -> f64;
}
extern "C" {
    pub fn yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn __yn(arg1: ::std::os::raw::c_int, arg2: f64) -> f64;
}
extern "C" {
    pub fn erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erf(arg1: f64) -> f64;
}
extern "C" {
    pub fn erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn __erfc(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __lgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __tgamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn __gamma(arg1: f64) -> f64;
}
extern "C" {
    pub fn lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __lgamma_r(arg1: f64, __signgamp: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn rint(__x: f64) -> f64;
}
extern "C" {
    pub fn __rint(__x: f64) -> f64;
}
extern "C" {
    pub fn nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __nextafter(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn __nexttoward(__x: f64, __y: u128) -> f64;
}
extern "C" {
    pub fn remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __remainder(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __scalbn(__x: f64, __n: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogb(__x: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn __scalbln(__x: f64, __n: ::std::os::raw::c_long) -> f64;
}
extern "C" {
    pub fn nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn __nearbyint(__x: f64) -> f64;
}
extern "C" {
    pub fn round(__x: f64) -> f64;
}
extern "C" {
    pub fn __round(__x: f64) -> f64;
}
extern "C" {
    pub fn trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn __trunc(__x: f64) -> f64;
}
extern "C" {
    pub fn remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn __remquo(__x: f64, __y: f64, __quo: *mut ::std::os::raw::c_int) -> f64;
}
extern "C" {
    pub fn lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrint(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrint(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lround(__x: f64) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llround(__x: f64) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fdim(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmax(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn __fmin(__x: f64, __y: f64) -> f64;
}
extern "C" {
    pub fn fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn __fma(__x: f64, __y: f64, __z: f64) -> f64;
}
extern "C" {
    pub fn scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __scalb(__x: f64, __n: f64) -> f64;
}
extern "C" {
    pub fn __fpclassifyf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigf(__x: f32, __y: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acosf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanf(__x: f32) -> f32;
}
extern "C" {
    pub fn atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn __atan2f(__y: f32, __x: f32) -> f32;
}
extern "C" {
    pub fn cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cosf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanf(__x: f32) -> f32;
}
extern "C" {
    pub fn coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __coshf(__x: f32) -> f32;
}
extern "C" {
    pub fn sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __tanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn __acoshf(__x: f32) -> f32;
}
extern "C" {
    pub fn asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __asinhf(__x: f32) -> f32;
}
extern "C" {
    pub fn atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn __atanhf(__x: f32) -> f32;
}
extern "C" {
    pub fn expf(__x: f32) -> f32;
}
extern "C" {
    pub fn __expf(__x: f32) -> f32;
}
extern "C" {
    pub fn frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __frexpf(__x: f32, __exponent: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __ldexpf(__x: f32, __exponent: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn logf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logf(__x: f32) -> f32;
}
extern "C" {
    pub fn log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log10f(__x: f32) -> f32;
}
extern "C" {
    pub fn modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn __modff(__x: f32, __iptr: *mut f32) -> f32;
}
extern "C" {
    pub fn expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn __expm1f(__x: f32) -> f32;
}
extern "C" {
    pub fn log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn __log1pf(__x: f32) -> f32;
}
extern "C" {
    pub fn logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn __logbf(__x: f32) -> f32;
}
extern "C" {
    pub fn exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __exp2f(__x: f32) -> f32;
}
extern "C" {
    pub fn log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn __log2f(__x: f32) -> f32;
}
extern "C" {
    pub fn powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __powf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __sqrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __hypotf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn __cbrtf(__x: f32) -> f32;
}
extern "C" {
    pub fn ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn __ceilf(__x: f32) -> f32;
}
extern "C" {
    pub fn fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn __fabsf(__x: f32) -> f32;
}
extern "C" {
    pub fn floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn __floorf(__x: f32) -> f32;
}
extern "C" {
    pub fn fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmodf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn isinff(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitef(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __dremf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn __significandf(__x: f32) -> f32;
}
extern "C" {
    pub fn copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __copysignf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn __nanf(__tagb: *const ::std::os::raw::c_char) -> f32;
}
extern "C" {
    pub fn isnanf(__value: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __j1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __jnf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y0f(arg1: f32) -> f32;
}
extern "C" {
    pub fn y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn __y1f(arg1: f32) -> f32;
}
extern "C" {
    pub fn ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn __ynf(arg1: ::std::os::raw::c_int, arg2: f32) -> f32;
}
extern "C" {
    pub fn erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erff(arg1: f32) -> f32;
}
extern "C" {
    pub fn erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __erfcf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __lgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __tgammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn __gammaf(arg1: f32) -> f32;
}
extern "C" {
    pub fn lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __lgammaf_r(arg1: f32, __signgamp: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __rintf(__x: f32) -> f32;
}
extern "C" {
    pub fn nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __nextafterf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn __nexttowardf(__x: f32, __y: u128) -> f32;
}
extern "C" {
    pub fn remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __remainderf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __scalbnf(__x: f32, __n: ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbf(__x: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn __scalblnf(__x: f32, __n: ::std::os::raw::c_long) -> f32;
}
extern "C" {
    pub fn nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn __nearbyintf(__x: f32) -> f32;
}
extern "C" {
    pub fn roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn __roundf(__x: f32) -> f32;
}
extern "C" {
    pub fn truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn __truncf(__x: f32) -> f32;
}
extern "C" {
    pub fn remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn __remquof(__x: f32, __y: f32, __quo: *mut ::std::os::raw::c_int) -> f32;
}
extern "C" {
    pub fn lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundf(__x: f32) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundf(__x: f32) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fdimf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fmaxf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn __fminf(__x: f32, __y: f32) -> f32;
}
extern "C" {
    pub fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn __fmaf(__x: f32, __y: f32, __z: f32) -> f32;
}
extern "C" {
    pub fn scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __scalbf(__x: f32, __n: f32) -> f32;
}
extern "C" {
    pub fn __fpclassifyl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __signbitl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __iseqsigl(__x: u128, __y: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __issignalingl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acosl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanl(__x: u128) -> u128;
}
extern "C" {
    pub fn atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn __atan2l(__y: u128, __x: u128) -> u128;
}
extern "C" {
    pub fn cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cosl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanl(__x: u128) -> u128;
}
extern "C" {
    pub fn coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __coshl(__x: u128) -> u128;
}
extern "C" {
    pub fn sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __tanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn __acoshl(__x: u128) -> u128;
}
extern "C" {
    pub fn asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __asinhl(__x: u128) -> u128;
}
extern "C" {
    pub fn atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn __atanhl(__x: u128) -> u128;
}
extern "C" {
    pub fn expl(__x: u128) -> u128;
}
extern "C" {
    pub fn __expl(__x: u128) -> u128;
}
extern "C" {
    pub fn frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __frexpl(__x: u128, __exponent: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __ldexpl(__x: u128, __exponent: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn logl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logl(__x: u128) -> u128;
}
extern "C" {
    pub fn log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log10l(__x: u128) -> u128;
}
extern "C" {
    pub fn modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn __modfl(__x: u128, __iptr: *mut u128) -> u128;
}
extern "C" {
    pub fn expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn __expm1l(__x: u128) -> u128;
}
extern "C" {
    pub fn log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn __log1pl(__x: u128) -> u128;
}
extern "C" {
    pub fn logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn __logbl(__x: u128) -> u128;
}
extern "C" {
    pub fn exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __exp2l(__x: u128) -> u128;
}
extern "C" {
    pub fn log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn __log2l(__x: u128) -> u128;
}
extern "C" {
    pub fn powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __powl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __sqrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __hypotl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn __cbrtl(__x: u128) -> u128;
}
extern "C" {
    pub fn ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn __ceill(__x: u128) -> u128;
}
extern "C" {
    pub fn fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn __fabsl(__x: u128) -> u128;
}
extern "C" {
    pub fn floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn __floorl(__x: u128) -> u128;
}
extern "C" {
    pub fn fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmodl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn isinfl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn finitel(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __dreml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn __significandl(__x: u128) -> u128;
}
extern "C" {
    pub fn copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __copysignl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn __nanl(__tagb: *const ::std::os::raw::c_char) -> u128;
}
extern "C" {
    pub fn isnanl(__value: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __j1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __jnl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y0l(arg1: u128) -> u128;
}
extern "C" {
    pub fn y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn __y1l(arg1: u128) -> u128;
}
extern "C" {
    pub fn ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn __ynl(arg1: ::std::os::raw::c_int, arg2: u128) -> u128;
}
extern "C" {
    pub fn erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfl(arg1: u128) -> u128;
}
extern "C" {
    pub fn erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn __erfcl(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __lgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __tgammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn __gammal(arg1: u128) -> u128;
}
extern "C" {
    pub fn lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __lgammal_r(arg1: u128, __signgamp: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __rintl(__x: u128) -> u128;
}
extern "C" {
    pub fn nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nextafterl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __nexttowardl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __remainderl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __scalbnl(__x: u128, __n: ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __ilogbl(__x: u128) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn __scalblnl(__x: u128, __n: ::std::os::raw::c_long) -> u128;
}
extern "C" {
    pub fn nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn __nearbyintl(__x: u128) -> u128;
}
extern "C" {
    pub fn roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn __roundl(__x: u128) -> u128;
}
extern "C" {
    pub fn truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn __truncl(__x: u128) -> u128;
}
extern "C" {
    pub fn remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn __remquol(__x: u128, __y: u128, __quo: *mut ::std::os::raw::c_int) -> u128;
}
extern "C" {
    pub fn lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lrintl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llrintl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn __lroundl(__x: u128) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn __llroundl(__x: u128) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fdiml(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fmaxl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn __fminl(__x: u128, __y: u128) -> u128;
}
extern "C" {
    pub fn fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn __fmal(__x: u128, __y: u128, __z: u128) -> u128;
}
extern "C" {
    pub fn scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub fn __scalbl(__x: u128, __n: u128) -> u128;
}
extern "C" {
    pub static mut signgam: ::std::os::raw::c_int;
}
pub type _bindgen_ty_2 = ::std::os::raw::c_uint;
pub type pg_time_t = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_pg_tm() {
    const UNINIT: ::std::mem::MaybeUninit<pg_tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<pg_tm>(),
        56usize,
        concat!("Size of: ", stringify!(pg_tm))
    );
    assert_eq!(
        ::std::mem::align_of::<pg_tm>(),
        8usize,
        concat!("Alignment of ", stringify!(pg_tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_gmtoff) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_zone) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pg_tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tz {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pg_tzenum {
    _unused: [u8; 0],
}
extern "C" {
    pub fn pg_localtime(timep: *const pg_time_t, tz: *const pg_tz) -> *mut pg_tm;
}
extern "C" {
    pub fn pg_gmtime(timep: *const pg_time_t) -> *mut pg_tm;
}
extern "C" {
    pub fn pg_next_dst_boundary(
        timep: *const pg_time_t,
        before_gmtoff: *mut ::std::os::raw::c_long,
        before_isdst: *mut ::std::os::raw::c_int,
        boundary: *mut pg_time_t,
        after_gmtoff: *mut ::std::os::raw::c_long,
        after_isdst: *mut ::std::os::raw::c_int,
        tz: *const pg_tz,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_interpret_timezone_abbrev(
        abbrev: *const ::std::os::raw::c_char,
        timep: *const pg_time_t,
        gmtoff: *mut ::std::os::raw::c_long,
        isdst: *mut ::std::os::raw::c_int,
        tz: *const pg_tz,
    ) -> bool;
}
extern "C" {
    pub fn pg_get_timezone_offset(tz: *const pg_tz, gmtoff: *mut ::std::os::raw::c_long) -> bool;
}
extern "C" {
    pub fn pg_get_timezone_name(tz: *mut pg_tz) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_tz_acceptable(tz: *mut pg_tz) -> bool;
}
extern "C" {
    pub fn pg_strftime(
        s: *mut ::std::os::raw::c_char,
        max: usize,
        format: *const ::std::os::raw::c_char,
        tm: *const pg_tm,
    ) -> usize;
}
extern "C" {
    pub static mut session_timezone: *mut pg_tz;
}
extern "C" {
    pub static mut log_timezone: *mut pg_tz;
}
extern "C" {
    pub fn pg_timezone_initialize();
}
extern "C" {
    pub fn pg_tzset(tzname: *const ::std::os::raw::c_char) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzset_offset(gmtoffset: ::std::os::raw::c_long) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzenumerate_start() -> *mut pg_tzenum;
}
extern "C" {
    pub fn pg_tzenumerate_next(dir: *mut pg_tzenum) -> *mut pg_tz;
}
extern "C" {
    pub fn pg_tzenumerate_end(dir: *mut pg_tzenum);
}
pub type DateADT = int32;
pub type TimeADT = int64;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TimeTzADT {
    pub time: TimeADT,
    pub zone: int32,
}
#[test]
fn bindgen_test_layout_TimeTzADT() {
    const UNINIT: ::std::mem::MaybeUninit<TimeTzADT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TimeTzADT>(),
        16usize,
        concat!("Size of: ", stringify!(TimeTzADT))
    );
    assert_eq!(
        ::std::mem::align_of::<TimeTzADT>(),
        8usize,
        concat!("Alignment of ", stringify!(TimeTzADT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeTzADT),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zone) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TimeTzADT),
            "::",
            stringify!(zone)
        )
    );
}
extern "C" {
    pub fn anytime_typmod_check(istz: bool, typmod: int32) -> int32;
}
extern "C" {
    pub fn date2timestamp_no_overflow(dateVal: DateADT) -> f64;
}
extern "C" {
    pub fn date2timestamp_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::std::os::raw::c_int,
    ) -> Timestamp;
}
extern "C" {
    pub fn date2timestamptz_opt_overflow(
        dateVal: DateADT,
        overflow: *mut ::std::os::raw::c_int,
    ) -> TimestampTz;
}
extern "C" {
    pub fn date_cmp_timestamp_internal(dateVal: DateADT, dt2: Timestamp) -> int32;
}
extern "C" {
    pub fn date_cmp_timestamptz_internal(dateVal: DateADT, dt2: TimestampTz) -> int32;
}
extern "C" {
    pub fn EncodeSpecialDate(dt: DateADT, str_: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn GetSQLCurrentDate() -> DateADT;
}
extern "C" {
    pub fn GetSQLCurrentTime(typmod: int32) -> *mut TimeTzADT;
}
extern "C" {
    pub fn GetSQLLocalTime(typmod: int32) -> TimeADT;
}
extern "C" {
    pub fn interval2tm(span: Interval, tm: *mut pg_tm, fsec: *mut fsec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tm2interval(tm: *mut pg_tm, fsec: fsec_t, span: *mut Interval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn time2tm(time: TimeADT, tm: *mut pg_tm, fsec: *mut fsec_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timetz2tm(
        time: *mut TimeTzADT,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzp: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tm2time(tm: *mut pg_tm, fsec: fsec_t, result: *mut TimeADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tm2timetz(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tz: ::std::os::raw::c_int,
        result: *mut TimeTzADT,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: ::std::os::raw::c_int,
        fsec: fsec_t,
    ) -> bool;
}
extern "C" {
    pub fn float_time_overflows(
        hour: ::std::os::raw::c_int,
        min: ::std::os::raw::c_int,
        sec: f64,
    ) -> bool;
}
extern "C" {
    pub fn AdjustTimeForTypmod(time: *mut TimeADT, typmod: int32);
}
extern "C" {
    pub static mut PgStartTime: TimestampTz;
}
extern "C" {
    pub static mut PgReloadTime: TimestampTz;
}
extern "C" {
    pub fn anytimestamp_typmod_check(istz: bool, typmod: int32) -> int32;
}
extern "C" {
    pub fn GetCurrentTimestamp() -> TimestampTz;
}
extern "C" {
    pub fn GetSQLCurrentTimestamp(typmod: int32) -> TimestampTz;
}
extern "C" {
    pub fn GetSQLLocalTimestamp(typmod: int32) -> Timestamp;
}
extern "C" {
    pub fn TimestampDifference(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        secs: *mut ::std::os::raw::c_long,
        microsecs: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn TimestampDifferenceMilliseconds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn TimestampDifferenceExceeds(
        start_time: TimestampTz,
        stop_time: TimestampTz,
        msec: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn time_t_to_timestamptz(tm: pg_time_t) -> TimestampTz;
}
extern "C" {
    pub fn timestamptz_to_time_t(t: TimestampTz) -> pg_time_t;
}
extern "C" {
    pub fn timestamptz_to_str(t: TimestampTz) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn tm2timestamp(
        tm: *mut pg_tm,
        fsec: fsec_t,
        tzp: *mut ::std::os::raw::c_int,
        dt: *mut Timestamp,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timestamp2tm(
        dt: Timestamp,
        tzp: *mut ::std::os::raw::c_int,
        tm: *mut pg_tm,
        fsec: *mut fsec_t,
        tzn: *mut *const ::std::os::raw::c_char,
        attimezone: *mut pg_tz,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dt2time(
        dt: Timestamp,
        hour: *mut ::std::os::raw::c_int,
        min: *mut ::std::os::raw::c_int,
        sec: *mut ::std::os::raw::c_int,
        fsec: *mut fsec_t,
    );
}
extern "C" {
    pub fn SetEpochTimestamp() -> Timestamp;
}
extern "C" {
    pub fn GetEpochTime(tm: *mut pg_tm);
}
extern "C" {
    pub fn timestamp_cmp_internal(dt1: Timestamp, dt2: Timestamp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timestamp2timestamptz_opt_overflow(
        timestamp: Timestamp,
        overflow: *mut ::std::os::raw::c_int,
    ) -> TimestampTz;
}
extern "C" {
    pub fn timestamp_cmp_timestamptz_internal(timestampVal: Timestamp, dt2: TimestampTz) -> int32;
}
extern "C" {
    pub fn isoweek2j(
        year: ::std::os::raw::c_int,
        week: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isoweek2date(
        woy: ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
        mon: *mut ::std::os::raw::c_int,
        mday: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn isoweekdate2date(
        isoweek: ::std::os::raw::c_int,
        wday: ::std::os::raw::c_int,
        year: *mut ::std::os::raw::c_int,
        mon: *mut ::std::os::raw::c_int,
        mday: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn date2isoweek(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn date2isoyear(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn date2isoyearday(
        year: ::std::os::raw::c_int,
        mon: ::std::os::raw::c_int,
        mday: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TimestampTimestampTzRequiresRewrite() -> bool;
}
#[doc = " Structure to represent sets of values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Set {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Set type"]
    pub settype: uint8,
    #[doc = "< Span basetype"]
    pub basetype: uint8,
    #[doc = "< Flags"]
    pub flags: int16,
    #[doc = "< Number of elements"]
    pub count: int32,
    #[doc = "< Maximum number of elements"]
    pub maxcount: int32,
    #[doc = "< Size of the bouding box"]
    pub bboxsize: int16,
}
#[test]
fn bindgen_test_layout_Set() {
    const UNINIT: ::std::mem::MaybeUninit<Set> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Set>(),
        20usize,
        concat!("Size of: ", stringify!(Set))
    );
    assert_eq!(
        ::std::mem::align_of::<Set>(),
        4usize,
        concat!("Alignment of ", stringify!(Set))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).settype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(settype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Set),
            "::",
            stringify!(bboxsize)
        )
    );
}
#[doc = " Structure to represent spans (a.k.a. ranges)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Span {
    #[doc = "< span type"]
    pub spantype: uint8,
    #[doc = "< span basetype"]
    pub basetype: uint8,
    #[doc = "< lower bound is inclusive (vs exclusive)"]
    pub lower_inc: bool,
    #[doc = "< upper bound is inclusive (vs exclusive)"]
    pub upper_inc: bool,
    #[doc = "< Not used"]
    pub padding: [::std::os::raw::c_char; 4usize],
    #[doc = "< lower bound value"]
    pub lower: Datum,
    #[doc = "< upper bound value"]
    pub upper: Datum,
}
#[test]
fn bindgen_test_layout_Span() {
    const UNINIT: ::std::mem::MaybeUninit<Span> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Span>(),
        24usize,
        concat!("Size of: ", stringify!(Span))
    );
    assert_eq!(
        ::std::mem::align_of::<Span>(),
        8usize,
        concat!("Alignment of ", stringify!(Span))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(spantype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower_inc) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(lower_inc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper_inc) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(upper_inc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lower) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(lower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).upper) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Span),
            "::",
            stringify!(upper)
        )
    );
}
#[doc = " Structure to represent span sets"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SpanSet {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Span set type"]
    pub spansettype: uint8,
    #[doc = "< Span type"]
    pub spantype: uint8,
    #[doc = "< Span basetype"]
    pub basetype: uint8,
    #[doc = "< Not used"]
    pub padding: ::std::os::raw::c_char,
    #[doc = "< Number of elements"]
    pub count: int32,
    #[doc = "< Maximum number of elements"]
    pub maxcount: int32,
    #[doc = "< Bounding span"]
    pub span: Span,
    #[doc = "< Beginning of variable-length data"]
    pub elems: [Span; 1usize],
}
#[test]
fn bindgen_test_layout_SpanSet() {
    const UNINIT: ::std::mem::MaybeUninit<SpanSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SpanSet>(),
        64usize,
        concat!("Size of: ", stringify!(SpanSet))
    );
    assert_eq!(
        ::std::mem::align_of::<SpanSet>(),
        8usize,
        concat!("Alignment of ", stringify!(SpanSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spansettype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(spansettype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spantype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(spantype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).basetype) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(basetype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).span) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(span)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SpanSet),
            "::",
            stringify!(elems)
        )
    );
}
#[doc = " Structure to represent temporal boxes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TBox {
    #[doc = "< time span"]
    pub period: Span,
    #[doc = "< value span"]
    pub span: Span,
    #[doc = "< flags"]
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_TBox() {
    const UNINIT: ::std::mem::MaybeUninit<TBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TBox>(),
        56usize,
        concat!("Size of: ", stringify!(TBox))
    );
    assert_eq!(
        ::std::mem::align_of::<TBox>(),
        8usize,
        concat!("Alignment of ", stringify!(TBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).span) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(span)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TBox),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Structure to represent spatiotemporal boxes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct STBox {
    #[doc = "< time span"]
    pub period: Span,
    #[doc = "< minimum x value"]
    pub xmin: f64,
    #[doc = "< minimum y value"]
    pub ymin: f64,
    #[doc = "< minimum z value"]
    pub zmin: f64,
    #[doc = "< maximum x value"]
    pub xmax: f64,
    #[doc = "< maximum y value"]
    pub ymax: f64,
    #[doc = "< maximum z value"]
    pub zmax: f64,
    #[doc = "< SRID"]
    pub srid: int32,
    #[doc = "< flags"]
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_STBox() {
    const UNINIT: ::std::mem::MaybeUninit<STBox> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<STBox>(),
        80usize,
        concat!("Size of: ", stringify!(STBox))
    );
    assert_eq!(
        ::std::mem::align_of::<STBox>(),
        8usize,
        concat!("Alignment of ", stringify!(STBox))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(period)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmin) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(xmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymin) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(ymin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmin) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(zmin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xmax) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(xmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ymax) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(ymax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).zmax) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(zmax)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).srid) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(srid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(STBox),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = "< Any temporal subtype"]
pub const tempSubtype_ANYTEMPSUBTYPE: tempSubtype = 0;
#[doc = "< Temporal instant subtype"]
pub const tempSubtype_TINSTANT: tempSubtype = 1;
#[doc = "< Temporal sequence subtype"]
pub const tempSubtype_TSEQUENCE: tempSubtype = 2;
#[doc = "< Temporal sequence set subtype"]
pub const tempSubtype_TSEQUENCESET: tempSubtype = 3;
#[doc = " @brief Enumeration that defines the temporal subtypes used in MEOS"]
pub type tempSubtype = ::std::os::raw::c_uint;
pub const interpType_INTERP_NONE: interpType = 0;
pub const interpType_DISCRETE: interpType = 1;
pub const interpType_STEP: interpType = 2;
pub const interpType_LINEAR: interpType = 3;
#[doc = " @brief Enumeration that defines the interpolation types used in MEOS"]
pub type interpType = ::std::os::raw::c_uint;
pub const spatialRel_INTERSECTS: spatialRel = 0;
pub const spatialRel_CONTAINS: spatialRel = 1;
pub const spatialRel_TOUCHES: spatialRel = 2;
pub const spatialRel_COVERS: spatialRel = 3;
#[doc = " @brief Enumeration that defines the spatial relationships for which a call\n to GEOS is made."]
pub type spatialRel = ::std::os::raw::c_uint;
#[doc = " Structure to represent the common structure of temporal values of\n any temporal subtype"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Temporal {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Temporal type"]
    pub temptype: uint8,
    #[doc = "< Temporal subtype"]
    pub subtype: uint8,
    #[doc = "< Flags"]
    pub flags: int16,
}
#[test]
fn bindgen_test_layout_Temporal() {
    const UNINIT: ::std::mem::MaybeUninit<Temporal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Temporal>(),
        8usize,
        concat!("Size of: ", stringify!(Temporal))
    );
    assert_eq!(
        ::std::mem::align_of::<Temporal>(),
        4usize,
        concat!("Alignment of ", stringify!(Temporal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Temporal),
            "::",
            stringify!(flags)
        )
    );
}
#[doc = " Structure to represent temporal values of instant subtype"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TInstant {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Temporal type"]
    pub temptype: uint8,
    #[doc = "< Temporal subtype"]
    pub subtype: uint8,
    #[doc = "< Flags"]
    pub flags: int16,
    #[doc = "< Timestamp (8 bytes)"]
    pub t: TimestampTz,
    #[doc = "< Base value for types passed by value,\nfirst 8 bytes of the base value for values\npassed by reference. The extra bytes\nneeded are added upon creation."]
    pub value: Datum,
}
#[test]
fn bindgen_test_layout_TInstant() {
    const UNINIT: ::std::mem::MaybeUninit<TInstant> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TInstant>(),
        24usize,
        concat!("Size of: ", stringify!(TInstant))
    );
    assert_eq!(
        ::std::mem::align_of::<TInstant>(),
        8usize,
        concat!("Alignment of ", stringify!(TInstant))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TInstant),
            "::",
            stringify!(value)
        )
    );
}
#[doc = " Structure to represent temporal values of instant set or sequence subtype"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSequence {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Temporal type"]
    pub temptype: uint8,
    #[doc = "< Temporal subtype"]
    pub subtype: uint8,
    #[doc = "< Flags"]
    pub flags: int16,
    #[doc = "< Number of TInstant elements"]
    pub count: int32,
    #[doc = "< Maximum number of TInstant elements"]
    pub maxcount: int32,
    #[doc = "< Size of the bounding box"]
    pub bboxsize: int16,
    #[doc = "< Not used"]
    pub padding: [::std::os::raw::c_char; 6usize],
    #[doc = "< Time span (24 bytes). All bounding boxes start\nwith a period so actually it is also the begining\nof the bounding box. The extra bytes needed for\nthe bounding box are added upon creation."]
    pub period: Span,
}
#[test]
fn bindgen_test_layout_TSequence() {
    const UNINIT: ::std::mem::MaybeUninit<TSequence> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSequence>(),
        48usize,
        concat!("Size of: ", stringify!(TSequence))
    );
    assert_eq!(
        ::std::mem::align_of::<TSequence>(),
        8usize,
        concat!("Alignment of ", stringify!(TSequence))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(bboxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequence),
            "::",
            stringify!(period)
        )
    );
}
#[doc = " Structure to represent temporal values of sequence set subtype"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TSequenceSet {
    #[doc = "< Varlena header (do not touch directly!)"]
    pub vl_len_: int32,
    #[doc = "< Temporal type"]
    pub temptype: uint8,
    #[doc = "< Temporal subtype"]
    pub subtype: uint8,
    #[doc = "< Flags"]
    pub flags: int16,
    #[doc = "< Number of TSequence elements"]
    pub count: int32,
    #[doc = "< Total number of TInstant elements in all\ncomposing TSequence elements"]
    pub totalcount: int32,
    #[doc = "< Maximum number of TSequence elements"]
    pub maxcount: int32,
    #[doc = "< Size of the bounding box"]
    pub bboxsize: int16,
    #[doc = "< Not used"]
    pub padding: int16,
    #[doc = "< Time span (24 bytes). All bounding boxes start\nwith a period so actually it is also the begining\nof the bounding box. The extra bytes needed for\nthe bounding box are added upon creation."]
    pub period: Span,
}
#[test]
fn bindgen_test_layout_TSequenceSet() {
    const UNINIT: ::std::mem::MaybeUninit<TSequenceSet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<TSequenceSet>(),
        48usize,
        concat!("Size of: ", stringify!(TSequenceSet))
    );
    assert_eq!(
        ::std::mem::align_of::<TSequenceSet>(),
        8usize,
        concat!("Alignment of ", stringify!(TSequenceSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vl_len_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(vl_len_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temptype) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(temptype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subtype) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(subtype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).count) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).totalcount) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(totalcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).maxcount) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(maxcount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bboxsize) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(bboxsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).padding) as usize - ptr as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).period) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TSequenceSet),
            "::",
            stringify!(period)
        )
    );
}
#[doc = " Struct for storing a similarity match"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Match {
    pub i: ::std::os::raw::c_int,
    pub j: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Match() {
    const UNINIT: ::std::mem::MaybeUninit<Match> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Match>(),
        8usize,
        concat!("Size of: ", stringify!(Match))
    );
    assert_eq!(
        ::std::mem::align_of::<Match>(),
        4usize,
        concat!("Alignment of ", stringify!(Match))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Match), "::", stringify!(i))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).j) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(Match), "::", stringify!(j))
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkipListElem {
    pub value: *mut ::std::os::raw::c_void,
    pub height: ::std::os::raw::c_int,
    pub next: [::std::os::raw::c_int; 32usize],
}
#[test]
fn bindgen_test_layout_SkipListElem() {
    const UNINIT: ::std::mem::MaybeUninit<SkipListElem> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SkipListElem>(),
        144usize,
        concat!("Size of: ", stringify!(SkipListElem))
    );
    assert_eq!(
        ::std::mem::align_of::<SkipListElem>(),
        8usize,
        concat!("Alignment of ", stringify!(SkipListElem))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipListElem),
            "::",
            stringify!(next)
        )
    );
}
#[doc = " Structure to represent skiplists that keep the current state of an aggregation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SkipList {
    pub capacity: ::std::os::raw::c_int,
    pub next: ::std::os::raw::c_int,
    pub length: ::std::os::raw::c_int,
    pub freed: *mut ::std::os::raw::c_int,
    pub freecount: ::std::os::raw::c_int,
    pub freecap: ::std::os::raw::c_int,
    pub tail: ::std::os::raw::c_int,
    pub extra: *mut ::std::os::raw::c_void,
    pub extrasize: usize,
    pub elems: *mut SkipListElem,
}
#[test]
fn bindgen_test_layout_SkipList() {
    const UNINIT: ::std::mem::MaybeUninit<SkipList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<SkipList>(),
        64usize,
        concat!("Size of: ", stringify!(SkipList))
    );
    assert_eq!(
        ::std::mem::align_of::<SkipList>(),
        8usize,
        concat!("Alignment of ", stringify!(SkipList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).capacity) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(capacity)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freed) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freecount) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freecount)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freecap) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(freecap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tail) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(tail)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extra) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).extrasize) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(extrasize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).elems) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SkipList),
            "::",
            stringify!(elems)
        )
    );
}
pub const errorCode_MEOS_SUCCESS: errorCode = 0;
pub const errorCode_MEOS_ERR_INTERNAL_ERROR: errorCode = 1;
pub const errorCode_MEOS_ERR_INTERNAL_TYPE_ERROR: errorCode = 2;
pub const errorCode_MEOS_ERR_VALUE_OUT_OF_RANGE: errorCode = 3;
pub const errorCode_MEOS_ERR_DIVISION_BY_ZERO: errorCode = 4;
pub const errorCode_MEOS_ERR_MEMORY_ALLOC_ERROR: errorCode = 5;
pub const errorCode_MEOS_ERR_AGGREGATION_ERROR: errorCode = 6;
pub const errorCode_MEOS_ERR_DIRECTORY_ERROR: errorCode = 7;
pub const errorCode_MEOS_ERR_FILE_ERROR: errorCode = 8;
pub const errorCode_MEOS_ERR_INVALID_ARG: errorCode = 10;
pub const errorCode_MEOS_ERR_INVALID_ARG_TYPE: errorCode = 11;
pub const errorCode_MEOS_ERR_INVALID_ARG_VALUE: errorCode = 12;
pub const errorCode_MEOS_ERR_MFJSON_INPUT: errorCode = 20;
pub const errorCode_MEOS_ERR_MFJSON_OUTPUT: errorCode = 21;
pub const errorCode_MEOS_ERR_TEXT_INPUT: errorCode = 22;
pub const errorCode_MEOS_ERR_TEXT_OUTPUT: errorCode = 23;
pub const errorCode_MEOS_ERR_WKB_INPUT: errorCode = 24;
pub const errorCode_MEOS_ERR_WKB_OUTPUT: errorCode = 25;
pub const errorCode_MEOS_ERR_GEOJSON_INPUT: errorCode = 26;
pub const errorCode_MEOS_ERR_GEOJSON_OUTPUT: errorCode = 27;
#[doc = " Error codes"]
pub type errorCode = ::std::os::raw::c_uint;
extern "C" {
    pub fn meos_error(
        errlevel: ::std::os::raw::c_int,
        errcode: ::std::os::raw::c_int,
        format: *mut ::std::os::raw::c_char,
        ...
    );
}
extern "C" {
    pub fn meos_errno() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_set(err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_restore(err: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn meos_errno_reset() -> ::std::os::raw::c_int;
}
#[doc = " Initialization of the MEOS library"]
pub type error_handler_fn = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: ::std::os::raw::c_int,
        arg2: ::std::os::raw::c_int,
        arg3: *mut ::std::os::raw::c_char,
    ),
>;
extern "C" {
    pub fn meos_initialize_timezone(name: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn meos_initialize_error_handler(err_handler: error_handler_fn);
}
extern "C" {
    pub fn meos_finalize_timezone();
}
extern "C" {
    pub fn meos_set_datestyle(
        newval: *mut ::std::os::raw::c_char,
        extra: *mut ::std::os::raw::c_void,
    ) -> bool;
}
extern "C" {
    pub fn meos_set_intervalstyle(
        newval: *mut ::std::os::raw::c_char,
        extra: ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn meos_get_datestyle() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn meos_get_intervalstyle() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn meos_initialize(tz_str: *const ::std::os::raw::c_char, err_handler: error_handler_fn);
}
extern "C" {
    pub fn meos_finalize();
}
extern "C" {
    pub fn add_date_int(d: DateADT, days: int32) -> DateADT;
}
extern "C" {
    pub fn add_interval_interval(
        interv1: *const Interval,
        interv2: *const Interval,
    ) -> *mut Interval;
}
extern "C" {
    pub fn add_timestamptz_interval(t: TimestampTz, interv: *const Interval) -> TimestampTz;
}
extern "C" {
    pub fn bool_in(str_: *const ::std::os::raw::c_char) -> bool;
}
extern "C" {
    pub fn bool_out(b: bool) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn cstring2text(str_: *const ::std::os::raw::c_char) -> *mut text;
}
extern "C" {
    pub fn date_to_timestamptz(d: DateADT) -> TimestampTz;
}
extern "C" {
    pub fn minus_date_date(d1: DateADT, d2: DateADT) -> *mut Interval;
}
extern "C" {
    pub fn minus_date_int(d: DateADT, days: int32) -> DateADT;
}
extern "C" {
    pub fn minus_timestamptz_interval(t: TimestampTz, interv: *const Interval) -> TimestampTz;
}
extern "C" {
    pub fn minus_timestamptz_timestamptz(t1: TimestampTz, t2: TimestampTz) -> *mut Interval;
}
extern "C" {
    pub fn mult_interval_double(interv: *const Interval, factor: f64) -> *mut Interval;
}
extern "C" {
    pub fn pg_date_in(str_: *const ::std::os::raw::c_char) -> DateADT;
}
extern "C" {
    pub fn pg_date_out(d: DateADT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_interval_cmp(
        interv1: *const Interval,
        interv2: *const Interval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pg_interval_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> *mut Interval;
}
extern "C" {
    pub fn pg_interval_make(
        years: int32,
        months: int32,
        weeks: int32,
        days: int32,
        hours: int32,
        mins: int32,
        secs: f64,
    ) -> *mut Interval;
}
extern "C" {
    pub fn pg_interval_out(interv: *const Interval) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_time_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> TimeADT;
}
extern "C" {
    pub fn pg_time_out(t: TimeADT) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_timestamp_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> Timestamp;
}
extern "C" {
    pub fn pg_timestamp_out(t: Timestamp) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn pg_timestamptz_in(str_: *const ::std::os::raw::c_char, typmod: int32) -> TimestampTz;
}
extern "C" {
    pub fn pg_timestamptz_out(t: TimestampTz) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text2cstring(txt: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_cmp(txt1: *const text, txt2: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn text_copy(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_initcap(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_lower(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn text_out(txt: *const text) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn text_upper(txt: *const text) -> *mut text;
}
extern "C" {
    pub fn textcat_text_text(txt1: *const text, txt2: *const text) -> *mut text;
}
extern "C" {
    pub fn timestamptz_to_date(t: TimestampTz) -> DateADT;
}
extern "C" {
    pub fn geo_as_ewkb(gs: *const GSERIALIZED, endian: *mut ::std::os::raw::c_char) -> *mut bytea;
}
extern "C" {
    pub fn geo_as_ewkt(
        gs: *const GSERIALIZED,
        precision: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_geojson(
        gs: *const GSERIALIZED,
        option: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
        srs: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_hexewkb(
        gs: *const GSERIALIZED,
        endian: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_as_text(
        gs: *const GSERIALIZED,
        precision: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_from_ewkb(bytea_wkb: *const bytea, srid: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_from_geojson(geojson: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_out(gs: *const GSERIALIZED) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geo_same(gs1: *const GSERIALIZED, gs2: *const GSERIALIZED) -> bool;
}
extern "C" {
    pub fn geography_from_hexewkb(wkt: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geography_from_text(
        wkt: *mut ::std::os::raw::c_char,
        srid: ::std::os::raw::c_int,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geometry_from_hexewkb(wkt: *const ::std::os::raw::c_char) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geometry_from_text(
        wkt: *mut ::std::os::raw::c_char,
        srid: ::std::os::raw::c_int,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn pgis_geography_in(str_: *mut ::std::os::raw::c_char, typmod: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn pgis_geometry_in(str_: *mut ::std::os::raw::c_char, typmod: int32) -> *mut GSERIALIZED;
}
extern "C" {
    #[doc = " Input/output functions for set and span types"]
    pub fn bigintset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn bigintset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bigintspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn bigintspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bigintspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn bigintspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dateset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn dateset_out(s: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn datespan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn datespan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn datespanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn datespanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn floatset_out(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn floatspan_out(
        s: *const Span,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn floatspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_out(
        ss: *const SpanSet,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geogset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn geomset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn geoset_as_ewkt(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geoset_as_text(
        set: *const Set,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn geoset_out(set: *const Set, maxdd: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn intset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn intspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn intspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn intspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn set_as_hexwkb(
        s: *const Set,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn set_as_wkb(s: *const Set, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn set_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn set_from_wkb(wkb: *const u8, size: usize) -> *mut Set;
}
extern "C" {
    pub fn span_as_hexwkb(
        s: *const Span,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn span_as_wkb(s: *const Span, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn span_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn span_from_wkb(wkb: *const u8, size: usize) -> *mut Span;
}
extern "C" {
    pub fn spanset_as_hexwkb(
        ss: *const SpanSet,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn spanset_as_wkb(ss: *const SpanSet, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn spanset_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_from_wkb(wkb: *const u8, size: usize) -> *mut SpanSet;
}
extern "C" {
    pub fn textset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn textset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzset_in(str_: *const ::std::os::raw::c_char) -> *mut Set;
}
extern "C" {
    pub fn tstzset_out(set: *const Set) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzspan_in(str_: *const ::std::os::raw::c_char) -> *mut Span;
}
extern "C" {
    pub fn tstzspan_out(s: *const Span) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tstzspanset_in(str_: *const ::std::os::raw::c_char) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzspanset_out(ss: *const SpanSet) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Constructor functions for set and span types"]
    pub fn bigintset_make(values: *const int64, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn bigintspan_make(
        lower: int64,
        upper: int64,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn dateset_make(values: *const DateADT, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn datespan_make(
        lower: DateADT,
        upper: DateADT,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn floatset_make(values: *const f64, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn floatspan_make(lower: f64, upper: f64, lower_inc: bool, upper_inc: bool) -> *mut Span;
}
extern "C" {
    pub fn geoset_make(values: *mut *const GSERIALIZED, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn intset_make(
        values: *const ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
    ) -> *mut Set;
}
extern "C" {
    pub fn intspan_make(
        lower: ::std::os::raw::c_int,
        upper: ::std::os::raw::c_int,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn set_copy(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn span_copy(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn spanset_copy(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_make(
        spans: *mut Span,
        count: ::std::os::raw::c_int,
        normalize: bool,
        order: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn textset_make(values: *mut *const text, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn tstzset_make(values: *const TimestampTz, count: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_make(
        lower: TimestampTz,
        upper: TimestampTz,
        lower_inc: bool,
        upper_inc: bool,
    ) -> *mut Span;
}
extern "C" {
    #[doc = " Conversion functions for set and span types"]
    pub fn bigint_to_set(i: int64) -> *mut Set;
}
extern "C" {
    pub fn bigint_to_span(i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn bigint_to_spanset(i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn date_to_set(d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn date_to_span(d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn date_to_spanset(d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn dateset_to_tstzset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn datespan_to_tstzspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn datespanset_to_tstzspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn float_to_set(d: f64) -> *mut Set;
}
extern "C" {
    pub fn float_to_span(d: f64) -> *mut Span;
}
extern "C" {
    pub fn float_to_spanset(d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn floatset_to_intset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatspan_to_intspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspanset_to_intspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn geo_to_set(gs: *mut GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn int_to_set(i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn int_to_span(i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn int_to_spanset(i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn intset_to_floatset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intspan_to_floatspan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn intspanset_to_floatspanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn set_to_spanset(s: *const Set) -> *mut SpanSet;
}
extern "C" {
    pub fn span_to_spanset(s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn text_to_set(txt: *mut text) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_to_set(t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_to_span(t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_to_spanset(t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzset_to_dateset(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_to_datespan(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn tstzspanset_to_datespanset(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    #[doc = " Accessor functions for set and span types"]
    pub fn bigintset_end_value(s: *const Set) -> int64;
}
extern "C" {
    pub fn bigintset_start_value(s: *const Set) -> int64;
}
extern "C" {
    pub fn bigintset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut int64) -> bool;
}
extern "C" {
    pub fn bigintset_values(s: *const Set) -> *mut int64;
}
extern "C" {
    pub fn bigintspan_lower(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspan_upper(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspan_width(s: *const Span) -> int64;
}
extern "C" {
    pub fn bigintspanset_lower(ss: *const SpanSet) -> int64;
}
extern "C" {
    pub fn bigintspanset_upper(ss: *const SpanSet) -> int64;
}
extern "C" {
    pub fn bigintspanset_width(ss: *const SpanSet, boundspan: bool) -> int64;
}
extern "C" {
    pub fn dateset_end_value(s: *const Set) -> DateADT;
}
extern "C" {
    pub fn dateset_start_value(s: *const Set) -> DateADT;
}
extern "C" {
    pub fn dateset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut DateADT) -> bool;
}
extern "C" {
    pub fn dateset_values(s: *const Set) -> *mut DateADT;
}
extern "C" {
    pub fn datespan_duration(s: *const Span) -> *mut Interval;
}
extern "C" {
    pub fn datespan_lower(s: *const Span) -> DateADT;
}
extern "C" {
    pub fn datespan_upper(s: *const Span) -> DateADT;
}
extern "C" {
    pub fn datespanset_date_n(
        ss: *const SpanSet,
        n: ::std::os::raw::c_int,
        result: *mut DateADT,
    ) -> bool;
}
extern "C" {
    pub fn datespanset_dates(ss: *const SpanSet) -> *mut Set;
}
extern "C" {
    pub fn datespanset_duration(ss: *const SpanSet, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn datespanset_end_date(ss: *const SpanSet) -> DateADT;
}
extern "C" {
    pub fn datespanset_num_dates(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn datespanset_start_date(ss: *const SpanSet) -> DateADT;
}
extern "C" {
    pub fn floatset_end_value(s: *const Set) -> f64;
}
extern "C" {
    pub fn floatset_start_value(s: *const Set) -> f64;
}
extern "C" {
    pub fn floatset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut f64) -> bool;
}
extern "C" {
    pub fn floatset_values(s: *const Set) -> *mut f64;
}
extern "C" {
    pub fn floatspan_lower(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspan_upper(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspan_width(s: *const Span) -> f64;
}
extern "C" {
    pub fn floatspanset_lower(ss: *const SpanSet) -> f64;
}
extern "C" {
    pub fn floatspanset_upper(ss: *const SpanSet) -> f64;
}
extern "C" {
    pub fn floatspanset_width(ss: *const SpanSet, boundspan: bool) -> f64;
}
extern "C" {
    pub fn geoset_end_value(s: *const Set) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geoset_srid(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn geoset_start_value(s: *const Set) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geoset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn geoset_values(s: *const Set) -> *mut *mut GSERIALIZED;
}
extern "C" {
    pub fn intset_end_value(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intset_start_value(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn intset_values(s: *const Set) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_lower(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_upper(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_width(s: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_lower(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_upper(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspanset_width(ss: *const SpanSet, boundspan: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_hash(s: *const Set) -> uint32;
}
extern "C" {
    pub fn set_hash_extended(s: *const Set, seed: uint64) -> uint64;
}
extern "C" {
    pub fn set_num_values(s: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_to_span(s: *const Set) -> *mut Span;
}
extern "C" {
    pub fn span_hash(s: *const Span) -> uint32;
}
extern "C" {
    pub fn span_hash_extended(s: *const Span, seed: uint64) -> uint64;
}
extern "C" {
    pub fn span_lower_inc(s: *const Span) -> bool;
}
extern "C" {
    pub fn span_upper_inc(s: *const Span) -> bool;
}
extern "C" {
    pub fn spanset_end_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_hash(ss: *const SpanSet) -> uint32;
}
extern "C" {
    pub fn spanset_hash_extended(ss: *const SpanSet, seed: uint64) -> uint64;
}
extern "C" {
    pub fn spanset_lower_inc(ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_num_spans(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spanset_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_span_n(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn spanset_spans(ss: *const SpanSet) -> *mut *mut Span;
}
extern "C" {
    pub fn spanset_start_span(ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_upper_inc(ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn textset_end_value(s: *const Set) -> *mut text;
}
extern "C" {
    pub fn textset_start_value(s: *const Set) -> *mut text;
}
extern "C" {
    pub fn textset_value_n(s: *const Set, n: ::std::os::raw::c_int, result: *mut *mut text)
        -> bool;
}
extern "C" {
    pub fn textset_values(s: *const Set) -> *mut *mut text;
}
extern "C" {
    pub fn tstzset_end_value(s: *const Set) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_start_value(s: *const Set) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_value_n(
        s: *const Set,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn tstzset_values(s: *const Set) -> *mut TimestampTz;
}
extern "C" {
    pub fn tstzspan_duration(s: *const Span) -> *mut Interval;
}
extern "C" {
    pub fn tstzspan_lower(s: *const Span) -> TimestampTz;
}
extern "C" {
    pub fn tstzspan_upper(s: *const Span) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_duration(ss: *const SpanSet, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn tstzspanset_end_timestamptz(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_lower(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_num_timestamps(ss: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tstzspanset_start_timestamptz(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    pub fn tstzspanset_timestamptz_n(
        ss: *const SpanSet,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn tstzspanset_timestamps(ss: *const SpanSet) -> *mut Set;
}
extern "C" {
    pub fn tstzspanset_upper(ss: *const SpanSet) -> TimestampTz;
}
extern "C" {
    #[doc = " Transformation functions for set and span types"]
    pub fn bigintset_shift_scale(
        s: *const Set,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn bigintspan_shift_scale(
        s: *const Span,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn bigintspanset_shift_scale(
        ss: *const SpanSet,
        shift: int64,
        width: int64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn dateset_shift_scale(
        s: *const Set,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn datespan_shift_scale(
        s: *const Span,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn datespanset_shift_scale(
        ss: *const SpanSet,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn floatset_ceil(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_floor(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_degrees(s: *const Set, normalize: bool) -> *mut Set;
}
extern "C" {
    pub fn floatset_radians(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn floatset_round(s: *const Set, maxdd: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn floatset_shift_scale(
        s: *const Set,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn floatspan_ceil(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspan_floor(s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn floatspan_round(s: *const Span, maxdd: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn floatspan_shift_scale(
        s: *const Span,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn floatspanset_ceil(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_floor(ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_round(ss: *const SpanSet, maxdd: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn floatspanset_shift_scale(
        ss: *const SpanSet,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn geoset_round(s: *const Set, maxdd: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn geoset_set_srid(s: *const Set, srid: int32) -> *mut Set;
}
extern "C" {
    pub fn geoset_transform(s: *const Set, srid: int32) -> *mut Set;
}
extern "C" {
    pub fn geoset_transform_pipeline(
        s: *const Set,
        pipelinestr: *mut ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn point_transform(gs: *const GSERIALIZED, srid: int32) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn point_transform_pipeline(
        gs: *const GSERIALIZED,
        pipelinestr: *mut ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn intset_shift_scale(
        s: *const Set,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Set;
}
extern "C" {
    pub fn intspan_shift_scale(
        s: *const Span,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut Span;
}
extern "C" {
    pub fn intspanset_shift_scale(
        ss: *const SpanSet,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn textset_initcap(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textset_lower(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textset_upper(s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn textcat_textset_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn textcat_text_textset(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_tprecision(
        t: TimestampTz,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> TimestampTz;
}
extern "C" {
    pub fn tstzset_shift_scale(
        s: *const Set,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Set;
}
extern "C" {
    pub fn tstzset_tprecision(
        s: *const Set,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut Set;
}
extern "C" {
    pub fn tstzspan_shift_scale(
        s: *const Span,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Span;
}
extern "C" {
    pub fn tstzspan_tprecision(
        s: *const Span,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut Span;
}
extern "C" {
    pub fn tstzspanset_shift_scale(
        ss: *const SpanSet,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut SpanSet;
}
extern "C" {
    pub fn tstzspanset_tprecision(
        ss: *const SpanSet,
        duration: *const Interval,
        torigin: TimestampTz,
    ) -> *mut SpanSet;
}
extern "C" {
    #[doc = " Comparison functions for set and span types"]
    pub fn set_cmp(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn set_eq(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_ge(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_gt(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_le(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_lt(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn set_ne(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn span_cmp(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn span_eq(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_ge(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_gt(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_le(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_lt(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn span_ne(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn spanset_cmp(ss1: *const SpanSet, ss2: *const SpanSet) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn spanset_eq(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_ge(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_gt(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_le(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_lt(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn spanset_ne(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    #[doc = " Bounding box functions for set and span types"]
    pub fn adjacent_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn adjacent_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn adjacent_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn adjacent_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn adjacent_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn adjacent_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_geo_set(gs: *mut GSERIALIZED, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn contained_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn contained_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contained_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn contains_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn contains_set_geo(s: *const Set, gs: *mut GSERIALIZED) -> bool;
}
extern "C" {
    pub fn contains_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn contains_set_text(s: *const Set, t: *mut text) -> bool;
}
extern "C" {
    pub fn contains_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn contains_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn contains_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn contains_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn contains_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn contains_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn contains_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn contains_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn contains_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn contains_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn contains_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overlaps_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overlaps_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overlaps_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn after_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn after_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn after_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn after_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn after_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn after_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn before_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn before_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn before_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn before_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn before_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn before_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn left_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn left_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn left_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn left_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn left_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn left_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn left_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn left_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn left_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn left_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn left_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn left_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overafter_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn overafter_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overbefore_date_set(d: DateADT, s: *const Set) -> bool;
}
extern "C" {
    pub fn overbefore_date_span(d: DateADT, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_date_spanset(d: DateADT, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overbefore_set_date(s: *const Set, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_set_timestamptz(s: *const Set, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_span_date(s: *const Span, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_span_timestamptz(s: *const Span, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_spanset_date(ss: *const SpanSet, d: DateADT) -> bool;
}
extern "C" {
    pub fn overbefore_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_set(t: TimestampTz, s: *const Set) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_span(t: TimestampTz, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overleft_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn overleft_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn overleft_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn overleft_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overleft_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overleft_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn overright_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn overright_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn overright_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn overright_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn overright_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn overright_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn overright_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn overright_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn overright_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn overright_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn overright_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn overright_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_bigint_set(i: int64, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_bigint_span(i: int64, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_bigint_spanset(i: int64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_float_set(d: f64, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_float_span(d: f64, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_float_spanset(d: f64, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_int_set(i: ::std::os::raw::c_int, s: *const Set) -> bool;
}
extern "C" {
    pub fn right_int_span(i: ::std::os::raw::c_int, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_set_bigint(s: *const Set, i: int64) -> bool;
}
extern "C" {
    pub fn right_set_float(s: *const Set, d: f64) -> bool;
}
extern "C" {
    pub fn right_set_int(s: *const Set, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_set_set(s1: *const Set, s2: *const Set) -> bool;
}
extern "C" {
    pub fn right_set_text(s: *const Set, txt: *mut text) -> bool;
}
extern "C" {
    pub fn right_span_bigint(s: *const Span, i: int64) -> bool;
}
extern "C" {
    pub fn right_span_float(s: *const Span, d: f64) -> bool;
}
extern "C" {
    pub fn right_span_int(s: *const Span, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_span_span(s1: *const Span, s2: *const Span) -> bool;
}
extern "C" {
    pub fn right_span_spanset(s: *const Span, ss: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_spanset_bigint(ss: *const SpanSet, i: int64) -> bool;
}
extern "C" {
    pub fn right_spanset_float(ss: *const SpanSet, d: f64) -> bool;
}
extern "C" {
    pub fn right_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn right_spanset_span(ss: *const SpanSet, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> bool;
}
extern "C" {
    pub fn right_text_set(txt: *mut text, s: *const Set) -> bool;
}
extern "C" {
    #[doc = " Set functions for set and span types"]
    pub fn intersection_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn intersection_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn intersection_span_bigint(s: *const Span, i: int64) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_date(s: *const Span, d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_float(s: *const Span, d: f64) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_span(s1: *const Span, s2: *const Span) -> *mut Span;
}
extern "C" {
    pub fn intersection_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn intersection_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn intersection_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn intersection_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_bigint_span(i: int64, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_bigint_spanset(i: int64, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_date_span(d: DateADT, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_date_spanset(d: DateADT, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_float_span(d: f64, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_float_spanset(d: f64, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_int_span(i: ::std::os::raw::c_int, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_int_spanset(i: ::std::os::raw::c_int, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn minus_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn minus_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn minus_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn minus_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn minus_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn minus_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn minus_span_bigint(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_date(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_float(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_span(s1: *const Span, s2: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn minus_timestamptz_span(t: TimestampTz, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn minus_timestamptz_spanset(t: TimestampTz, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_bigint_set(i: int64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_bigint_span(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_bigint_spanset(i: int64, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_date_set(d: DateADT, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_date_span(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_date_spanset(d: DateADT, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_float_set(d: f64, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_float_span(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_float_spanset(d: f64, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_geo_set(gs: *const GSERIALIZED, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_int_set(i: ::std::os::raw::c_int, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_int_span(i: ::std::os::raw::c_int, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_int_spanset(i: ::std::os::raw::c_int, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_set_bigint(s: *const Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn union_set_date(s: *const Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn union_set_float(s: *const Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn union_set_geo(s: *const Set, gs: *const GSERIALIZED) -> *mut Set;
}
extern "C" {
    pub fn union_set_int(s: *const Set, i: ::std::os::raw::c_int) -> *mut Set;
}
extern "C" {
    pub fn union_set_set(s1: *const Set, s2: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_set_text(s: *const Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn union_set_timestamptz(s: *const Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    pub fn union_span_bigint(s: *const Span, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_date(s: *const Span, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_float(s: *const Span, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_int(s: *const Span, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_span(s1: *const Span, s2: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_spanset(s: *const Span, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_span_timestamptz(s: *const Span, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_bigint(ss: *const SpanSet, i: int64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_date(ss: *const SpanSet, d: DateADT) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_float(ss: *const SpanSet, d: f64) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_int(ss: *const SpanSet, i: ::std::os::raw::c_int) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_span(ss: *const SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_spanset(ss1: *const SpanSet, ss2: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn union_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> *mut SpanSet;
}
extern "C" {
    pub fn union_text_set(txt: *const text, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_timestamptz_set(t: TimestampTz, s: *const Set) -> *mut Set;
}
extern "C" {
    pub fn union_timestamptz_span(t: TimestampTz, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn union_timestamptz_spanset(t: TimestampTz, ss: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    #[doc = " Distance functions for set and span types"]
    pub fn distance_bigintset_bigintset(s1: *const Set, s2: *const Set) -> int64;
}
extern "C" {
    pub fn distance_bigintspan_bigintspan(s1: *const Span, s2: *const Span) -> int64;
}
extern "C" {
    pub fn distance_bigintspanset_bigintspan(ss: *const SpanSet, s: *const Span) -> int64;
}
extern "C" {
    pub fn distance_bigintspanset_bigintspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> int64;
}
extern "C" {
    pub fn distance_dateset_dateset(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespan_datespan(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespanset_datespan(
        ss: *const SpanSet,
        s: *const Span,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_datespanset_datespanset(
        ss1: *const SpanSet,
        ss2: *const SpanSet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_floatset_floatset(s1: *const Set, s2: *const Set) -> f64;
}
extern "C" {
    pub fn distance_floatspan_floatspan(s1: *const Span, s2: *const Span) -> f64;
}
extern "C" {
    pub fn distance_floatspanset_floatspan(ss: *const SpanSet, s: *const Span) -> f64;
}
extern "C" {
    pub fn distance_floatspanset_floatspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> f64;
}
extern "C" {
    pub fn distance_intset_intset(s1: *const Set, s2: *const Set) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspan_intspan(s1: *const Span, s2: *const Span) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspanset_intspan(ss: *const SpanSet, s: *const Span)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_intspanset_intspanset(
        ss1: *const SpanSet,
        ss2: *const SpanSet,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_bigint(s: *const Set, i: int64) -> int64;
}
extern "C" {
    pub fn distance_set_date(s: *const Set, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_float(s: *const Set, d: f64) -> f64;
}
extern "C" {
    pub fn distance_set_int(s: *const Set, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_set_timestamptz(s: *const Set, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_span_bigint(s: *const Span, i: int64) -> int64;
}
extern "C" {
    pub fn distance_span_date(s: *const Span, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_span_float(s: *const Span, d: f64) -> f64;
}
extern "C" {
    pub fn distance_span_int(s: *const Span, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_span_timestamptz(s: *const Span, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_spanset_bigint(ss: *const SpanSet, i: int64) -> int64;
}
extern "C" {
    pub fn distance_spanset_date(ss: *const SpanSet, d: DateADT) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_spanset_float(ss: *const SpanSet, d: f64) -> f64;
}
extern "C" {
    pub fn distance_spanset_int(
        ss: *const SpanSet,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn distance_spanset_timestamptz(ss: *const SpanSet, t: TimestampTz) -> f64;
}
extern "C" {
    pub fn distance_tstzset_tstzset(s1: *const Set, s2: *const Set) -> f64;
}
extern "C" {
    pub fn distance_tstzspan_tstzspan(s1: *const Span, s2: *const Span) -> f64;
}
extern "C" {
    pub fn distance_tstzspanset_tstzspan(ss: *const SpanSet, s: *const Span) -> f64;
}
extern "C" {
    pub fn distance_tstzspanset_tstzspanset(ss1: *const SpanSet, ss2: *const SpanSet) -> f64;
}
extern "C" {
    #[doc = " Aggregate functions for set and span types"]
    pub fn bigint_extent_transfn(state: *mut Span, i: int64) -> *mut Span;
}
extern "C" {
    pub fn bigint_union_transfn(state: *mut Set, i: int64) -> *mut Set;
}
extern "C" {
    pub fn date_extent_transfn(state: *mut Span, d: DateADT) -> *mut Span;
}
extern "C" {
    pub fn date_union_transfn(state: *mut Set, d: DateADT) -> *mut Set;
}
extern "C" {
    pub fn float_extent_transfn(state: *mut Span, d: f64) -> *mut Span;
}
extern "C" {
    pub fn float_union_transfn(state: *mut Set, d: f64) -> *mut Set;
}
extern "C" {
    pub fn int_extent_transfn(state: *mut Span, i: ::std::os::raw::c_int) -> *mut Span;
}
extern "C" {
    pub fn int_union_transfn(state: *mut Set, i: int32) -> *mut Set;
}
extern "C" {
    pub fn set_extent_transfn(state: *mut Span, s: *const Set) -> *mut Span;
}
extern "C" {
    pub fn set_union_finalfn(state: *mut Set) -> *mut Set;
}
extern "C" {
    pub fn set_union_transfn(state: *mut Set, s: *mut Set) -> *mut Set;
}
extern "C" {
    pub fn span_extent_transfn(state: *mut Span, s: *const Span) -> *mut Span;
}
extern "C" {
    pub fn span_union_transfn(state: *mut SpanSet, s: *const Span) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_extent_transfn(state: *mut Span, ss: *const SpanSet) -> *mut Span;
}
extern "C" {
    pub fn spanset_union_finalfn(state: *mut SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn spanset_union_transfn(state: *mut SpanSet, ss: *const SpanSet) -> *mut SpanSet;
}
extern "C" {
    pub fn text_union_transfn(state: *mut Set, txt: *const text) -> *mut Set;
}
extern "C" {
    pub fn timestamptz_extent_transfn(state: *mut Span, t: TimestampTz) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_union_transfn(state: *mut Set, t: TimestampTz) -> *mut Set;
}
extern "C" {
    #[doc = " Input and output functions for box types"]
    pub fn tbox_in(str_: *const ::std::os::raw::c_char) -> *mut TBox;
}
extern "C" {
    pub fn tbox_out(box_: *const TBox, maxdd: ::std::os::raw::c_int)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tbox_from_wkb(wkb: *const u8, size: usize) -> *mut TBox;
}
extern "C" {
    pub fn tbox_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut TBox;
}
extern "C" {
    pub fn stbox_from_wkb(wkb: *const u8, size: usize) -> *mut STBox;
}
extern "C" {
    pub fn stbox_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut STBox;
}
extern "C" {
    pub fn tbox_as_wkb(box_: *const TBox, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn tbox_as_hexwkb(
        box_: *const TBox,
        variant: u8,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stbox_as_wkb(box_: *const STBox, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn stbox_as_hexwkb(
        box_: *const STBox,
        variant: u8,
        size: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stbox_in(str_: *const ::std::os::raw::c_char) -> *mut STBox;
}
extern "C" {
    pub fn stbox_out(
        box_: *const STBox,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Constructor functions for box types"]
    pub fn float_tstzspan_to_tbox(d: f64, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn float_timestamptz_to_tbox(d: f64, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn geo_tstzspan_to_stbox(gs: *const GSERIALIZED, s: *const Span) -> *mut STBox;
}
extern "C" {
    pub fn geo_timestamptz_to_stbox(gs: *const GSERIALIZED, t: TimestampTz) -> *mut STBox;
}
extern "C" {
    pub fn int_tstzspan_to_tbox(i: ::std::os::raw::c_int, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn int_timestamptz_to_tbox(i: ::std::os::raw::c_int, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn numspan_tstzspan_to_tbox(span: *const Span, s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn numspan_timestamptz_to_tbox(span: *const Span, t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn stbox_copy(box_: *const STBox) -> *mut STBox;
}
extern "C" {
    pub fn stbox_make(
        hasx: bool,
        hasz: bool,
        geodetic: bool,
        srid: int32,
        xmin: f64,
        xmax: f64,
        ymin: f64,
        ymax: f64,
        zmin: f64,
        zmax: f64,
        s: *const Span,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tbox_copy(box_: *const TBox) -> *mut TBox;
}
extern "C" {
    pub fn tbox_make(s: *const Span, p: *const Span) -> *mut TBox;
}
extern "C" {
    #[doc = " Conversion functions for box types"]
    pub fn float_to_tbox(d: f64) -> *mut TBox;
}
extern "C" {
    pub fn geo_to_stbox(gs: *const GSERIALIZED) -> *mut STBox;
}
extern "C" {
    pub fn int_to_tbox(i: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn set_to_tbox(s: *const Set) -> *mut TBox;
}
extern "C" {
    pub fn span_to_tbox(s: *const Span) -> *mut TBox;
}
extern "C" {
    pub fn spanset_to_tbox(ss: *const SpanSet) -> *mut TBox;
}
extern "C" {
    pub fn spatialset_to_stbox(s: *const Set) -> *mut STBox;
}
extern "C" {
    pub fn stbox_to_gbox(box_: *const STBox) -> *mut GBOX;
}
extern "C" {
    pub fn stbox_to_box3d(box_: *const STBox) -> *mut BOX3D;
}
extern "C" {
    pub fn stbox_to_geo(box_: *const STBox) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn stbox_to_tstzspan(box_: *const STBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_intspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_floatspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn tbox_to_tstzspan(box_: *const TBox) -> *mut Span;
}
extern "C" {
    pub fn timestamptz_to_stbox(t: TimestampTz) -> *mut STBox;
}
extern "C" {
    pub fn timestamptz_to_tbox(t: TimestampTz) -> *mut TBox;
}
extern "C" {
    pub fn tstzset_to_stbox(s: *const Set) -> *mut STBox;
}
extern "C" {
    pub fn tstzspan_to_stbox(s: *const Span) -> *mut STBox;
}
extern "C" {
    pub fn tstzspanset_to_stbox(ss: *const SpanSet) -> *mut STBox;
}
extern "C" {
    pub fn tnumber_to_tbox(temp: *const Temporal) -> *mut TBox;
}
extern "C" {
    pub fn tpoint_to_stbox(temp: *const Temporal) -> *mut STBox;
}
extern "C" {
    #[doc = " Accessor functions for box types"]
    pub fn stbox_hast(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_hasx(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_hasz(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_isgeodetic(box_: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_srid(box_: *const STBox) -> int32;
}
extern "C" {
    pub fn stbox_tmax(box_: *const STBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn stbox_tmax_inc(box_: *const STBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn stbox_tmin(box_: *const STBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn stbox_tmin_inc(box_: *const STBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn stbox_xmax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_xmin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_ymax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_ymin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_zmax(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn stbox_zmin(box_: *const STBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_hast(box_: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_hasx(box_: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_tmax(box_: *const TBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn tbox_tmax_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_tmin(box_: *const TBox, result: *mut TimestampTz) -> bool;
}
extern "C" {
    pub fn tbox_tmin_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_xmax(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_xmax_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tbox_xmin(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tbox_xmin_inc(box_: *const TBox, result: *mut bool) -> bool;
}
extern "C" {
    pub fn tboxfloat_xmax(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tboxfloat_xmin(box_: *const TBox, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tboxint_xmax(box_: *const TBox, result: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    pub fn tboxint_xmin(box_: *const TBox, result: *mut ::std::os::raw::c_int) -> bool;
}
extern "C" {
    #[doc = " Transformation functions for box types"]
    pub fn stbox_expand_space(box_: *const STBox, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn stbox_expand_time(box_: *const STBox, interv: *const Interval) -> *mut STBox;
}
extern "C" {
    pub fn stbox_get_space(box_: *const STBox) -> *mut STBox;
}
extern "C" {
    pub fn stbox_quad_split(box_: *const STBox, count: *mut ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn stbox_round(box_: *const STBox, maxdd: ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn stbox_set_srid(box_: *const STBox, srid: int32) -> *mut STBox;
}
extern "C" {
    pub fn stbox_shift_scale_time(
        box_: *const STBox,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_transform(box_: *const STBox, srid: int32) -> *mut STBox;
}
extern "C" {
    pub fn stbox_transform_pipeline(
        box_: *const STBox,
        pipelinestr: *mut ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut STBox;
}
extern "C" {
    pub fn tbox_expand_time(box_: *const TBox, interv: *const Interval) -> *mut TBox;
}
extern "C" {
    pub fn tbox_expand_float(box_: *const TBox, d: f64) -> *mut TBox;
}
extern "C" {
    pub fn tbox_expand_int(box_: *const TBox, i: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn tbox_round(box_: *const TBox, maxdd: ::std::os::raw::c_int) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_float(
        box_: *const TBox,
        shift: f64,
        width: f64,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_int(
        box_: *const TBox,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
        hasshift: bool,
        haswidth: bool,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tbox_shift_scale_time(
        box_: *const TBox,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut TBox;
}
extern "C" {
    #[doc = " Set functions for box types"]
    pub fn union_tbox_tbox(box1: *const TBox, box2: *const TBox, strict: bool) -> *mut TBox;
}
extern "C" {
    pub fn intersection_tbox_tbox(box1: *const TBox, box2: *const TBox) -> *mut TBox;
}
extern "C" {
    pub fn union_stbox_stbox(box1: *const STBox, box2: *const STBox, strict: bool) -> *mut STBox;
}
extern "C" {
    pub fn intersection_stbox_stbox(box1: *const STBox, box2: *const STBox) -> *mut STBox;
}
extern "C" {
    #[doc = " Bounding box functions for box types"]
    pub fn adjacent_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn adjacent_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn same_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn same_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn left_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overleft_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn right_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overright_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn before_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overbefore_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn after_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn overafter_tbox_tbox(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn left_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overleft_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn right_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overright_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn below_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overbelow_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn above_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overabove_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn front_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overfront_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn back_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overback_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn before_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overbefore_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn after_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn overafter_stbox_stbox(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    #[doc = " Comparison functions for box types"]
    pub fn tbox_eq(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_ne(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_cmp(box1: *const TBox, box2: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tbox_lt(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_le(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_ge(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn tbox_gt(box1: *const TBox, box2: *const TBox) -> bool;
}
extern "C" {
    pub fn stbox_eq(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_ne(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_cmp(box1: *const STBox, box2: *const STBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn stbox_lt(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_le(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_ge(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    pub fn stbox_gt(box1: *const STBox, box2: *const STBox) -> bool;
}
extern "C" {
    #[doc = " Input and output functions for temporal types"]
    pub fn tbool_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_in(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_from_mfjson(str_: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_from_wkb(wkb: *const u8, size: usize) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_from_hexwkb(hexwkb: *const ::std::os::raw::c_char) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tint_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tfloat_out(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttext_out(temp: *const Temporal) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_out(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_as_text(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tpoint_as_ewkt(
        temp: *const Temporal,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_as_mfjson(
        temp: *const Temporal,
        with_bbox: bool,
        flags: ::std::os::raw::c_int,
        precision: ::std::os::raw::c_int,
        srs: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_as_wkb(temp: *const Temporal, variant: u8, size_out: *mut usize) -> *mut u8;
}
extern "C" {
    pub fn temporal_as_hexwkb(
        temp: *const Temporal,
        variant: u8,
        size_out: *mut usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Constructor functions for temporal types"]
    pub fn tbool_from_base_temp(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tboolinst_make(b: bool, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tboolseq_from_base_tstzset(b: bool, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tboolseq_from_base_tstzspan(b: bool, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn tboolseqset_from_base_tstzspanset(b: bool, ss: *const SpanSet) -> *mut TSequenceSet;
}
extern "C" {
    pub fn temporal_copy(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_from_base_temp(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloatinst_make(d: f64, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tfloatseq_from_base_tstzspan(
        d: f64,
        s: *const Span,
        interp: interpType,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tfloatseq_from_base_tstzset(d: f64, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tfloatseqset_from_base_tstzspanset(
        d: f64,
        ss: *const SpanSet,
        interp: interpType,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tint_from_base_temp(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tintinst_make(i: ::std::os::raw::c_int, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tintseq_from_base_tstzspan(i: ::std::os::raw::c_int, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn tintseq_from_base_tstzset(i: ::std::os::raw::c_int, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tintseqset_from_base_tstzspanset(
        i: ::std::os::raw::c_int,
        ss: *const SpanSet,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tpoint_from_base_temp(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpointinst_make(gs: *const GSERIALIZED, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn tpointseq_from_base_tstzspan(
        gs: *const GSERIALIZED,
        s: *const Span,
        interp: interpType,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tpointseq_from_base_tstzset(gs: *const GSERIALIZED, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn tpointseqset_from_base_tstzspanset(
        gs: *const GSERIALIZED,
        ss: *const SpanSet,
        interp: interpType,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tsequence_make(
        instants: *mut *const TInstant,
        count: ::std::os::raw::c_int,
        lower_inc: bool,
        upper_inc: bool,
        interp: interpType,
        normalize: bool,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn tsequenceset_make(
        sequences: *mut *const TSequence,
        count: ::std::os::raw::c_int,
        normalize: bool,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tsequenceset_make_gaps(
        instants: *mut *const TInstant,
        count: ::std::os::raw::c_int,
        interp: interpType,
        maxt: *mut Interval,
        maxdist: f64,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn ttext_from_base_temp(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttextinst_make(txt: *const text, t: TimestampTz) -> *mut TInstant;
}
extern "C" {
    pub fn ttextseq_from_base_tstzspan(txt: *const text, s: *const Span) -> *mut TSequence;
}
extern "C" {
    pub fn ttextseq_from_base_tstzset(txt: *const text, s: *const Set) -> *mut TSequence;
}
extern "C" {
    pub fn ttextseqset_from_base_tstzspanset(
        txt: *const text,
        ss: *const SpanSet,
    ) -> *mut TSequenceSet;
}
extern "C" {
    #[doc = " Conversion functions for temporal types"]
    pub fn temporal_to_tstzspan(temp: *const Temporal) -> *mut Span;
}
extern "C" {
    pub fn tfloat_to_tint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tint_to_tfloat(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_to_span(temp: *const Temporal) -> *mut Span;
}
extern "C" {
    #[doc = " Accessor functions for temporal types"]
    pub fn tbool_end_value(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tbool_start_value(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tbool_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn tbool_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut bool,
    ) -> bool;
}
extern "C" {
    pub fn tbool_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut bool;
}
extern "C" {
    pub fn temporal_duration(temp: *const Temporal, boundspan: bool) -> *mut Interval;
}
extern "C" {
    pub fn temporal_end_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_end_sequence(temp: *const Temporal) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_end_timestamptz(temp: *const Temporal) -> TimestampTz;
}
extern "C" {
    pub fn temporal_hash(temp: *const Temporal) -> uint32;
}
extern "C" {
    pub fn temporal_instant_n(temp: *const Temporal, n: ::std::os::raw::c_int) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_instants(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TInstant;
}
extern "C" {
    pub fn temporal_interp(temp: *const Temporal) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_max_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_min_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_num_instants(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_num_sequences(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_num_timestamps(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_segments(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TSequence;
}
extern "C" {
    pub fn temporal_sequence_n(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_sequences(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut TSequence;
}
extern "C" {
    pub fn temporal_lower_inc(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_upper_inc(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_start_instant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_start_sequence(temp: *const Temporal) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_start_timestamptz(temp: *const Temporal) -> TimestampTz;
}
extern "C" {
    pub fn temporal_stops(
        temp: *const Temporal,
        maxdist: f64,
        minduration: *const Interval,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn temporal_subtype(temp: *const Temporal) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn temporal_time(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn temporal_timestamptz_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut TimestampTz,
    ) -> bool;
}
extern "C" {
    pub fn temporal_timestamps(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TimestampTz;
}
extern "C" {
    pub fn tfloat_end_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_max_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_min_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_start_value(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tfloat_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn tfloat_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn tfloat_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut f64;
}
extern "C" {
    pub fn tint_end_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_max_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_min_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_start_value(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tint_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tint_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tint_values(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn tnumber_integral(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tnumber_twavg(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tnumber_valuespans(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn tpoint_end_value(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_start_value(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_values(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut GSERIALIZED;
}
extern "C" {
    pub fn ttext_end_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_max_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_min_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_start_value(temp: *const Temporal) -> *mut text;
}
extern "C" {
    pub fn ttext_value_at_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        strict: bool,
        value: *mut *mut text,
    ) -> bool;
}
extern "C" {
    pub fn ttext_value_n(
        temp: *const Temporal,
        n: ::std::os::raw::c_int,
        result: *mut *mut text,
    ) -> bool;
}
extern "C" {
    pub fn ttext_values(temp: *const Temporal, count: *mut ::std::os::raw::c_int)
        -> *mut *mut text;
}
extern "C" {
    #[doc = " Transformation functions for temporal types"]
    pub fn float_degrees(value: f64, normalize: bool) -> f64;
}
extern "C" {
    pub fn temporal_scale_time(temp: *const Temporal, duration: *const Interval) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_set_interp(temp: *const Temporal, interp: interpType) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_shift_scale_time(
        temp: *const Temporal,
        shift: *const Interval,
        duration: *const Interval,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_shift_time(temp: *const Temporal, shift: *const Interval) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_to_tinstant(temp: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn temporal_to_tsequence(
        temp: *const Temporal,
        interp_str: *mut ::std::os::raw::c_char,
    ) -> *mut TSequence;
}
extern "C" {
    pub fn temporal_to_tsequenceset(
        temp: *const Temporal,
        interp_str: *mut ::std::os::raw::c_char,
    ) -> *mut TSequenceSet;
}
extern "C" {
    pub fn tfloat_floor(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_ceil(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_degrees(temp: *const Temporal, normalize: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_radians(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_round(temp: *const Temporal, maxdd: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_scale_value(temp: *const Temporal, width: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_shift_scale_value(temp: *const Temporal, shift: f64, width: f64)
        -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_shift_value(temp: *const Temporal, shift: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloatarr_round(
        temp: *mut *const Temporal,
        count: ::std::os::raw::c_int,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tint_scale_value(temp: *const Temporal, width: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tint_shift_scale_value(
        temp: *const Temporal,
        shift: ::std::os::raw::c_int,
        width: ::std::os::raw::c_int,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tint_shift_value(temp: *const Temporal, shift: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_round(temp: *const Temporal, maxdd: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform(temp: *const Temporal, srid: int32) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform_pipeline(
        temp: *const Temporal,
        pipelinestr: *mut ::std::os::raw::c_char,
        srid: int32,
        is_forward: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_transform_pj(
        temp: *const Temporal,
        srid: int32,
        pj: *const LWPROJ,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn lwproj_transform(srid_from: int32, srid_to: int32) -> *mut LWPROJ;
}
extern "C" {
    pub fn tpointarr_round(
        temp: *mut *const Temporal,
        count: ::std::os::raw::c_int,
        maxdd: ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    #[doc = " Modification functions for temporal types"]
    pub fn temporal_append_tinstant(
        temp: *mut Temporal,
        inst: *const TInstant,
        maxdist: f64,
        maxt: *mut Interval,
        expand: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_append_tsequence(
        temp: *mut Temporal,
        seq: *const TSequence,
        expand: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzspan(
        temp: *const Temporal,
        s: *const Span,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzspanset(
        temp: *const Temporal,
        ss: *const SpanSet,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_timestamptz(
        temp: *const Temporal,
        t: TimestampTz,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_delete_tstzset(
        temp: *const Temporal,
        s: *const Set,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_insert(
        temp1: *const Temporal,
        temp2: *const Temporal,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_merge(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_merge_array(
        temparr: *mut *mut Temporal,
        count: ::std::os::raw::c_int,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_update(
        temp1: *const Temporal,
        temp2: *const Temporal,
        connect: bool,
    ) -> *mut Temporal;
}
extern "C" {
    #[doc = " Restriction functions for temporal types"]
    pub fn tbool_at_value(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_minus_value(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_max(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_min(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzspan(temp: *const Temporal, s: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzspanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_timestamptz(temp: *const Temporal, t: TimestampTz) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_tstzset(temp: *const Temporal, s: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_at_values(temp: *const Temporal, set: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_max(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_min(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzspan(temp: *const Temporal, s: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzspanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_timestamptz(temp: *const Temporal, t: TimestampTz) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_tstzset(temp: *const Temporal, s: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_minus_values(temp: *const Temporal, set: *const Set) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_at_value(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_minus_value(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tint_at_value(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tint_minus_value(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_span(temp: *const Temporal, span: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_spanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_at_tbox(temp: *const Temporal, box_: *const TBox) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_span(temp: *const Temporal, span: *const Span) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_spanset(temp: *const Temporal, ss: *const SpanSet) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_minus_tbox(temp: *const Temporal, box_: *const TBox) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_geom_time(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        zspan: *const Span,
        period: *const Span,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_stbox(
        temp: *const Temporal,
        box_: *const STBox,
        border_inc: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_at_value(temp: *const Temporal, gs: *mut GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_geom_time(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        zspan: *const Span,
        period: *const Span,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_stbox(
        temp: *const Temporal,
        box_: *const STBox,
        border_inc: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_minus_value(temp: *const Temporal, gs: *mut GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_at_value(temp: *const Temporal, txt: *mut text) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_minus_value(temp: *const Temporal, txt: *mut text) -> *mut Temporal;
}
extern "C" {
    #[doc = " Comparison functions for temporal types"]
    pub fn temporal_cmp(temp1: *const Temporal, temp2: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn temporal_eq(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_ge(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_gt(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_le(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_lt(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn temporal_ne(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn always_eq_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_eq_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ne_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_ge_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_gt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_le_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn always_lt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_eq_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ge_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_gt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_le_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_lt_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_bool_tbool(b: bool, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_float_tfloat(d: f64, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_int_tint(
        i: ::std::os::raw::c_int,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_point_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tbool_bool(temp: *const Temporal, b: bool) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_temporal_temporal(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_text_ttext(txt: *const text, temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tfloat_float(temp: *const Temporal, d: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tint_int(
        temp: *const Temporal,
        i: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ever_ne_ttext_text(temp: *const Temporal, txt: *const text) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn teq_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_point_tpoint(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn teq_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn teq_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn teq_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tge_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tge_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tge_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tge_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tgt_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tle_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tle_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tle_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tle_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tlt_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn tne_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_float_tfloat(d: f64, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_int_tint(i: ::std::os::raw::c_int, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_point_tpoint(gs: *const GSERIALIZED, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tne_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tne_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn tne_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    #[doc = " Bounding box functions for temporal types"]
    pub fn adjacent_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn adjacent_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn adjacent_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn adjacent_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contained_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn contained_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn contained_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contained_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn contains_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn contains_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn contains_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn contains_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overlaps_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overlaps_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overlaps_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn same_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn same_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn same_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn same_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn same_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn above_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn above_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn above_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn after_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn after_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn after_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn after_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn back_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn back_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn back_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn before_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn before_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn before_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn before_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn below_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn below_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn below_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn front_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn front_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn front_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn left_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn left_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn left_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn left_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overabove_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overabove_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overabove_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overafter_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overafter_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overafter_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overafter_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overback_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overback_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overback_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_temporal_tstzspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overbefore_temporal_temporal(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overbefore_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overbefore_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbefore_tstzspan_temporal(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbelow_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overbelow_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overbelow_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overfront_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overfront_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overfront_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overleft_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overleft_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overleft_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn overright_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn overright_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn overright_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn overright_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_numspan_tnumber(s: *const Span, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_stbox_tpoint(box_: *const STBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tbox_tnumber(box_: *const TBox, temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tnumber_numspan(temp: *const Temporal, s: *const Span) -> bool;
}
extern "C" {
    pub fn right_tnumber_tbox(temp: *const Temporal, box_: *const TBox) -> bool;
}
extern "C" {
    pub fn right_tnumber_tnumber(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    pub fn right_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> bool;
}
extern "C" {
    pub fn right_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> bool;
}
extern "C" {
    #[doc = " Boolean functions for temporal types"]
    pub fn tand_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tand_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tand_tbool_tbool(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tbool_when_true(temp: *const Temporal) -> *mut SpanSet;
}
extern "C" {
    pub fn tnot_tbool(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tor_bool_tbool(b: bool, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tor_tbool_bool(temp: *const Temporal, b: bool) -> *mut Temporal;
}
extern "C" {
    pub fn tor_tbool_tbool(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    #[doc = " Mathematical functions for temporal types"]
    pub fn add_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn add_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn add_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn add_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn add_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn div_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn div_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn div_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn div_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn div_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn mult_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn mult_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn mult_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn sub_float_tfloat(d: f64, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn sub_int_tint(i: ::std::os::raw::c_int, tnumber: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tfloat_float(tnumber: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tint_int(tnumber: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn sub_tnumber_tnumber(
        tnumber1: *const Temporal,
        tnumber2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tfloat_derivative(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_abs(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_angular_difference(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_delta_value(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    #[doc = " Text functions for temporal types"]
    pub fn textcat_text_ttext(txt: *const text, temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn textcat_ttext_text(temp: *const Temporal, txt: *const text) -> *mut Temporal;
}
extern "C" {
    pub fn textcat_ttext_ttext(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_upper(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_lower(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn ttext_initcap(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    #[doc = " Distance functions for temporal types"]
    pub fn distance_tfloat_float(temp: *const Temporal, d: f64) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tnumber_tnumber(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tpoint_point(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn distance_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn nad_stbox_geo(box_: *const STBox, gs: *const GSERIALIZED) -> f64;
}
extern "C" {
    pub fn nad_stbox_stbox(box1: *const STBox, box2: *const STBox) -> f64;
}
extern "C" {
    pub fn nad_tint_int(temp: *const Temporal, i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tint_tbox(temp: *const Temporal, box_: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tint_tint(temp1: *const Temporal, temp2: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tboxint_tboxint(box1: *const TBox, box2: *const TBox) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nad_tfloat_float(temp: *const Temporal, d: f64) -> f64;
}
extern "C" {
    pub fn nad_tfloat_tfloat(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn nad_tfloat_tbox(temp: *const Temporal, box_: *const TBox) -> f64;
}
extern "C" {
    pub fn nad_tboxfloat_tboxfloat(box1: *const TBox, box2: *const TBox) -> f64;
}
extern "C" {
    pub fn nad_tpoint_geo(temp: *const Temporal, gs: *const GSERIALIZED) -> f64;
}
extern "C" {
    pub fn nad_tpoint_stbox(temp: *const Temporal, box_: *const STBox) -> f64;
}
extern "C" {
    pub fn nad_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn nai_tpoint_geo(temp: *const Temporal, gs: *const GSERIALIZED) -> *mut TInstant;
}
extern "C" {
    pub fn nai_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut TInstant;
}
extern "C" {
    pub fn shortestline_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn shortestline_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> *mut GSERIALIZED;
}
extern "C" {
    #[doc = " Spatial functions for temporal points"]
    pub fn bearing_point_point(
        gs1: *const GSERIALIZED,
        gs2: *const GSERIALIZED,
        result: *mut f64,
    ) -> bool;
}
extern "C" {
    pub fn bearing_tpoint_point(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        invert: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn bearing_tpoint_tpoint(temp1: *const Temporal, temp2: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_angular_difference(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_azimuth(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_convex_hull(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_cumulative_length(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_direction(temp: *const Temporal, result: *mut f64) -> bool;
}
extern "C" {
    pub fn tpoint_get_x(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_get_y(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_get_z(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_is_simple(temp: *const Temporal) -> bool;
}
extern "C" {
    pub fn tpoint_length(temp: *const Temporal) -> f64;
}
extern "C" {
    pub fn tpoint_speed(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_srid(temp: *const Temporal) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tpoint_stboxes(temp: *const Temporal, count: *mut ::std::os::raw::c_int) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_trajectory(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn tpoint_twcentroid(temp: *const Temporal) -> *mut GSERIALIZED;
}
extern "C" {
    pub fn geo_expand_space(gs: *const GSERIALIZED, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn geomeas_to_tpoint(gs: *const GSERIALIZED) -> *mut Temporal;
}
extern "C" {
    pub fn tgeogpoint_to_tgeompoint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tgeompoint_to_tgeogpoint(temp: *const Temporal) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_AsMVTGeom(
        temp: *const Temporal,
        bounds: *const STBox,
        extent: i32,
        buffer: i32,
        clip_geom: bool,
        gsarr: *mut *mut GSERIALIZED,
        timesarr: *mut *mut int64,
        count: *mut ::std::os::raw::c_int,
    ) -> bool;
}
extern "C" {
    pub fn tpoint_expand_space(temp: *const Temporal, d: f64) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_make_simple(
        temp: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tpoint_set_srid(temp: *const Temporal, srid: int32) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_tfloat_to_geomeas(
        tpoint: *const Temporal,
        measure: *const Temporal,
        segmentize: bool,
        result: *mut *mut GSERIALIZED,
    ) -> bool;
}
extern "C" {
    pub fn acontains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn aintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn econtains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn edwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn eintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn etouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcontains_geo_tpoint(
        gs: *const GSERIALIZED,
        temp: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdisjoint_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdisjoint_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdwithin_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        dist: f64,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tdwithin_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        dist: f64,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tintersects_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn tintersects_tpoint_tpoint(
        temp1: *const Temporal,
        temp2: *const Temporal,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn ttouches_tpoint_geo(
        temp: *const Temporal,
        gs: *const GSERIALIZED,
        restr: bool,
        atvalue: bool,
    ) -> *mut Temporal;
}
extern "C" {
    #[doc = " Aggregate functions for temporal types"]
    pub fn tbool_tand_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tbool_tor_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn temporal_extent_transfn(s: *mut Span, temp: *const Temporal) -> *mut Span;
}
extern "C" {
    pub fn temporal_tagg_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tcount_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_tsum_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wmax_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wmin_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tfloat_wsum_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn timestamptz_tcount_transfn(state: *mut SkipList, t: TimestampTz) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_tsum_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wmax_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wmin_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tint_wsum_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tnumber_extent_transfn(box_: *mut TBox, temp: *const Temporal) -> *mut TBox;
}
extern "C" {
    pub fn tnumber_tavg_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn tnumber_tavg_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tnumber_wavg_transfn(
        state: *mut SkipList,
        temp: *const Temporal,
        interv: *const Interval,
    ) -> *mut SkipList;
}
extern "C" {
    pub fn tpoint_extent_transfn(box_: *mut STBox, temp: *const Temporal) -> *mut STBox;
}
extern "C" {
    pub fn tpoint_tcentroid_finalfn(state: *mut SkipList) -> *mut Temporal;
}
extern "C" {
    pub fn tpoint_tcentroid_transfn(state: *mut SkipList, temp: *mut Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn tstzset_tcount_transfn(state: *mut SkipList, s: *const Set) -> *mut SkipList;
}
extern "C" {
    pub fn tstzspan_tcount_transfn(state: *mut SkipList, s: *const Span) -> *mut SkipList;
}
extern "C" {
    pub fn tstzspanset_tcount_transfn(state: *mut SkipList, ss: *const SpanSet) -> *mut SkipList;
}
extern "C" {
    pub fn ttext_tmax_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    pub fn ttext_tmin_transfn(state: *mut SkipList, temp: *const Temporal) -> *mut SkipList;
}
extern "C" {
    #[doc = " Analytics functions for temporal types"]
    pub fn temporal_simplify_dp(
        temp: *const Temporal,
        eps_dist: f64,
        synchronized: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_max_dist(
        temp: *const Temporal,
        eps_dist: f64,
        synchronized: bool,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_min_dist(temp: *const Temporal, dist: f64) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_simplify_min_tdelta(
        temp: *const Temporal,
        mint: *const Interval,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tprecision(
        temp: *const Temporal,
        duration: *const Interval,
        origin: TimestampTz,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_tsample(
        temp: *const Temporal,
        duration: *const Interval,
        origin: TimestampTz,
        interp: interpType,
    ) -> *mut Temporal;
}
extern "C" {
    pub fn temporal_dyntimewarp_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn temporal_dyntimewarp_path(
        temp1: *const Temporal,
        temp2: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Match;
}
extern "C" {
    pub fn temporal_frechet_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn temporal_frechet_path(
        temp1: *const Temporal,
        temp2: *const Temporal,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Match;
}
extern "C" {
    pub fn temporal_hausdorff_distance(temp1: *const Temporal, temp2: *const Temporal) -> f64;
}
extern "C" {
    pub fn float_bucket(value: f64, size: f64, origin: f64) -> f64;
}
extern "C" {
    pub fn floatspan_bucket_list(
        bounds: *const Span,
        size: f64,
        origin: f64,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn int_bucket(
        value: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn intspan_bucket_list(
        bounds: *const Span,
        size: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
extern "C" {
    pub fn stbox_tile(
        point: *mut GSERIALIZED,
        t: TimestampTz,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *mut Interval,
        sorigin: *mut GSERIALIZED,
        torigin: TimestampTz,
        hast: bool,
    ) -> *mut STBox;
}
extern "C" {
    pub fn stbox_tile_list(
        bounds: *const STBox,
        xsize: f64,
        ysize: f64,
        zsize: f64,
        duration: *const Interval,
        sorigin: *mut GSERIALIZED,
        torigin: TimestampTz,
        border_inc: bool,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut STBox;
}
extern "C" {
    pub fn temporal_time_split(
        temp: *mut Temporal,
        duration: *mut Interval,
        torigin: TimestampTz,
        time_buckets: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloat_value_split(
        temp: *mut Temporal,
        size: f64,
        origin: f64,
        value_buckets: *mut *mut f64,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloat_value_time_split(
        temp: *mut Temporal,
        size: f64,
        duration: *mut Interval,
        vorigin: f64,
        torigin: TimestampTz,
        value_buckets: *mut *mut f64,
        time_buckets: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tfloatbox_tile(
        value: f64,
        t: TimestampTz,
        vsize: f64,
        duration: *mut Interval,
        vorigin: f64,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tfloatbox_tile_list(
        box_: *const TBox,
        xsize: f64,
        duration: *const Interval,
        xorigin: f64,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn timestamptz_bucket(
        timestamp: TimestampTz,
        duration: *const Interval,
        origin: TimestampTz,
    ) -> TimestampTz;
}
extern "C" {
    pub fn tint_value_split(
        temp: *mut Temporal,
        size: ::std::os::raw::c_int,
        origin: ::std::os::raw::c_int,
        value_buckets: *mut *mut ::std::os::raw::c_int,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tint_value_time_split(
        temp: *mut Temporal,
        size: ::std::os::raw::c_int,
        duration: *mut Interval,
        vorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
        value_buckets: *mut *mut ::std::os::raw::c_int,
        time_buckets: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tintbox_tile(
        value: ::std::os::raw::c_int,
        t: TimestampTz,
        vsize: ::std::os::raw::c_int,
        duration: *mut Interval,
        vorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tintbox_tile_list(
        box_: *const TBox,
        xsize: ::std::os::raw::c_int,
        duration: *const Interval,
        xorigin: ::std::os::raw::c_int,
        torigin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut TBox;
}
extern "C" {
    pub fn tpoint_space_split(
        temp: *mut Temporal,
        xsize: f32,
        ysize: f32,
        zsize: f32,
        sorigin: *mut GSERIALIZED,
        bitmatrix: bool,
        border_inc: bool,
        space_buckets: *mut *mut *mut GSERIALIZED,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tpoint_space_time_split(
        temp: *mut Temporal,
        xsize: f32,
        ysize: f32,
        zsize: f32,
        duration: *mut Interval,
        sorigin: *mut GSERIALIZED,
        torigin: TimestampTz,
        bitmatrix: bool,
        border_inc: bool,
        space_buckets: *mut *mut *mut GSERIALIZED,
        time_buckets: *mut *mut TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut *mut Temporal;
}
extern "C" {
    pub fn tstzspan_bucket_list(
        bounds: *const Span,
        duration: *const Interval,
        origin: TimestampTz,
        count: *mut ::std::os::raw::c_int,
    ) -> *mut Span;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
